/*******************************************************************************
 * Team_GameBase generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Team_GameBase extends TeamGame
    dependson(Misc_PlayerDataManager_ServerLink)
    dependson(Misc_PawnReplicationInfo)
    dependson(TAM_TeamInfo)
    dependson(TAM_TeamInfoRed)
    dependson(TAM_TeamInfoBlue)
    dependson(Team_HUDBase)
    dependson(Misc_Util)
    dependson(Misc_Bot)
    dependson(Misc_PlayerData)
    dependson(TournamentModuleBase)
    dependson(WeaponFire_Shield)
    hidecategories(Movement,Collision,Lighting,LightColor,Karma,Force)
    config
    abstract;

struct SEndCeremonyInfo
{
    var string PlayerName;
    var string CharacterName;
    var int PlayerTeam;
    var Vector SpawnPos;
    var Rotator SpawnRot;
};

struct ControllerArray
{
    var array<Controller> C;
};

var config int StartingHealth;
var config int StartingArmor;
var config float MaxHealth;
var float AdrenalinePerDamage;
var config bool bDisableSpeed;
var config bool bDisableBooster;
var config bool bDisableInvis;
var config bool bDisableBerserk;
var array<string> EnabledCombos;
var config bool bForceRUP;
var config int ForceRUPMinPlayers;
var config int ForceSeconds;
var Controller DarkHorse;
var string NextMapString;
var byte Deaths[2];
var bool bDefaultsReset;
var config int MinsPerRound;
var int RoundTime;
var bool bRoundOT;
var int RoundOTTime;
var config int OTDamage;
var config int OTInterval;
var config float CampThreshold;
var int CampInterval;
var config bool bKickExcessiveCampers;
var config int TimeOuts;
var byte TimeOutTeam;
var PlayerController TimeOutPlayer;
var int TeamTimeOuts[2];
var int TimeOutCount;
var float TimeOutRemainder;
var float LastTimeOutUpdate;
var config int TimeOutDuration;
var bool bFirstSpawn;
var bool bEndOfRound;
var bool bRespawning;
var int RespawnTime;
var int NextRoundTime;
var config int NextRoundDelay;
var int CurrentRound;
var config bool bModifyShieldGun;
var config int AssaultAmmo;
var config int AssaultGrenades;
var config int BioAmmo;
var config int ShockAmmo;
var config int LinkAmmo;
var config int MiniAmmo;
var config int FlakAmmo;
var config int RocketAmmo;
var config int LightningAmmo;
var config int EndOfRoundDelay;
var int EndOfRoundTime;
var PlayerReplicationInfo EndOfRoundScorer;
var config bool RoundCanTie;
var bool EndGameCalled;
var config bool EnableNewNet;
var TAM_Mutator MutTAM;
var int WinningTeamIndex;
var array<Controller> EndCeremonyRankings;
var SEndCeremonyInfo ServerEndCeremonyInfo[10];
var int EndCeremonyPlayerCount;
var int EndCeremonySoundIdx;
var config array<string> EndCeremonySound;
var config bool EndCeremonyEnabled;
var config bool EndCeremonyStatsEnabled;
var int EndCeremonyTimer;
var int EndCeremonyStatsListDisplayTime;
var config bool AllowPersistentStatsWithBots;
var Misc_PlayerDataManager_ServerLink PlayerDataManager_ServerLink;
var bool DisablePersistentStatsForMatch;
var bool MatchStatsRegistered;
var config bool bSpawnProtectionOnRez;
var config bool AutoBalanceTeams;
var config float AutoBalanceRandomization;
var config float AutoBalanceAvgPPRWeight;
var config int AutoBalanceSeconds;
var config bool AutoBalanceOnJoins;
var config bool AllowForceAutoBalance;
var config int ForceAutoBalanceCooldown;
var int ForceAutoBalanceTimer;
var bool TeamsAutoBalanced;
var array<Controller> DontAutoBalanceList;
var bool ForceAutoBalance;
var config bool ServerLinkEnabled;
var config string ServerLinkAddress;
var config int ServerLinkPort;
var config string ServerLinkAccount;
var config string ServerLinkPassword;
var config string ShieldTextureName;
var config string FlagTextureName;
var config bool ShowServerName;
var config bool FlagTextureEnabled;
var config bool FlagTextureShowAcronym;
var config string SoundAloneName;
var config string SoundSpawnProtectionName;
var config bool AllowServerSaveSettings;
var config bool AlwaysRestartServerWhenEmpty;
var Sound OvertimeSound;
var config bool EnforceMaxPlayers;
var TournamentModuleBase TournamentModule;
var config string TournamentModuleClass;

static function PrecacheGameTextures(LevelInfo myLevel)
{
    class'xTeamGame'.static.PrecacheGameTextures(myLevel);
    //return;    
}

static function PrecacheGameStaticMeshes(LevelInfo myLevel)
{
    class'xDeathMatch'.static.PrecacheGameStaticMeshes(myLevel);
    //return;    
}

function InitGameReplicationInfo()
{
    super(DeathMatch).InitGameReplicationInfo();
    // End:0x18
    if(Misc_BaseGRI(GameReplicationInfo) == none)
    {
        return;
    }
    Misc_BaseGRI(GameReplicationInfo).RoundTime = MinsPerRound * 60;
    Misc_BaseGRI(GameReplicationInfo).StartingHealth = StartingHealth;
    Misc_BaseGRI(GameReplicationInfo).StartingArmor = StartingArmor;
    Misc_BaseGRI(GameReplicationInfo).MaxHealth = MaxHealth;
    Misc_BaseGRI(GameReplicationInfo).MinsPerRound = MinsPerRound;
    Misc_BaseGRI(GameReplicationInfo).OTDamage = OTDamage;
    Misc_BaseGRI(GameReplicationInfo).OTInterval = OTInterval;
    Misc_BaseGRI(GameReplicationInfo).CampThreshold = CampThreshold;
    Misc_BaseGRI(GameReplicationInfo).bKickExcessiveCampers = bKickExcessiveCampers;
    Misc_BaseGRI(GameReplicationInfo).bDisableSpeed = bDisableSpeed;
    Misc_BaseGRI(GameReplicationInfo).bDisableInvis = bDisableInvis;
    Misc_BaseGRI(GameReplicationInfo).bDisableBooster = bDisableBooster;
    Misc_BaseGRI(GameReplicationInfo).bDisableBerserk = bDisableBerserk;
    Misc_BaseGRI(GameReplicationInfo).bForceRUP = bForceRUP;
    Misc_BaseGRI(GameReplicationInfo).ForceRUPMinPlayers = ForceRUPMinPlayers;
    Misc_BaseGRI(GameReplicationInfo).TimeOuts = TimeOuts;
    Misc_BaseGRI(GameReplicationInfo).Acronym = Acronym;
    Misc_BaseGRI(GameReplicationInfo).EnableNewNet = EnableNewNet;
    Misc_BaseGRI(GameReplicationInfo).ShieldTextureName = ShieldTextureName;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureName = FlagTextureName;
    Misc_BaseGRI(GameReplicationInfo).ShowServerName = ShowServerName;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureEnabled = FlagTextureEnabled;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureShowAcronym = FlagTextureShowAcronym;
    Misc_BaseGRI(GameReplicationInfo).SoundAloneName = SoundAloneName;
    Misc_BaseGRI(GameReplicationInfo).SoundSpawnProtectionName = SoundSpawnProtectionName;
    //return;    
}

function GetServerDetails(out ServerResponseLine ServerState)
{
    super.GetServerDetails(ServerState);
    AddServerDetail(ServerState, "3SPN Version", class'Misc_BaseGRI'.default.Version);
    //return;    
}

function GetServerPlayers(out ServerResponseLine ServerState)
{
    local Mutator M;
    local Controller C;
    local PlayerReplicationInfo PRI;
    local int i, TeamFlag;

    i = ServerState.PlayerInfo.Length;
    TeamFlag[0] = 1 << 29;
    TeamFlag[1] = TeamFlag[0] << 1;
    C = Level.ControllerList;
    J0x44:
    // End:0x1CF [Loop If]
    if(C != none)
    {
        PRI = C.PlayerReplicationInfo;
        // End:0x1B8
        if(((PRI != none) && !PRI.bBot) && MessagingSpectator(C) == none)
        {
            ServerState.PlayerInfo.Length = i + 1;
            ServerState.PlayerInfo[i].PlayerNum = C.PlayerNum;
            ServerState.PlayerInfo[i].PlayerName = Misc_PRI(PRI).GetColoredName();
            ServerState.PlayerInfo[i].Score = int(PRI.Score);
            ServerState.PlayerInfo[i].Ping = 4 * PRI.Ping;
            // End:0x1B1
            if(bTeamGame && PRI.Team != none)
            {
                ServerState.PlayerInfo[i].StatsID = ServerState.PlayerInfo[i].StatsID | TeamFlag[PRI.Team.TeamIndex];
            }
            ++ i;
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x44;
    }
    M = BaseMutator.NextMutator;
    J0x1E3:
    // End:0x219 [Loop If]
    if(M != none)
    {
        M.GetServerPlayers(ServerState);
        M = M.NextMutator;
        // [Loop Continue]
        goto J0x1E3;
    }
    // End:0x237
    if((Teams[0] == none) || Teams[1] == none)
    {
        return;
    }
    i = ServerState.PlayerInfo.Length;
    ServerState.PlayerInfo.Length = i + 2;
    ServerState.PlayerInfo[i].PlayerName = "Red Team";
    ServerState.PlayerInfo[i].Score = int(Teams[0].Score);
    ServerState.PlayerInfo[i + 1].PlayerName = "Blue Team";
    ServerState.PlayerInfo[i + 1].Score = int(Teams[1].Score);
    //return;    
}

static function FillPlayInfo(PlayInfo Pi)
{
    super.FillPlayInfo(Pi);
    Pi.UnresolvedNativeFunction_98("3SPN", "StartingHealth", "Starting Health", 0, 100, "Text", "3;0:999");
    Pi.UnresolvedNativeFunction_98("3SPN", "StartingArmor", "Starting Armor", 0, 101, "Text", "3;0:999");
    Pi.UnresolvedNativeFunction_98("3SPN", "MaxHealth", "Max Health", 0, 102, "Text", "8;1.0:2.0");
    Pi.UnresolvedNativeFunction_98("3SPN", "MinsPerRound", "Minutes per Round", 0, 120, "Text", "3;0:999");
    Pi.UnresolvedNativeFunction_98("3SPN", "OTDamage", "Overtime Damage", 0, 121, "Text", "3;0:999");
    Pi.UnresolvedNativeFunction_98("3SPN", "OTInterval", "Overtime Damage Interval", 0, 122, "Text", "3;0:999");
    Pi.UnresolvedNativeFunction_98("3SPN", "CampThreshold", "Camp Area", 0, 150, "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "bKickExcessiveCampers", "Kick Excessive Campers", 0, 151, "Check",,, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "bForceRUP", "Force Ready", 0, 175, "Check",,, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ForceRUPMinPlayers", "Force Ready Min Players", 0, 176, "Text", "3;0;999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ForceSeconds", "Force Time", 0, 177, "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "bDisableSpeed", "Disable Speed", 0, 200, "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "bDisableInvis", "Disable Invis", 0, 201, "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "bDisableBerserk", "Disable Berserk", 0, 202, "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "bDisableBooster", "Disable Booster", 0, 203, "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "Timeouts", "TimeOuts Per Team", 0, 220, "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "bModifyShieldGun", "Use Modified Shield Gun", 0, byte(299), "Check",,, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "AssaultAmmo", "Assault Ammunition", 0, byte(300), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "AssaultGrenades", "Assault Grenades", 0, byte(301), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "BioAmmo", "Bio Ammunition", 0, byte(302), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ShockAmmo", "Shock Ammunition", 0, byte(303), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "LinkAmmo", "Link Ammunition", 0, byte(304), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "MiniAmmo", "Mini Ammunition", 0, byte(305), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "FlakAmmo", "Flak Ammunition", 0, byte(306), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "RocketAmmo", "Rocket Ammunition", 0, byte(307), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "LightningAmmo", "Lightning Ammunition", 0, byte(308), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "EnableNewNet", "Enable New Net", 0, byte(400), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "EndCeremonyEnabled", "Enable End Ceremony", 0, byte(401), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AllowPersistentStatsWithBots", "Allow Persistent Stats With Bots", 0, byte(403), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "RoundCanTie", "Rounds Can Tie", 0, byte(404), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "bSpawnProtectionOnRez", "Enable Spawn Protection After Resurrection", 0, byte(405), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AutoBalanceTeams", "Automatically Balance Teams At Match Start", 0, byte(406), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AutoBalanceOnJoins", "Auto Balance Teams When New Players Join", 0, byte(407), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AllowForceAutoBalance", "Allow Forcing Auto Balance By Writing 'Teams' Into Chat", 0, byte(408), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "ForceAutoBalanceCooldown", "Force Auto Balance Cooldown Timer In Seconds", 0, byte(409), "Text", "3;0:100",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "AutoBalanceRandomization", "Randomization Percentage Used For Automatic Balancing", 0, byte(410), "Text", "3;0:100",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "AutoBalanceAvgPPRWeight", "Auto Balance Avg VS Current PPR Weight (Percent)", 0, byte(411), "Text", "3;0:100",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "AutoBalanceSeconds", "Auto Balance Teams Time", 0, byte(412), "Text", "3;0:100",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "TimeOutDuration", "Time Out Duration", 0, byte(413), "Text", "3;0:999",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "EnforceMaxPlayers", "Enforce Maximum Number Of Players (Tournament)", 0, byte(414), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "ServerLinkEnabled", "ServerLink Enabled", 0, byte(500), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "ServerLinkAddress", "ServerLink IP", 0, byte(501), "Text", "60",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ServerLinkPort", "ServerLink Port", 0, byte(502), "Text", "60",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ServerLinkAccount", "ServerLink Account", 0, byte(503), "Text", "60",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "ServerLinkPassword", "ServerLink Password", 0, byte(504), "Text", "60",, true);
    Pi.UnresolvedNativeFunction_98("3SPN", "EndCeremonyStatsEnabled", "Enable End Ceremony Stats List (ServerLink)", 0, byte(505), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AllowServerSaveSettings", "Allow Caching Player's 3SPN Settings On The Server", 0, byte(600), "Check");
    Pi.UnresolvedNativeFunction_98("3SPN", "AlwaysRestartServerWhenEmpty", "Always Restart Server When The Last Player Leaves", 0, byte(601), "Check");
    //return;    
}

static event string GetDescriptionText(string PropName)
{
    switch(PropName)
    {
        // End:0x38
        case "StartingHealth":
            return "Base health at round start.";
        // End:0x67
        case "StartingArmor":
            return "Base armor at round start.";
        // End:0x9C
        case "MinsPerRound":
            return "Round time-limit before overtime.";
        // End:0xD9
        case "OTDamage":
            return "The amount of damage all players while in OT.";
        // End:0x114
        case "OTInterval":
            return "The interval at which OT damage is given.";
        // End:0x15E
        case "MaxHealth":
            return "The maximum amount of health and armor a player can have.";
        // End:0x1AB
        case "CampThreshold":
            return "The area a player must stay in to be considered camping.";
        // End:0x1F3
        case "bKickExcessiveCampers":
            return "Kick players that camp 4 consecutive times.";
        // End:0x22B
        case "bDisableSpeed":
            return "Disable the Speed adrenaline combo.";
        // End:0x26A
        case "bDisableInvis":
            return "Disable the Invisibility adrenaline combo.";
        // End:0x2A6
        case "bDisableBooster":
            return "Disable the Booster adrenaline combo.";
        // End:0x2E2
        case "bDisableBerserk":
            return "Disable the Berserk adrenaline combo.";
        // End:0x327
        case "bForceRUP":
            return "Force players to ready up after a set amount of time";
        // End:0x385
        case "ForceRUPMinPlayers":
            return "Force players to ready only when at least this many players present.";
        // End:0x3E9
        case "ForceSeconds":
            return "The amount of time players have to ready up before the game starts automatically";
        // End:0x428
        case "Timeouts":
            return "Number of Timeouts a team can call in one game.";
        // End:0x47F
        case "bModifyShieldGun":
            return "The Shield Gun will have more kick back for higher shield jumps";
        // End:0x4C2
        case "AssaultAmmo":
            return "Amount of Assault Ammunition to give in a round.";
        // End:0x507
        case "AssaultGrenades":
            return "Amount of Assault Grenades to give in a round.";
        // End:0x548
        case "BioAmmo":
            return "Amount of Bio Rifle Ammunition to give in a round.";
        // End:0x589
        case "LinkAmmo":
            return "Amount of Link Gun Ammunition to give in a round.";
        // End:0x5C8
        case "ShockAmmo":
            return "Amount of Shock Ammunition to give in a round.";
        // End:0x605
        case "MiniAmmo":
            return "Amount of Mini Ammunition to give in a round.";
        // End:0x642
        case "FlakAmmo":
            return "Amount of Flak Ammunition to give in a round.";
        // End:0x683
        case "RocketAmmo":
            return "Amount of Rocket Ammunition to give in a round.";
        // End:0x6CA
        case "LightningAmmo":
            return "Amount of Lightning Ammunition to give in a round.";
        // End:0x70A
        case "EnableNewNet":
            return "Make enhanced netcode available for players.";
        // End:0x737
        case "EndCeremonyEnabled":
            return "Enable End Ceremony";
        // End:0x77B
        case "AllowPersistentStatsWithBots":
            return "Allow Persistent Stats With Bots";
        // End:0x79C
        case "RoundCanTie":
            return "Rounds Can Tie";
        // End:0x7E3
        case "bSpawnProtectionOnRez":
            return "Enable Spawn Protection After Resurrection";
        // End:0x825
        case "AutoBalanceTeams":
            return "Automatically Balance Teams At Match Start";
        // End:0x867
        case "AutoBalanceOnJoins":
            return "Auto Balance Teams When New Players Join";
        // End:0x8AE
        case "AllowForceAutoBalance":
            return "Automatically Balance Teams At Match Start";
        // End:0x8FA
        case "ForceAutoBalanceCooldown":
            return "Force Auto Balance Cooldown Timer In Seconds";
        // End:0x94F
        case "AutoBalanceRandomization":
            return "Randomization Percentage Used For Automatic Balancing";
        // End:0x99E
        case "AutoBalanceAvgPPRWeight":
            return "Auto Balance Avg VS Current PPR Weight (Percent)";
        // End:0x9CF
        case "AutoBalanceSeconds":
            return "Auto Balance Teams Time";
        // End:0x9F7
        case "TimeOutDuration":
            return "Time Out Duration";
        // End:0xA3E
        case "EnforceMaxPlayers":
            return "Enforce Maximum Number Of Players (Tournament)";
        // End:0xA69
        case "ServerLinkEnabled":
            return "ServerLink Enabled";
        // End:0xA8F
        case "ServerLinkAddress":
            return "ServerLink IP";
        // End:0xAB4
        case "ServerLinkPort":
            return "ServerLink Port";
        // End:0xADF
        case "ServerLinkAccount":
            return "ServerLink Account";
        // End:0xB0C
        case "ServerLinkPassword":
            return "ServerLink Password";
        // End:0xB56
        case "EndCeremonyStatsEnabled":
            return "Enable End Ceremony Stats List (ServerLink)";
        // End:0xBA7
        case "AllowServerSaveSettings":
            return "Allow Caching Player's 3SPN Settings On The Server";
        // End:0xBFC
        case "AlwaysRestartServerWhenEmpty":
            return "Always Restart Server When The Last Player Leaves";
        // End:0xFFFF
        default:
            return super.GetDescriptionText(PropName);
    }
    //return;    
}

function ParseOptions(string Options)
{
    local string InOpt;

    InOpt = ParseOption(Options, "StartingHealth");
    // End:0x3A
    if(InOpt != "")
    {
        StartingHealth = int(InOpt);
    }
    InOpt = ParseOption(Options, "StartingArmor");
    // End:0x73
    if(InOpt != "")
    {
        StartingArmor = int(InOpt);
    }
    InOpt = ParseOption(Options, "MaxHealth");
    // End:0xA8
    if(InOpt != "")
    {
        MaxHealth = float(InOpt);
    }
    InOpt = ParseOption(Options, "MinsPerRound");
    // End:0xE0
    if(InOpt != "")
    {
        MinsPerRound = int(InOpt);
    }
    InOpt = ParseOption(Options, "OTDamage");
    // End:0x114
    if(InOpt != "")
    {
        OTDamage = int(InOpt);
    }
    InOpt = ParseOption(Options, "OTInterval");
    // End:0x14A
    if(InOpt != "")
    {
        OTInterval = int(InOpt);
    }
    InOpt = ParseOption(Options, "CampThreshold");
    // End:0x183
    if(InOpt != "")
    {
        CampThreshold = float(InOpt);
    }
    InOpt = ParseOption(Options, "ForceRUP");
    // End:0x1B8
    if(InOpt != "")
    {
        bForceRUP = bool(InOpt);
    }
    InOpt = ParseOption(Options, "ForceRUPMinPlayers");
    // End:0x1F6
    if(InOpt != "")
    {
        ForceRUPMinPlayers = int(InOpt);
    }
    InOpt = ParseOption(Options, "KickExcessiveCampers");
    // End:0x237
    if(InOpt != "")
    {
        bKickExcessiveCampers = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableSpeed");
    // End:0x270
    if(InOpt != "")
    {
        bDisableSpeed = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableInvis");
    // End:0x2A9
    if(InOpt != "")
    {
        bDisableInvis = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableBerserk");
    // End:0x2E4
    if(InOpt != "")
    {
        bDisableBerserk = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableBooster");
    // End:0x31F
    if(InOpt != "")
    {
        bDisableBooster = bool(InOpt);
    }
    InOpt = ParseOption(Options, "Timeouts");
    // End:0x353
    if(InOpt != "")
    {
        TimeOuts = int(InOpt);
    }
    //return;    
}

event InitGame(string Options, out string Error)
{
    local class<TournamentModuleBase> TMClass;

    // End:0x11
    if(ServerLinkEnabled)
    {
        bEnableStatLogging = true;
    }
    super.InitGame(Options, Error);
    ParseOptions(Options);
    // End:0x6C
    if(TournamentModuleClass != "")
    {
        TMClass = class<TournamentModuleBase>(DynamicLoadObject(TournamentModuleClass, class'Class'));
        // End:0x6C
        if(TMClass != none)
        {
            TournamentModule = UnresolvedNativeFunction_97(TMClass);
        }
    }
    // End:0x90
    if(TournamentModule != none)
    {
        TournamentModule.InitGame(Options, Error);
    }
    // End:0xA4
    foreach DynamicActors(class'TAM_Mutator', MutTAM)
    {
        // End:0xA4
        break;        
    }    
    MutTAM.EnableNewNet = EnableNewNet;
    class'xPawn'.default.ControllerClass = class'Misc_Bot';
    DisablePersistentStatsForMatch = false;
    SpawnProtectionTime = 0.0;
    EndGameCalled = false;
    MaxLives = 1;
    bForceRespawn = true;
    bAllowWeaponThrowing = true;
    TimeOutCount = 0;
    TeamTimeOuts[0] = TimeOuts;
    TeamTimeOuts[1] = TimeOuts;
    MutTAM.InitWeapons(AssaultAmmo, AssaultGrenades, BioAmmo, ShockAmmo, LinkAmmo, MiniAmmo, FlakAmmo, RocketAmmo, LightningAmmo);
    // End:0x1DF
    if(bModifyShieldGun)
    {
        class'ShieldFire'.default.SelfForceScale = 1.50;
        class'ShieldFire'.default.SelfDamageScale = 0.10;
        class'ShieldFire'.default.MinSelfDamage = 0.0;
        class'WeaponFire_Shield'.default.SelfForceScale = 1.50;
        class'WeaponFire_Shield'.default.SelfDamageScale = 0.10;
        class'WeaponFire_Shield'.default.MinSelfDamage = 0.0;
    }
    // End:0x209
    if(!bDisableSpeed)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboSpeed";
    }
    // End:0x237
    if(!bDisableBooster)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboDefensive";
    }
    // End:0x263
    if(!bDisableBerserk)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboBerserk";
    }
    // End:0x28D
    if(!bDisableInvis)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboInvis";
    }
    // End:0x2D2
    if(ServerLinkEnabled)
    {
        PlayerDataManager_ServerLink = UnresolvedNativeFunction_97(class'Misc_PlayerDataManager_ServerLink');
        // End:0x2D2
        if(PlayerDataManager_ServerLink != none)
        {
            PlayerDataManager_ServerLink.ConfigureServerLink(ServerLinkAddress, ServerLinkPort, ServerLinkAccount, ServerLinkPassword);
        }
    }
    MatchStatsRegistered = false;
    SaveConfig();
    //return;    
}

static function bool AllowMutator(string MutatorClassName)
{
    // End:0x29
    if((MutatorClassName == "") || InStr(MutatorClassName, "UTComp") != -1)
    {
        return false;
    }
    return super(GameInfo).AllowMutator(MutatorClassName);
    //return;    
}

event PreLogin(string Options, string Address, string PlayerID, out string Error, out string FailCode)
{
    // End:0x33
    if(TournamentModule != none)
    {
        TournamentModule.PreLogin(Options, Address, PlayerID, Error, FailCode);
    }
    super(UnrealMPGameInfo).PreLogin(Options, Address, PlayerID, Error, FailCode);
    //return;    
}

function ChangeName(Controller Other, string S, bool bNameChange)
{
    local string OldName;
    local Misc_Player P;

    OldName = Other.PlayerReplicationInfo.PlayerName;
    super(DeathMatch).ChangeName(Other, S, bNameChange);
    LogInternal("Changed name to " $ S);
    // End:0x5B
    if(!bNameChange)
    {
        return;
    }
    // End:0x7E
    if(Other.PlayerReplicationInfo.PlayerName == OldName)
    {
        return;
    }
    P = Misc_Player(Other);
    // End:0x9B
    if(P == none)
    {
        return;
    }
    PlayerChangedName(P);
    //return;    
}

function int GetTimeoutState(PlayerController Caller)
{
    // End:0x0F
    if(bWaitingToStartMatch)
    {
        return -1;
    }
    // End:0x36
    if((Caller == none) || Caller.PlayerReplicationInfo == none)
    {
        return -1;
    }
    // End:0x53
    if(Caller.PlayerReplicationInfo.bAdmin)
    {
        return 0;
    }
    // End:0x78
    if((Level.TimeSeconds - LastTimeOutUpdate) < 3.0)
    {
        return -1;
    }
    // End:0x9B
    if(Caller.PlayerReplicationInfo.Team == none)
    {
        return -1;
    }
    // End:0xBC
    if(Caller.PlayerReplicationInfo.bOnlySpectator)
    {
        return -1;
    }
    // End:0xCA
    if(TimeOuts == 0)
    {
        return 3;
    }
    // End:0xF8
    if(TimeOutTeam == Caller.PlayerReplicationInfo.Team.TeamIndex)
    {
        return 1;
    }
    // End:0x127
    if(((TimeOutCount == -1) || TimeOutCount > 0) || TimeOutTeam != 255)
    {
        return 2;
    }
    // End:0x156
    if(TeamTimeOuts[Caller.PlayerReplicationInfo.Team.TeamIndex] <= 0)
    {
        return 4;
    }
    return 0;
    //return;    
}

function CallTimeout(PlayerController Caller)
{
    local Controller C;
    local int toState;

    toState = GetTimeoutState(Caller);
    // End:0x22
    if(toState == -1)
    {
        return;
    }
    LastTimeOutUpdate = Level.TimeSeconds;
    // End:0x8D
    if((Caller.PlayerReplicationInfo == none) || (Caller.PlayerReplicationInfo.Team == none) && !Caller.PlayerReplicationInfo.bAdmin)
    {
        return;
    }
    // End:0x2A1
    else
    {
        // End:0xD3
        if(toState == 3)
        {
            Caller.ClientMessage("Timeouts are disabled on this server");
            return;
        }
        // End:0x2A1
        else
        {
            // End:0x221
            if(toState == 1)
            {
                // End:0x12F
                if(TimeOutCount > 0)
                {
                    Caller.ClientMessage("You can not cancel a Timeout once it takes effect.");
                }
                // End:0x21C
                else
                {
                    EndTimeOut();
                    C = Level.ControllerList;
                    J0x149:
                    // End:0x21C [Loop If]
                    if(C != none)
                    {
                        // End:0x205
                        if((C != none) && C.UnresolvedNativeFunction_97('PlayerController'))
                        {
                            // End:0x1D1
                            if(Caller.PlayerReplicationInfo.Team.TeamIndex == 0)
                            {
                                PlayerController(C).ClientMessage("Red Team canceled the Timeout");
                            }
                            // End:0x205
                            else
                            {
                                PlayerController(C).ClientMessage("Blue Team canceled the Timeout");
                            }
                        }
                        C = C.nextController;
                        // [Loop Continue]
                        goto J0x149;
                    }
                }
                return;
            }
            // End:0x2A1
            else
            {
                // End:0x25F
                if(toState == 2)
                {
                    Caller.ClientMessage("A Timeout is already pending");
                    return;
                }
                // End:0x2A1
                else
                {
                    // End:0x2A1
                    if(toState == 4)
                    {
                        Caller.ClientMessage("Your team has no Timeouts remaining");
                        return;
                    }
                }
            }
        }
    }
    // End:0x401
    if(Caller.PlayerReplicationInfo.bAdmin)
    {
        // End:0x368
        if((TimeOutCount == -1) || TimeOutCount > 0)
        {
            EndTimeOut();
            C = Level.ControllerList;
            J0x2F2:
            // End:0x365 [Loop If]
            if(C != none)
            {
                // End:0x34E
                if((C != none) && C.UnresolvedNativeFunction_97('PlayerController'))
                {
                    PlayerController(C).ClientMessage("Admin canceled the Timeout");
                }
                C = C.nextController;
                // [Loop Continue]
                goto J0x2F2;
            }
        }
        // End:0x3FE
        else
        {
            TimeOutTeam = 3;
            TimeOutPlayer = Caller;
            C = Level.ControllerList;
            J0x38F:
            // End:0x3FE [Loop If]
            if(C != none)
            {
                // End:0x3E7
                if((C != none) && C.UnresolvedNativeFunction_97('PlayerController'))
                {
                    PlayerController(C).ClientMessage("Admin called a Timeout");
                }
                C = C.nextController;
                // [Loop Continue]
                goto J0x38F;
            }
        }
    }
    // End:0x4FA
    else
    {
        TimeOutTeam = byte(Caller.PlayerReplicationInfo.Team.TeamIndex);
        TimeOutPlayer = Caller;
        C = Level.ControllerList;
        J0x448:
        // End:0x4FA [Loop If]
        if(C != none)
        {
            // End:0x4E3
            if((C != none) && C.UnresolvedNativeFunction_97('PlayerController'))
            {
                // End:0x4B3
                if(TimeOutTeam == 0)
                {
                    PlayerController(C).ClientMessage("Red Team called a Timeout");
                }
                // End:0x4E3
                else
                {
                    PlayerController(C).ClientMessage("Blue Team called a Timeout");
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x448;
        }
    }
    //return;    
}

function EndTimeOut()
{
    Misc_BaseGRI(GameReplicationInfo).bGamePaused = false;
    GameReplicationInfo.bStopCountDown = false;
    TimeOutCount = 0;
    TimeOutTeam = default.TimeOutTeam;
    TimeOutPlayer = none;
    Level.Pauser = none;
    //return;    
}

function ScoreKill(Controller Killer, Controller Other)
{
    // End:0x0D
    if(Killer == none)
    {
        return;
    }
    super.ScoreKill(Killer, Other);
    //return;    
}

function int ReduceDamage(int Damage, Pawn injured, Pawn instigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType)
{
    local Misc_PRI PRI;
    local int OldDamage, NewDamage, RealDamage, Result;
    local float Score, RFF, FF;
    local Vector EyeHeight;

    // End:0x17
    if(bEndOfRound)
    {
        Momentum *= 2.0;
        return 0;
    }
    // End:0x4B
    if(DamageType == class'DamTypeSuperShockBeam')
    {
        return super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
    }
    // End:0xCF9
    if((((Misc_Pawn(instigatedBy) != none) && instigatedBy.Controller != none) && injured.GetTeamNum() != 255) && instigatedBy.GetTeamNum() != 255)
    {
        PRI = Misc_PRI(instigatedBy.PlayerReplicationInfo);
        // End:0xEA
        if(PRI == none)
        {
            return super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
        }
        // End:0x542
        if((injured.GetTeamNum() == instigatedBy.GetTeamNum()) && FriendlyFireScale > 0.0)
        {
            RFF = PRI.ReverseFF;
            // End:0x1AA
            if((RFF > 0.0) && injured != instigatedBy)
            {
                instigatedBy.TakeDamage(int((float(Damage) * RFF) * FriendlyFireScale), instigatedBy, HitLocation, Momentum, DamageType);
                Damage -= int((float(Damage) * RFF) * FriendlyFireScale);
            }
            OldDamage = PRI.AllyDamage;
            RealDamage = OldDamage + Damage;
            // End:0x252
            if(injured == instigatedBy)
            {
                // End:0x226
                if((class<DamType_Camping>(DamageType) != none) || class<DamType_Overtime>(DamageType) != none)
                {
                    return super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
                }
                // End:0x244
                if(class<DamTypeShieldImpact>(DamageType) != none)
                {
                    NewDamage = OldDamage;
                }
                // End:0x24F
                else
                {
                    NewDamage = RealDamage;
                }
            }
            // End:0x27F
            else
            {
                NewDamage = int(float(OldDamage) + (float(Damage) * (FriendlyFireScale - (FriendlyFireScale * RFF))));
            }
            PRI.AllyDamage = NewDamage;
            Score = float(NewDamage - OldDamage);
            // End:0x4E6
            if(Score > 0.0)
            {
                // End:0x3B9
                if(injured != instigatedBy)
                {
                    // End:0x337
                    if(RFF < 1.0)
                    {
                        RFF = FMin(RFF + (float(Damage) * 0.00150), 1.0);
                        GameEvent("RFFChange", string(RFF - PRI.ReverseFF), PRI);
                        PRI.ReverseFF = RFF;
                    }
                    EyeHeight.Z = instigatedBy.EyeHeight;
                    // End:0x3B9
                    if((Misc_Player(instigatedBy.Controller) != none) && FastTrace(injured.Location, instigatedBy.Location + EyeHeight))
                    {
                        Misc_Player(instigatedBy.Controller).hitdamage -= int(Score);
                    }
                }
                // End:0x49D
                if(Misc_Player(instigatedBy.Controller) != none)
                {
                    Misc_Player(instigatedBy.Controller).NewFriendlyDamage += (Score * 0.010);
                    // End:0x49D
                    if(Misc_Player(instigatedBy.Controller).NewFriendlyDamage >= 1.0)
                    {
                        ScoreEvent(PRI, float(-int(Misc_Player(instigatedBy.Controller).NewFriendlyDamage)), "FriendlyDamage");
                        Misc_Player(instigatedBy.Controller).NewFriendlyDamage -= float(int(Misc_Player(instigatedBy.Controller).NewFriendlyDamage));
                    }
                }
                PRI.Score -= (Score * 0.010);
                instigatedBy.Controller.AwardAdrenaline((-Score * 0.10) * AdrenalinePerDamage);
            }
            FF = FriendlyFireScale;
            FriendlyFireScale -= (FriendlyFireScale * RFF);
            Result = super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
            FriendlyFireScale = FF;
            return Result;
        }
        // End:0xCF9
        else
        {
            // End:0xCF9
            if(injured.GetTeamNum() != instigatedBy.GetTeamNum())
            {
                // End:0x5A1
                if(Misc_Pawn(injured).IsSpawnProtectionEnabled())
                {
                    return super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
                }
                OldDamage = PRI.EnemyDamage;
                NewDamage = OldDamage + Damage;
                PRI.EnemyDamage = NewDamage;
                Score = float(NewDamage - OldDamage);
                // End:0x78B
                if(Score > 0.0)
                {
                    // End:0x744
                    if(Misc_Player(instigatedBy.Controller) != none)
                    {
                        Misc_Player(instigatedBy.Controller).NewEnemyDamage += (Score * 0.010);
                        // End:0x6DD
                        if(Misc_Player(instigatedBy.Controller).NewEnemyDamage >= 1.0)
                        {
                            ScoreEvent(PRI, float(int(Misc_Player(instigatedBy.Controller).NewEnemyDamage)), "EnemyDamage");
                            Misc_Player(instigatedBy.Controller).NewEnemyDamage -= float(int(Misc_Player(instigatedBy.Controller).NewEnemyDamage));
                        }
                        EyeHeight.Z = instigatedBy.EyeHeight;
                        // End:0x744
                        if(FastTrace(injured.Location, instigatedBy.Location + EyeHeight))
                        {
                            Misc_Player(instigatedBy.Controller).hitdamage += int(Score);
                        }
                    }
                    PRI.Score += (Score * 0.010);
                    instigatedBy.Controller.AwardAdrenaline((Score * 0.10) * AdrenalinePerDamage);
                }
                // End:0x851
                if((float(Damage) > ((float(injured.Health) + injured.ShieldStrength) + float(50))) && (float(Damage) / (float(injured.Health) + injured.ShieldStrength)) > float(2))
                {
                    ++ PRI.OverkillCount;
                    SpecialEvent(PRI, "Overkill");
                    // End:0x851
                    if(Misc_Player(instigatedBy.Controller) != none)
                    {
                        Misc_Player(instigatedBy.Controller).ReceiveLocalizedMessage(class'Message_Overkill');
                    }
                }
                // End:0x89C
                if(DamageType == class'DamType_FlakChunk')
                {
                    ++ PRI.Flak.primary.Hit;
                    PRI.Flak.primary.Damage += Damage;
                }
                // End:0xCF9
                else
                {
                    // End:0x8E7
                    if(DamageType == class'DamType_FlakShell')
                    {
                        ++ PRI.Flak.Secondary.Hit;
                        PRI.Flak.Secondary.Damage += Damage;
                    }
                    // End:0xCF9
                    else
                    {
                        // End:0x928
                        if(DamageType == class'DamType_Rocket')
                        {
                            ++ PRI.Rockets.Hit;
                            PRI.Rockets.Damage += Damage;
                        }
                        // End:0xCF9
                        else
                        {
                            // End:0x969
                            if(DamageType == class'DamTypeSniperShot')
                            {
                                ++ PRI.Sniper.Hit;
                                PRI.Sniper.Damage += Damage;
                            }
                            // End:0xCF9
                            else
                            {
                                // End:0x9B4
                                if(DamageType == class'DamTypeShockBeam')
                                {
                                    ++ PRI.Shock.primary.Hit;
                                    PRI.Shock.primary.Damage += Damage;
                                }
                                // End:0xCF9
                                else
                                {
                                    // End:0x9FF
                                    if(DamageType == class'DamTypeShockBall')
                                    {
                                        ++ PRI.Shock.Secondary.Hit;
                                        PRI.Shock.Secondary.Damage += Damage;
                                    }
                                    // End:0xCF9
                                    else
                                    {
                                        // End:0xA40
                                        if(DamageType == class'DamType_ShockCombo')
                                        {
                                            ++ PRI.Combo.Hit;
                                            PRI.Combo.Damage += Damage;
                                        }
                                        // End:0xCF9
                                        else
                                        {
                                            // End:0xA8B
                                            if(DamageType == class'DamTypeMinigunBullet')
                                            {
                                                ++ PRI.Mini.primary.Hit;
                                                PRI.Mini.primary.Damage += Damage;
                                            }
                                            // End:0xCF9
                                            else
                                            {
                                                // End:0xAD6
                                                if(DamageType == class'DamTypeMinigunAlt')
                                                {
                                                    ++ PRI.Mini.Secondary.Hit;
                                                    PRI.Mini.Secondary.Damage += Damage;
                                                }
                                                // End:0xCF9
                                                else
                                                {
                                                    // End:0xB21
                                                    if(DamageType == class'DamTypeLinkPlasma')
                                                    {
                                                        ++ PRI.Link.Secondary.Hit;
                                                        PRI.Link.Secondary.Damage += Damage;
                                                    }
                                                    // End:0xCF9
                                                    else
                                                    {
                                                        // End:0xB6C
                                                        if(DamageType == class'DamTypeLinkShaft')
                                                        {
                                                            ++ PRI.Link.primary.Hit;
                                                            PRI.Link.primary.Damage += Damage;
                                                        }
                                                        // End:0xCF9
                                                        else
                                                        {
                                                            // End:0xBBD
                                                            if(DamageType == class'DamType_Headshot')
                                                            {
                                                                ++ PRI.HeadShots;
                                                                ++ PRI.Sniper.Hit;
                                                                PRI.Sniper.Damage += Damage;
                                                            }
                                                            // End:0xCF9
                                                            else
                                                            {
                                                                // End:0xBFE
                                                                if(DamageType == class'DamType_BioGlob')
                                                                {
                                                                    ++ PRI.Bio.Hit;
                                                                    PRI.Bio.Damage += Damage;
                                                                }
                                                                // End:0xCF9
                                                                else
                                                                {
                                                                    // End:0xC49
                                                                    if(DamageType == class'DamTypeAssaultBullet')
                                                                    {
                                                                        ++ PRI.Assault.primary.Hit;
                                                                        PRI.Assault.primary.Damage += Damage;
                                                                    }
                                                                    // End:0xCF9
                                                                    else
                                                                    {
                                                                        // End:0xC94
                                                                        if(DamageType == class'DamTypeAssaultGrenade')
                                                                        {
                                                                            ++ PRI.Assault.Secondary.Hit;
                                                                            PRI.Assault.Secondary.Damage += Damage;
                                                                        }
                                                                        // End:0xCF9
                                                                        else
                                                                        {
                                                                            // End:0xCD5
                                                                            if(DamageType == class'DamType_RocketHoming')
                                                                            {
                                                                                ++ PRI.Rockets.Hit;
                                                                                PRI.Rockets.Damage += Damage;
                                                                            }
                                                                            // End:0xCF9
                                                                            else
                                                                            {
                                                                                // End:0xCF9
                                                                                if(DamageType == class'DamTypeShieldImpact')
                                                                                {
                                                                                    PRI.SGDamage += Damage;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return super.ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
    //return;    
}

function NavigationPoint FindPlayerStart(Controller Player, optional byte InTeam, optional string incomingName)
{
    local NavigationPoint N, BestStart;
    local Teleporter Tel;
    local float BestRating, NewRating;
    local byte Team;

    // End:0x35
    if((Player != none) && Player.StartSpot != none)
    {
        LastPlayerStartSpot = Player.StartSpot;
    }
    // End:0x8B
    if((((Level.NetMode == NM_Standalone) && bWaitingToStartMatch) && Player != none) && Player.StartSpot != none)
    {
        return Player.StartSpot;
    }
    // End:0xCB
    if(GameRulesModifiers != none)
    {
        N = GameRulesModifiers.FindPlayerStart(Player, InTeam, incomingName);
        // End:0xCB
        if(N != none)
        {
            return N;
        }
    }
    // End:0x10A
    if(incomingName != "")
    {
        // End:0x109
        foreach AllActors(class'Teleporter', Tel)
        {
            // End:0x108
            if(string(Tel.Tag) ~= incomingName)
            {                
                return Tel;
            }            
        }        
    }
    // End:0x181
    if((Player != none) && Player.PlayerReplicationInfo != none)
    {
        // End:0x173
        if(Player.PlayerReplicationInfo.Team != none)
        {
            Team = byte(Player.PlayerReplicationInfo.Team.TeamIndex);
        }
        // End:0x17E
        else
        {
            Team = InTeam;
        }
    }
    // End:0x18C
    else
    {
        Team = InTeam;
    }
    N = Level.NavigationPointList;
    J0x1A0:
    // End:0x250 [Loop If]
    if(N != none)
    {
        // End:0x209
        if((N.UnresolvedNativeFunction_97('PathNode') || N.UnresolvedNativeFunction_97('PlayerStart')) || N.UnresolvedNativeFunction_97('JumpSpot'))
        {
            NewRating = RatePlayerStart(N, Team, Player);
        }
        // End:0x214
        else
        {
            NewRating = 1.0;
        }
        // End:0x239
        if(NewRating > BestRating)
        {
            BestRating = NewRating;
            BestStart = N;
        }
        N = N.nextNavigationPoint;
        // [Loop Continue]
        goto J0x1A0;
    }
    // End:0x325
    if(BestStart == none)
    {
        LogInternal("Warning - PATHS NOT DEFINED or NO PLAYERSTART with positive rating");
        BestRating = -100000000.0;
        // End:0x324
        foreach AllActors(class'NavigationPoint', N)
        {
            NewRating = RatePlayerStart(N, 0, Player);
            // End:0x2EF
            if(InventorySpot(N) != none)
            {
                NewRating -= float(50);
            }
            NewRating += (float(20) * FRand());
            // End:0x323
            if(NewRating > BestRating)
            {
                BestRating = NewRating;
                BestStart = N;
            }            
        }        
    }
    LastStartSpot = BestStart;
    // End:0x34F
    if(Player != none)
    {
        Player.StartSpot = BestStart;
    }
    // End:0x362
    if(!bWaitingToStartMatch)
    {
        bFirstSpawn = false;
    }
    return BestStart;
    //return;    
}

function float RatePlayerStart(NavigationPoint N, byte Team, Controller Player)
{
    local NavigationPoint P;
    local float Score, NextDist;
    local Controller OtherPlayer;

    P = N;
    // End:0x46
    if(((P == none) || P.PhysicsVolume.bWaterVolume) || Player == none)
    {
        return -10000000.0;
    }
    Score = 1000000.0;
    // End:0x108
    if(bFirstSpawn && LastPlayerStartSpot != none)
    {
        NextDist = VSize(N.Location - LastPlayerStartSpot.Location);
        Score += (NextDist * (0.250 + (0.750 * FRand())));
        // End:0xDA
        if((N == LastStartSpot) || N == LastPlayerStartSpot)
        {
            Score -= 100000000.0;
        }
        // End:0x108
        else
        {
            // End:0x108
            if(FastTrace(N.Location, LastPlayerStartSpot.Location))
            {
                Score -= 1000000.0;
            }
        }
    }
    OtherPlayer = Level.ControllerList;
    J0x11C:
    // End:0x31D [Loop If]
    if(OtherPlayer != none)
    {
        // End:0x306
        if(((OtherPlayer != none) && OtherPlayer.bIsPlayer) && OtherPlayer.Pawn != none)
        {
            NextDist = VSize(OtherPlayer.Pawn.Location - N.Location);
            // End:0x1CE
            if(NextDist < (OtherPlayer.Pawn.CollisionRadius + OtherPlayer.Pawn.CollisionHeight))
            {
                return 0.0;
            }
            // End:0x306
            else
            {
                // End:0x29A
                if((OtherPlayer.GetTeamNum() == Player.GetTeamNum()) && OtherPlayer != Player)
                {
                    // End:0x239
                    if(FastTrace(OtherPlayer.Pawn.Location, N.Location))
                    {
                        Score += 10000.0;
                    }
                    // End:0x25F
                    if(NextDist > float(1500))
                    {
                        Score -= (NextDist * float(10));
                    }
                    // End:0x297
                    else
                    {
                        // End:0x285
                        if(NextDist < float(1000))
                        {
                            Score += (NextDist * float(10));
                        }
                        // End:0x297
                        else
                        {
                            Score += (NextDist * float(20));
                        }
                    }
                }
                // End:0x306
                else
                {
                    // End:0x306
                    if(OtherPlayer.GetTeamNum() != Player.GetTeamNum())
                    {
                        // End:0x2F4
                        if(FastTrace(OtherPlayer.Pawn.Location, N.Location))
                        {
                            Score -= 20000.0;
                        }
                        Score += (NextDist * float(10));
                    }
                }
            }
        }
        OtherPlayer = OtherPlayer.nextController;
        // [Loop Continue]
        goto J0x11C;
    }
    return FMax(Score, 5.0);
    //return;    
}

function StartMatch()
{
    super(DeathMatch).StartMatch();
    CurrentRound = 1;
    Misc_BaseGRI(GameReplicationInfo).CurrentRound = 1;
    GameEvent("NewRound", string(CurrentRound), none);
    RoundTime = 60 * MinsPerRound;
    Misc_BaseGRI(GameReplicationInfo).RoundTime = RoundTime;
    RespawnTime = 2;
    EndOfRoundTime = 0;
    EndOfRoundScorer = none;
    NextRoundTime = 0;
    GameReplicationInfo.bStopCountDown = false;
    //return;    
}

function StartNewRound()
{
    local Controller C;

    RespawnTime = 4;
    bRoundOT = false;
    RoundOTTime = 0;
    RoundTime = 60 * MinsPerRound;
    bFirstSpawn = true;
    EndOfRoundTime = 0;
    EndOfRoundScorer = none;
    NextRoundTime = 0;
    GameReplicationInfo.bStopCountDown = false;
    Deaths[0] = 0;
    Deaths[1] = 0;
    ++ CurrentRound;
    Misc_BaseGRI(GameReplicationInfo).CurrentRound = CurrentRound;
    bEndOfRound = false;
    Misc_BaseGRI(GameReplicationInfo).bEndOfRound = false;
    DarkHorse = none;
    Misc_BaseGRI(GameReplicationInfo).RoundTime = RoundTime;
    Misc_BaseGRI(GameReplicationInfo).RoundMinute = RoundTime;
    Misc_BaseGRI(GameReplicationInfo).NetUpdateTime = Level.TimeSeconds - float(1);
    C = Level.ControllerList;
    J0x11A:
    // End:0x160 [Loop If]
    if(C != none)
    {
        // End:0x149
        if(PlayerController(C) != none)
        {
            PlayerController(C).UnPressButtons();
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x11A;
    }
    GameEvent("NewRound", string(CurrentRound), none);
    //return;    
}

event PlayerController Login(string Portal, string Options, out string Error)
{
    local string InName;
    local PlayerController PC;

    Options = class'Misc_Util'.static.SanitizeLoginOptions(Options);
    // End:0x3F
    if(TournamentModule != none)
    {
        Options = TournamentModule.ModifyLogin(Options);
    }
    InName = Left(ParseOption(Options, "Name"), 20);
    ReplaceText(InName, " ", "_");
    ReplaceText(InName, "|", "I");
    PC = super(DeathMatch).Login(Portal, Options, Error);
    // End:0x137
    if(PC != none)
    {
        // End:0xDD
        if(Misc_PRI(PC.PlayerReplicationInfo) != none)
        {
            Misc_PRI(PC.PlayerReplicationInfo).ColoredName = InName;
        }
        // End:0x137
        if(Misc_Player(PC) != none)
        {
            Misc_Player(PC).NextRezTime = Level.TimeSeconds + float(5);
            Misc_Player(PC).LoginTime = Level.TimeSeconds;
        }
    }
    return PC;
    //return;    
}

event PostLogin(PlayerController NewPlayer)
{
    local Misc_Player P;

    super.PostLogin(NewPlayer);
    P = Misc_Player(NewPlayer);
    // End:0x74
    if(IsInState('MatchOver') && P != none)
    {
        NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
        NewPlayer.PlayerReplicationInfo.NumLives = 0;
        StartCeremonyForPlayer(P);
    }
    // End:0x110
    else
    {
        // End:0xD2
        if(!bRespawning && CurrentRound > 0)
        {
            NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
            NewPlayer.PlayerReplicationInfo.NumLives = 0;
            NewPlayer.GotoState('Spectating');
        }
        // End:0x110
        else
        {
            NewPlayer.PlayerReplicationInfo.bOutOfLives = false;
            NewPlayer.PlayerReplicationInfo.NumLives = 1;
            RestartPlayer(NewPlayer);
        }
    }
    // End:0x140
    if(!NewPlayer.PlayerReplicationInfo.bOnlySpectator && AutoBalanceOnJoins)
    {
        ForceAutoBalance = true;
    }
    // End:0x164
    if(Misc_Player(NewPlayer) != none)
    {
        Misc_Player(NewPlayer).ClientKillBases();
    }
    PlayerJoined(P);
    CheckMaxLives(none);
    //return;    
}

function PlayerJoined(PlayerController C)
{
    local Misc_Player P;

    P = Misc_Player(C);
    // End:0x1D
    if(P == none)
    {
        return;
    }
    // End:0x3C
    if(PlayerDataManager_ServerLink != none)
    {
        PlayerDataManager_ServerLink.PlayerJoined(P);
    }
    //return;    
}

function PlayerLeft(PlayerController C)
{
    local Misc_Player P;

    P = Misc_Player(C);
    // End:0x1D
    if(P == none)
    {
        return;
    }
    // End:0x3C
    if(PlayerDataManager_ServerLink != none)
    {
        PlayerDataManager_ServerLink.PlayerLeft(P);
    }
    //return;    
}

function PlayerChangedName(PlayerController C)
{
    local Misc_Player P;

    P = Misc_Player(C);
    // End:0x1D
    if(P == none)
    {
        return;
    }
    // End:0x3C
    if(PlayerDataManager_ServerLink != none)
    {
        PlayerDataManager_ServerLink.PlayerChangedName(P);
    }
    //return;    
}

function Logout(Controller Exiting)
{
    // End:0x20
    if(PlayerController(Exiting) != none)
    {
        PlayerLeft(PlayerController(Exiting));
    }
    super(DeathMatch).Logout(Exiting);
    CheckMaxLives(none);
    // End:0x75
    if((((NumPlayers <= 0) && !bWaitingToStartMatch || AlwaysRestartServerWhenEmpty) && !bGameEnded) && !bGameRestarted)
    {
        RestartGame();
    }
    //return;    
}

function bool BecomeSpectator(PlayerController P)
{
    // End:0x6F
    if((Team_GameBase(Level.Game) != none) && Team_GameBase(Level.Game).TournamentModule != none)
    {
        // End:0x6F
        if(!Team_GameBase(Level.Game).TournamentModule.AllowBecomeSpectator(P))
        {
            return false;
        }
    }
    // End:0xAC
    if((P.PlayerReplicationInfo == none) || NumSpectators >= MaxSpectators)
    {
        P.ReceiveLocalizedMessage(GameMessageClass, 12);
        return false;
    }
    // End:0xD4
    if(GameStats != none)
    {
        GameStats.DisconnectEvent(P.PlayerReplicationInfo);
    }
    P.PlayerReplicationInfo.bOnlySpectator = true;
    ++ NumSpectators;
    -- NumPlayers;
    // End:0x10E
    if(!bKillBots)
    {
        ++ RemainingBots;
    }
    // End:0x12B
    if(!NeedPlayers() || AddBot())
    {
        -- RemainingBots;
    }
    return true;
    //return;    
}

function bool AllowBecomeActivePlayer(PlayerController P)
{
    local bool B;

    B = true;
    // End:0x77
    if((Team_GameBase(Level.Game) != none) && Team_GameBase(Level.Game).TournamentModule != none)
    {
        // End:0x77
        if(!Team_GameBase(Level.Game).TournamentModule.AllowBecomeActivePlayer(P))
        {
            return false;
        }
    }
    // End:0x84
    if(TournamentModule != none)
    {
        return false;
    }
    // End:0xC7
    if((P.PlayerReplicationInfo == none) || NumPlayers >= MaxPlayers)
    {
        P.ReceiveLocalizedMessage(GameMessageClass, 13);
        B = false;
    }
    // End:0x10B
    if((B && Level.NetMode == NM_Standalone) && NumBots > InitialBots)
    {
        -- RemainingBots;
        bPlayerBecameActive = true;
    }
    return B;
    //return;    
}

function bool AddBot(optional string botname)
{
    local Bot NewBot;

    NewBot = SpawnBot(botname);
    // End:0x36
    if(NewBot == none)
    {
        WarnInternal("Failed to spawn bot.");
        return false;
    }
    BroadcastLocalizedMessage(GameMessageClass, 1, NewBot.PlayerReplicationInfo);
    NewBot.PlayerReplicationInfo.PlayerID = ++ CurrentID;
    ++ NumBots;
    // End:0x100
    if(!bRespawning && CurrentRound > 0)
    {
        NewBot.PlayerReplicationInfo.bOutOfLives = true;
        NewBot.PlayerReplicationInfo.NumLives = 0;
        // End:0xE8
        if(Level.NetMode == NM_Standalone)
        {
            RestartPlayer(NewBot);
        }
        // End:0xFD
        else
        {
            NewBot.GotoState('Dead', 'MPStart');
        }
    }
    // End:0x13E
    else
    {
        NewBot.PlayerReplicationInfo.bOutOfLives = false;
        NewBot.PlayerReplicationInfo.NumLives = 1;
        RestartPlayer(NewBot);
    }
    CheckMaxLives(none);
    // End:0x17D
    if(((PlayerDataManager_ServerLink != none) && !AllowPersistentStatsWithBots) && !DisablePersistentStatsForMatch)
    {
        BroadcastLocalizedMessage(class'Message_StatsRecordingDisabled');
        DisablePersistentStatsForMatch = true;
    }
    return true;
    //return;    
}

function AddGameSpecificInventory(Pawn P)
{
    super(DeathMatch).AddGameSpecificInventory(P);
    // End:0x4D
    if(((P == none) || P.Controller == none) || P.Controller.PlayerReplicationInfo == none)
    {
        return;
    }
    SetupPlayer(P);
    //return;    
}

function AddDefaultInventory(Pawn P)
{
    super(DeathMatch).AddDefaultInventory(P);
    MutTAM.GiveAmmo(P);
    //return;    
}

function SetupPlayer(Pawn P)
{
    P.Health = StartingHealth;
    P.HealthMax = float(StartingHealth);
    P.SuperHealthMax = float(StartingHealth) * MaxHealth;
    xPawn(P).ShieldStrengthMax = float(StartingArmor) * MaxHealth;
    // End:0xB2
    if(Misc_Player(P.Controller) != none)
    {
        xPawn(P).Spree = Misc_Player(P.Controller).Spree;
    }
    //return;    
}

function UpdateTimeOut(float DeltaTime)
{
    // End:0x43
    if((TimeOutTeam == 4) && TimeOutCount == -1)
    {
        // End:0x43
        if(NumPlayers >= MaxPlayers)
        {
            TimeOutCount = 30;
            BroadcastLocalizedMessage(class'Message_MaxPlayers', 30);
        }
    }
    // End:0xD9
    if((TimeOutCount > 0) && TimeOutCount != -1)
    {
        TimeOutRemainder += DeltaTime;
        // End:0xD9
        if(TimeOutRemainder >= 1.0)
        {
            TimeOutRemainder -= 1.0;
            -- TimeOutCount;
            // End:0xB6
            if(((float(TimeOutCount) % float(10)) == float(0)) || TimeOutCount <= 5)
            {
                SendTimeoutCountText();
            }
            // End:0xD9
            if(TimeOutCount <= 0)
            {
                TimeOutCount = 0;
                TimeOutRemainder = 0.0;
                EndTimeOut();
            }
        }
    }
    //return;    
}

function RespawnTimer()
{
    local Actor Reset;
    local Controller C;

    -- RespawnTime;
    bRespawning = RespawnTime > 0;
    // End:0x22B
    if(RespawnTime == 3)
    {
        C = Level.ControllerList;
        J0x36:
        // End:0x1DF [Loop If]
        if(C != none)
        {
            // End:0x83
            if(Misc_Player(C) != none)
            {
                Misc_Player(C).Spree = 0;
                Misc_Player(C).ClientResetClock(MinsPerRound * 60);
            }
            // End:0xB7
            if((C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.bOnlySpectator)
            {
            }
            // End:0x1C8
            else
            {
                // End:0x13D
                if(xPawn(C.Pawn) != none)
                {
                    C.Pawn.RemovePowerups();
                    // End:0x128
                    if(Misc_Player(C) != none)
                    {
                        Misc_Player(C).Spree = xPawn(C.Pawn).Spree;
                    }
                    C.Pawn.Destroy();
                }
                C.PlayerReplicationInfo.bOutOfLives = false;
                C.PlayerReplicationInfo.NumLives = 1;
                // End:0x194
                if(PlayerController(C) != none)
                {
                    PlayerController(C).ClientReset();
                }
                C.Reset();
                // End:0x1C8
                if(PlayerController(C) != none)
                {
                    PlayerController(C).GotoState('Spectating');
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x36;
        }
        // End:0x22A
        foreach AllActors(class'Actor', Reset)
        {
            // End:0x20C
            if(DestroyActor(Reset))
            {
                Reset.Destroy();
                // End:0x229
                continue;
            }
            // End:0x229
            if(ResetActor(Reset))
            {
                Reset.Reset();
            }            
        }        
    }
    // End:0x392
    if(RespawnTime <= 3)
    {
        C = Level.ControllerList;
        J0x24B:
        // End:0x392 [Loop If]
        if(C != none)
        {
            // End:0x297
            if(((C == none) || C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.bOnlySpectator)
            {
            }
            // End:0x37B
            else
            {
                // End:0x37B
                if((PlayerController(C) != none) && (C.Pawn == none) || C.Pawn.Weapon == none)
                {
                    // End:0x305
                    if(C.Pawn != none)
                    {
                        C.Pawn.Destroy();
                    }
                    C.PlayerReplicationInfo.bOutOfLives = false;
                    C.PlayerReplicationInfo.NumLives = 1;
                    PlayerController(C).ClientReset();
                    C.Reset();
                    PlayerController(C).GotoState('Spectating');
                    RestartPlayer(C);
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x24B;
        }
    }
    //return;    
}

function CalcEndCeremonyRankings()
{
    local Controller C;
    local PlayerReplicationInfo PRI;
    local int i;

    EndCeremonyRankings.Length = 0;
    C = Level.ControllerList;
    J0x1C:
    // End:0x114 [Loop If]
    if(C != none)
    {
        // End:0x4B
        if((C == none) || C.PlayerReplicationInfo == none)
        {
        }
        // End:0xFD
        else
        {
            PRI = C.PlayerReplicationInfo;
            // End:0x8C
            if(PRI.bOnlySpectator || PRI.Score == float(0))
            {
            }
            // End:0xFD
            else
            {
                i = 0;
                J0x93:
                // End:0xE0 [Loop If]
                if(i < EndCeremonyRankings.Length)
                {
                    // End:0xD6
                    if(PRI.Score >= EndCeremonyRankings[i].PlayerReplicationInfo.Score)
                    {
                        // [Explicit Break]
                        goto J0xE0;
                    }
                    ++ i;
                    J0xE0:
                    // [Loop Continue]
                    goto J0x93;
                }
                EndCeremonyRankings.Insert(i, 1);
                EndCeremonyRankings[i] = C;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x1C;
    }
    EndCeremonyTimer = 0;
    //return;    
}

function StartCeremonyForPlayer(Misc_Player C)
{
    local int i;
    local string SoundName;

    i = 0;
    J0x07:
    // End:0x3F [Loop If]
    if(i < EndCeremonyPlayerCount)
    {
        C.ClientAddCeremonyRanking(i, ServerEndCeremonyInfo[i]);
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    // End:0x60
    if(EndCeremonySoundIdx < EndCeremonySound.Length)
    {
        SoundName = EndCeremonySound[EndCeremonySoundIdx];
    }
    C.ClientStartCeremony(EndCeremonyPlayerCount, WinningTeamIndex, SoundName);
    //return;    
}

function SendStatsListNameToPlayers(string ListName)
{
    local Controller C;

    // End:0x0F
    if(!IsInState('MatchOver'))
    {
        return;
    }
    C = Level.ControllerList;
    J0x23:
    // End:0x6E [Loop If]
    if(C != none)
    {
        // End:0x57
        if(Misc_Player(C) != none)
        {
            Misc_Player(C).ClientReceiveStatsListName(ListName);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x23;
    }
    //return;    
}

function SendStatsListIdxToPlayers(int PlayerIndex, string PlayerName, string PlayerStat)
{
    local Controller C;

    // End:0x0F
    if(!IsInState('MatchOver'))
    {
        return;
    }
    C = Level.ControllerList;
    J0x23:
    // End:0x87 [Loop If]
    if(C != none)
    {
        // End:0x70
        if(Misc_Player(C) != none)
        {
            Misc_Player(C).ClientReceiveStatsListIdx(PlayerIndex, class'Misc_Util'.static.FixUnicodeString(PlayerName), PlayerStat);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x23;
    }
    //return;    
}

function CleanUpPawns()
{
    local Pawn P;

    // End:0x5C
    foreach AllActors(class'Pawn', P)
    {
        // End:0x28
        if(P.Controller != none)
        {
            continue;            
        }
        // End:0x5B
        if((Level.TimeSeconds - P.LastStartTime) > float(3))
        {
            P.Destroy();
        }        
    }    
    //return;    
}

function RestartPlayer(Controller C)
{
    local Misc_Player MP;

    MP = Misc_Player(C);
    // End:0x97
    if(MP != none)
    {
        MP.ActiveThisRound = true;
        // End:0x97
        if((MP.PlayerData != none) && MP.PlayerReplicationInfo.Team != none)
        {
            MP.PlayerData.TeamIdx = MP.PlayerReplicationInfo.Team.TeamIndex;
        }
    }
    // End:0xBD
    if(Misc_Bot(C) != none)
    {
        Misc_Bot(C).ActiveThisRound = true;
    }
    super.RestartPlayer(C);
    //return;    
}

function bool DestroyActor(Actor A)
{
    // End:0x15
    if(Projectile(A) != none)
    {
        return true;
    }
    // End:0x72
    else
    {
        // End:0x60
        if((Pawn(A) != none) && (xPawn(A).Controller == none) || xPawn(A).PlayerReplicationInfo == none)
        {
            return true;
        }
        // End:0x72
        else
        {
            // End:0x72
            if(Inventory(A) != none)
            {
                return true;
            }
        }
    }
    return false;
    //return;    
}

function bool ResetActor(Actor A)
{
    // End:0x24
    if((Mover(A) != none) || DECO_ExplodingBarrel(A) != none)
    {
        return true;
    }
    return false;
    //return;    
}

function SortByAvgPPR(out array<Controller> Players)
{
    local int i, j;
    local float PPRi, PPRj;
    local Controller C;

    i = 0;
    J0x07:
    // End:0x135 [Loop If]
    if(i < Players.Length)
    {
        j = i + 1;
        J0x25:
        // End:0x12B [Loop If]
        if(j < Players.Length)
        {
            PPRi = 0.0;
            // End:0x87
            if(Misc_PRI(Players[i].PlayerReplicationInfo) != none)
            {
                PPRi = Misc_PRI(Players[i].PlayerReplicationInfo).AvgPPR;
            }
            PPRj = 0.0;
            // End:0xD9
            if(Misc_PRI(Players[j].PlayerReplicationInfo) != none)
            {
                PPRj = Misc_PRI(Players[j].PlayerReplicationInfo).AvgPPR;
            }
            // End:0x121
            if(PPRj < PPRi)
            {
                C = Players[i];
                Players[i] = Players[j];
                Players[j] = C;
            }
            ++ j;
            // [Loop Continue]
            goto J0x25;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    //return;    
}

function BalanceTeamsMatchStart()
{
    local array<Controller> Players;
    local ControllerArray TeamPlayers[2];
    local float TeamPPR[2];
    local Controller C;
    local int TeamIdx, i, j;
    local bool TeamsAreOdd;

    i = 0;
    J0x07:
    // End:0x41 [Loop If]
    if(i < 2)
    {
        TeamPlayers[i].C.Length = 0;
        TeamPPR[i] = 0.0;
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    C = Level.ControllerList;
    J0x55:
    // End:0xEB [Loop If]
    if(C != none)
    {
        // End:0xA8
        if(((PlayerController(C) == none) || C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.Team == none)
        {
        }
        // End:0xD4
        else
        {
            i = Players.Length;
            Players.Length = i + 1;
            Players[i] = C;
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x55;
    }
    // End:0xFA
    if(Players.Length <= 2)
    {
        return;
    }
    SortByAvgPPR(Players);
    J0x105:
    // End:0x347 [Loop If]
    if(Players.Length > 0)
    {
        i = Players.Length;
        // End:0x13A
        if(TeamPPR[0] < TeamPPR[1])
        {
            TeamIdx = 0;
        }
        // End:0x19C
        else
        {
            // End:0x157
            if(TeamPPR[0] > TeamPPR[1])
            {
                TeamIdx = 1;
            }
            // End:0x19C
            else
            {
                TeamIdx = Players[i - 1].PlayerReplicationInfo.Team.TeamIndex;
                // End:0x19C
                if(TeamIdx >= 2)
                {
                    TeamIdx = Rand(2);
                }
            }
        }
        // End:0x1BA
        if(float(Rand(100)) < AutoBalanceRandomization)
        {
            TeamIdx = 1 - TeamIdx;
        }
        j = TeamPlayers[TeamIdx].C.Length;
        TeamPlayers[TeamIdx].C.Insert(j, 1);
        TeamPlayers[TeamIdx].C[j] = Players[i - 1];
        // End:0x261
        if(Misc_PRI(Players[i - 1].PlayerReplicationInfo) != none)
        {
            TeamPPR[TeamIdx] += Misc_PRI(Players[i - 1].PlayerReplicationInfo).AvgPPR;
        }
        -- i;
        // End:0x330
        if(i >= 1)
        {
            j = TeamPlayers[1 - TeamIdx].C.Length;
            TeamPlayers[1 - TeamIdx].C.Insert(j, 1);
            TeamPlayers[1 - TeamIdx].C[j] = Players[i - 1];
            // End:0x326
            if(Misc_PRI(Players[i - 1].PlayerReplicationInfo) != none)
            {
                TeamPPR[1 - TeamIdx] += Misc_PRI(Players[i - 1].PlayerReplicationInfo).AvgPPR;
            }
            -- i;
        }
        // End:0x338
        else
        {
            TeamsAreOdd = true;
        }
        Players.Length = i;
        // [Loop Continue]
        goto J0x105;
    }
    i = 0;
    J0x34E:
    // End:0x37A [Loop If]
    if(i < 2)
    {
        AssignTeams(TeamPlayers[i], i);
        ++ i;
        // [Loop Continue]
        goto J0x34E;
    }
    BroadcastLocalizedMessage(class'Message_TeamsBalanced');
    ForceAutoBalance = false;
    DontAutoBalanceList.Length = 0;
    //return;    
}

function float GetPlayerAutoBalancingPPR(Controller C)
{
    local Misc_PRI PRI;
    local float PPR;

    PRI = Misc_PRI(C.PlayerReplicationInfo);
    // End:0x2A
    if(PRI == none)
    {
        return 0.0;
    }
    // End:0x67
    if(PRI.PlayedRounds > 0)
    {
        PPR = PRI.Score / float(PRI.PlayedRounds);
    }
    // End:0x7B
    else
    {
        PPR = PRI.Score;
    }
    return Lerp(AutoBalanceAvgPPRWeight / 100.0, PPR, PRI.AvgPPR);
    //return;    
}

function Controller FindBestAutoBalanceCandidate(int TeamIdx, float PPRNeeded)
{
    local float PPR, BestPPR;
    local Controller C, BestMatch;
    local int i;


    J0x00:    // End:0x1F [Loop If]
    if(DontAutoBalanceList.Length > (NumPlayers / 2))
    {
        DontAutoBalanceList.Remove(0, 1);
        // [Loop Continue]
        goto J0x00;
    }
    C = Level.ControllerList;
    J0x33:
    // End:0x166 [Loop If]
    if(C != none)
    {
        i = 0;
        J0x45:
        // End:0x77 [Loop If]
        if(i < DontAutoBalanceList.Length)
        {
            // End:0x6D
            if(DontAutoBalanceList[i] == C)
            {
                J0x6D:
                // [Explicit Continue]
                goto J0x6D;
            }
            ++ i;
            // [Loop Continue]
            goto J0x45;
        }
        // End:0x14F
        if(((((PlayerController(C) != none) && C.PlayerReplicationInfo != none) && C.PlayerReplicationInfo.Team != none) && C.PlayerReplicationInfo.Team.TeamIndex == TeamIdx) && Misc_PRI(C.PlayerReplicationInfo) != none)
        {
            PPR = Abs(PPRNeeded - (GetPlayerAutoBalancingPPR(C)));
            // End:0x14F
            if((BestMatch == none) || PPR < BestPPR)
            {
                BestMatch = C;
                BestPPR = PPR;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x33;
    }
    return BestMatch;
    //return;    
}

function AutoBalanceSwitchPlayer(Controller C)
{
    local int TeamIdx, i;

    i = DontAutoBalanceList.Length;
    DontAutoBalanceList.Insert(i, 1);
    DontAutoBalanceList[i] = C;
    TeamIdx = C.PlayerReplicationInfo.Team.TeamIndex;
    Teams[TeamIdx].RemoveFromTeam(C);
    Teams[1 - TeamIdx].AddToTeam(C);
    //return;    
}

function BalanceTeamsRoundStart()
{
    local float TeamPPR[2];
    local int TeamSize[2], TeamScore;
    local Controller C, BestMatch, BestMatch2;
    local int TeamIdx, PlayersNeeded, PlayersMoved, i;
    local float PPRNeeded;
    local bool SwapPlayers;

    i = 0;
    J0x07:
    // End:0x3B [Loop If]
    if(i < 2)
    {
        TeamPPR[i] = 0.0;
        TeamSize[i] = 0;
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    C = Level.ControllerList;
    J0x4F:
    // End:0x15B [Loop If]
    if(C != none)
    {
        // End:0x90
        if((C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.Team == none)
        {
        }
        // End:0x144
        else
        {
            TeamScore[C.PlayerReplicationInfo.Team.TeamIndex] += int(Teams[C.PlayerReplicationInfo.Team.TeamIndex].Score);
            TeamPPR[C.PlayerReplicationInfo.Team.TeamIndex] += (GetPlayerAutoBalancingPPR(C));
            ++ TeamSize[C.PlayerReplicationInfo.Team.TeamIndex];
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x4F;
    }
    // End:0x17D
    if((TeamSize[0] == TeamSize[1]) && !ForceAutoBalance)
    {
        return;
    }
    // End:0x19A
    if(TeamSize[0] > TeamSize[1])
    {
        TeamIdx = 0;
    }
    // End:0x1A1
    else
    {
        TeamIdx = 1;
    }
    PlayersNeeded = (TeamSize[TeamIdx] - TeamSize[1 - TeamIdx]) / 2;
    PPRNeeded = (TeamPPR[TeamIdx] - TeamPPR[1 - TeamIdx]) / float(2);
    // End:0x2F3
    if((PlayersNeeded == 0) && ForceAutoBalance)
    {
        // End:0x220
        if(TeamScore[0] > TeamScore[1])
        {
            TeamIdx = 0;
        }
        // End:0x281
        else
        {
            // End:0x23D
            if(TeamScore[1] > TeamScore[0])
            {
                TeamIdx = 1;
            }
            // End:0x281
            else
            {
                // End:0x25A
                if(TeamPPR[0] > TeamPPR[1])
                {
                    TeamIdx = 0;
                }
                // End:0x281
                else
                {
                    // End:0x277
                    if(TeamPPR[1] > TeamPPR[0])
                    {
                        TeamIdx = 1;
                    }
                    // End:0x281
                    else
                    {
                        ForceAutoBalance = false;
                        return;
                    }
                }
            }
        }
        // End:0x2F3
        if(TeamSize[TeamIdx] >= TeamSize[1 - TeamIdx])
        {
            PlayersNeeded = 1;
            PPRNeeded = (TeamPPR[TeamIdx] - TeamPPR[1 - TeamIdx]) / float(2);
            // End:0x2F3
            if(TeamSize[TeamIdx] == TeamSize[1 - TeamIdx])
            {
                SwapPlayers = true;
            }
        }
    }
    PlayersMoved = 0;
    // End:0x313
    if(PlayersNeeded > 0)
    {
        PPRNeeded /= float(PlayersNeeded);
    }
    J0x313:
    // End:0x3CA [Loop If]
    if(PlayersNeeded > 0)
    {
        // End:0x38D
        if(SwapPlayers)
        {
            BestMatch = FindBestAutoBalanceCandidate(TeamIdx, PPRNeeded * float(2));
            BestMatch2 = FindBestAutoBalanceCandidate(1 - TeamIdx, PPRNeeded);
            // End:0x38A
            if((BestMatch != none) && BestMatch2 != none)
            {
                AutoBalanceSwitchPlayer(BestMatch);
                AutoBalanceSwitchPlayer(BestMatch2);
            }
        }
        // End:0x3B9
        else
        {
            BestMatch = FindBestAutoBalanceCandidate(TeamIdx, PPRNeeded);
            // End:0x3B9
            if(BestMatch != none)
            {
                AutoBalanceSwitchPlayer(BestMatch);
            }
        }
        -- PlayersNeeded;
        ++ PlayersMoved;
        // [Loop Continue]
        goto J0x313;
    }
    // End:0x3E0
    if(PlayersMoved > 0)
    {
        BroadcastLocalizedMessage(class'Message_TeamsBalanced');
    }
    ForceAutoBalance = false;
    //return;    
}

function QueueAutoBalance()
{
    // End:0x1A
    if(!AutoBalanceTeams || !AllowForceAutoBalance)
    {
        return;
    }
    // End:0x37
    if(ForceAutoBalanceTimer > 0)
    {
        BroadcastLocalizedMessage(class'Message_ForceAutoBalanceCooldown', ForceAutoBalanceTimer);
        return;
    }
    ForceAutoBalance = true;
    ForceAutoBalanceTimer = ForceAutoBalanceCooldown;
    BroadcastLocalizedMessage(class'Message_ForceAutoBalance');
    //return;    
}

function AssignTeams(ControllerArray TeamPlayers, int TeamIdx)
{
    local int i;
    local Controller C;

    i = 0;
    J0x07:
    // End:0xFE [Loop If]
    if(i < TeamPlayers.C.Length)
    {
        C = TeamPlayers.C[i];
        // End:0x9F
        if(C.PlayerReplicationInfo.Team != none)
        {
            // End:0x79
            if(C.PlayerReplicationInfo.Team == Teams[TeamIdx])
            {
                // [Explicit Continue]
                goto J0xF4;
            }
            C.PlayerReplicationInfo.Team.RemoveFromTeam(C);
        }
        Teams[TeamIdx].AddToTeam(C);
        // End:0xF4
        if(PlayerController(C) != none)
        {
            GameEvent("TeamChange", "" $ string(TeamIdx), C.PlayerReplicationInfo);
        }
        J0xF4:
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    //return;    
}

function byte PickTeam(byte Num, Controller C)
{
    local UnrealTeamInfo SmallTeam, BigTeam, NewTeam;
    local Controller B;
    local int BigTeamBots, SmallTeamBots;

    // End:0x3A
    if(bPlayersVsBots && Level.NetMode != NM_Standalone)
    {
        // End:0x37
        if(PlayerController(C) != none)
        {
            return 1;
        }
        return 0;
    }
    SmallTeam = Teams[0];
    BigTeam = Teams[1];
    // End:0xD5
    if((SmallTeam.Size > BigTeam.Size) || (SmallTeam.Size == BigTeam.Size) && SmallTeam.Score > BigTeam.Score)
    {
        SmallTeam = Teams[1];
        BigTeam = Teams[0];
    }
    // End:0xF6
    if(Num < 2)
    {
        NewTeam = Teams[Num];
    }
    // End:0x10F
    if(NewTeam == none)
    {
        NewTeam = SmallTeam;
    }
    // End:0x329
    else
    {
        // End:0x329
        if((bPlayersBalanceTeams && Level.NetMode != NM_Standalone) && PlayerController(C) != none)
        {
            // End:0x174
            if(SmallTeam.Size < BigTeam.Size)
            {
                NewTeam = SmallTeam;
            }
            // End:0x329
            else
            {
                B = Level.ControllerList;
                J0x188:
                // End:0x22E [Loop If]
                if(B != none)
                {
                    // End:0x217
                    if((B.PlayerReplicationInfo != none) && B.PlayerReplicationInfo.bBot)
                    {
                        // End:0x1EF
                        if(B.PlayerReplicationInfo.Team == BigTeam)
                        {
                            ++ BigTeamBots;
                        }
                        // End:0x217
                        else
                        {
                            // End:0x217
                            if(B.PlayerReplicationInfo.Team == SmallTeam)
                            {
                                ++ SmallTeamBots;
                            }
                        }
                    }
                    B = B.nextController;
                    // [Loop Continue]
                    goto J0x188;
                }
                // End:0x2CC
                if(BigTeamBots > 0)
                {
                    // End:0x276
                    if((SmallTeam.Size - SmallTeamBots) < (BigTeam.Size - BigTeamBots))
                    {
                        NewTeam = SmallTeam;
                    }
                    // End:0x2C9
                    else
                    {
                        // End:0x2B3
                        if((BigTeam.Size - BigTeamBots) < (SmallTeam.Size - SmallTeamBots))
                        {
                            NewTeam = BigTeam;
                        }
                        // End:0x2C9
                        else
                        {
                            // End:0x2C9
                            if(SmallTeamBots == 0)
                            {
                                NewTeam = BigTeam;
                            }
                        }
                    }
                }
                // End:0x329
                else
                {
                    // End:0x2E5
                    if(SmallTeamBots > 0)
                    {
                        NewTeam = SmallTeam;
                    }
                    // End:0x329
                    else
                    {
                        // End:0x329
                        if(UnrealTeamInfo(C.PlayerReplicationInfo.Team) != none)
                        {
                            NewTeam = UnrealTeamInfo(C.PlayerReplicationInfo.Team);
                        }
                    }
                }
            }
        }
    }
    return byte(NewTeam.TeamIndex);
    //return;    
}

function CheckForCampers()
{
    local Controller C;
    local Misc_Pawn P;
    local Misc_PRI PRI;
    local Box HistoryBox;
    local float maxDim;
    local int i;

    C = Level.ControllerList;
    J0x14:
    // End:0x4C6 [Loop If]
    if(C != none)
    {
        // End:0x90
        if((((Misc_PRI(C.PlayerReplicationInfo) == none) || Misc_Pawn(C.Pawn) == none) || C.PlayerReplicationInfo.bOnlySpectator) || C.PlayerReplicationInfo.bOutOfLives)
        {
        }
        // End:0x4AF
        else
        {
            P = Misc_Pawn(C.Pawn);
            PRI = Misc_PRI(C.PlayerReplicationInfo);
            P.LocationHistory[P.NextLocHistSlot] = P.Location;
            ++ P.NextLocHistSlot;
            // End:0x134
            if(P.NextLocHistSlot == 10)
            {
                P.NextLocHistSlot = 0;
                P.bWarmedUp = true;
            }
            // End:0x4AF
            if(P.bWarmedUp)
            {
                HistoryBox.Min.X = P.LocationHistory[0].X;
                HistoryBox.Min.Y = P.LocationHistory[0].Y;
                HistoryBox.Min.Z = P.LocationHistory[0].Z;
                HistoryBox.Max.X = P.LocationHistory[0].X;
                HistoryBox.Max.Y = P.LocationHistory[0].Y;
                HistoryBox.Max.Z = P.LocationHistory[0].Z;
                i = 1;
                J0x22B:
                // End:0x39D [Loop If]
                if(i < 10)
                {
                    HistoryBox.Min.X = FMin(HistoryBox.Min.X, P.LocationHistory[i].X);
                    HistoryBox.Min.Y = FMin(HistoryBox.Min.Y, P.LocationHistory[i].Y);
                    HistoryBox.Min.Z = FMin(HistoryBox.Min.Z, P.LocationHistory[i].Z);
                    HistoryBox.Max.X = FMax(HistoryBox.Max.X, P.LocationHistory[i].X);
                    HistoryBox.Max.Y = FMax(HistoryBox.Max.Y, P.LocationHistory[i].Y);
                    HistoryBox.Max.Z = FMax(HistoryBox.Max.Z, P.LocationHistory[i].Z);
                    ++ i;
                    // [Loop Continue]
                    goto J0x22B;
                }
                maxDim = FMax(FMax(HistoryBox.Max.X - HistoryBox.Min.X, HistoryBox.Max.Y - HistoryBox.Min.Y), HistoryBox.Max.Z - HistoryBox.Min.Z);
                // End:0x458
                if((maxDim < CampThreshold) && P.ReWarnTime == 0)
                {
                    PunishCamper(C, P, PRI);
                    P.ReWarnTime = CampInterval;
                }
                // End:0x4AF
                else
                {
                    // End:0x48B
                    if(maxDim > CampThreshold)
                    {
                        PRI.bWarned = false;
                        PRI.ConsecutiveCampCount = 0;
                    }
                    // End:0x4AF
                    else
                    {
                        // End:0x4AF
                        if(P.ReWarnTime > 0)
                        {
                            -- P.ReWarnTime;
                        }
                    }
                }
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    //return;    
}

function PunishCamper(Controller C, Misc_Pawn P, Misc_PRI PRI)
{
    SendCamperWarning(C);
    // End:0xAA
    if((C.Pawn.Health <= (10 * (PRI.CampCount + 1))) && C.Pawn.ShieldStrength <= float(0))
    {
        C.Pawn.TakeDamage(1000, C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Camping');
    }
    // End:0x18C
    else
    {
        // End:0x112
        if(int(C.Pawn.ShieldStrength) > 0)
        {
            C.Pawn.ShieldStrength = float(Max(0, int(P.ShieldStrength - float(10 * (PRI.CampCount + 1)))));
        }
        // End:0x140
        else
        {
            C.Pawn.Health -= (10 * (PRI.CampCount + 1));
        }
        C.Pawn.TakeDamage(int(0.010), C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Camping');
    }
    // End:0x1B3
    if(!PRI.bWarned)
    {
        PRI.bWarned = true;
        return;
    }
    // End:0x27F
    if((Level.NetMode == NM_DedicatedServer) && (PRI.Ping * 4) < 999)
    {
        ++ PRI.CampCount;
        ++ PRI.ConsecutiveCampCount;
        // End:0x27F
        if(bKickExcessiveCampers && PRI.ConsecutiveCampCount >= 4)
        {
            AccessControl.DefaultKickReason = AccessControl.IdleKickReason;
            AccessControl.KickPlayer(PlayerController(C));
            AccessControl.DefaultKickReason = AccessControl.default.DefaultKickReason;
        }
    }
    //return;    
}

function SendCamperWarning(Controller Camper)
{
    local Controller C;

    C = Level.ControllerList;
    J0x14:
    // End:0x7E [Loop If]
    if(C != none)
    {
        // End:0x32
        if(Misc_Player(C) == none)
        {
        }
        // End:0x67
        else
        {
            Misc_Player(C).ReceiveLocalizedMessage(class'Message_Camper', int(C != Camper), Camper.PlayerReplicationInfo);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    //return;    
}

function SendTimeoutStartText()
{
    local Controller C;

    C = Level.ControllerList;
    J0x14:
    // End:0x64 [Loop If]
    if(C != none)
    {
        // End:0x4D
        if(PlayerController(C) != none)
        {
            PlayerController(C).ReceiveLocalizedMessage(class'Message_TimeOut', default.TimeOutDuration);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    //return;    
}

function SendTimeoutCountText()
{
    local Color Color;
    local string Yellow, TimeOutMsg;

    Color = class'Canvas'.static.MakeColor(210, 210, 0);
    Yellow = class'DMStatsScreen'.static.MakeColorCode(Color);
    TimeOutMsg = ((Yellow $ "Time Out ends in ") $ string(TimeOutCount)) $ " seconds...";
    Broadcast(self, TimeOutMsg);
    //return;    
}

function Killed(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    super(DeathMatch).Killed(Killer, Killed, KilledPawn, DamageType);
    // End:0x174
    if((Killed != none) && Killed.PlayerReplicationInfo != none)
    {
        // End:0xFA
        if(bRespawning && Freon(Level.Game) == none)
        {
            Killed.PlayerReplicationInfo.bOutOfLives = false;
            Killed.PlayerReplicationInfo.NumLives = 1;
            // End:0xB6
            if(PlayerController(Killed) != none)
            {
                PlayerController(Killed).ClientReset();
            }
            Killed.Reset();
            // End:0xEA
            if(PlayerController(Killed) != none)
            {
                PlayerController(Killed).GotoState('Spectating');
            }
            RestartPlayer(Killed);
            return;
        }
        // End:0x12D
        else
        {
            Killed.PlayerReplicationInfo.bOutOfLives = true;
            Killed.PlayerReplicationInfo.NumLives = 0;
        }
        // End:0x174
        if(Killed.GetTeamNum() != 255)
        {
            ++ Deaths[Killed.GetTeamNum()];
            CheckForAlone(Killed, Killed.GetTeamNum());
        }
    }
    //return;    
}

function CheckForAlone(Controller Died, int TeamIndex)
{
    local Controller C, Last;
    local int alive[2];

    // End:0x18
    if(DarkHorse == Died)
    {
        DarkHorse = none;
        return;
    }
    C = Level.ControllerList;
    J0x2C:
    // End:0xF7 [Loop If]
    if(C != none)
    {
        // End:0x77
        if(((C == Died) || C.Pawn == none) || C.GetTeamNum() == 255)
        {
        }
        // End:0xE0
        else
        {
            ++ alive[C.GetTeamNum()];
            // End:0xA1
            if(alive[TeamIndex] > 1)
            {
                return;
            }
            // End:0xE0
            if(C.GetTeamNum() == TeamIndex)
            {
                // End:0xD5
                if(alive[TeamIndex] != 1)
                {
                    Last = none;
                }
                // End:0xE0
                else
                {
                    Last = C;
                }
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x2C;
    }
    // End:0x117
    if((alive[TeamIndex] != 1) || Last == none)
    {
        return;
    }
    // End:0x13B
    if(Misc_Player(Last) != none)
    {
        Misc_Player(Last).ClientPlayAlone();
    }
    // End:0x180
    if((DarkHorse == none) && (alive[int(!bool(TeamIndex))] >= 3) && (NumPlayers + NumBots) >= 4)
    {
        DarkHorse = Last;
    }
    //return;    
}

function NotifyKilled(Controller Killer, Controller Other, Pawn OtherPawn)
{
    super.NotifyKilled(Killer, Other, OtherPawn);
    SendPlayerIsOutText(Other);
    //return;    
}

function SendPlayerIsOutText(Controller Out)
{
    local Controller C;

    // End:0x0D
    if(Out == none)
    {
        return;
    }
    C = Level.ControllerList;
    J0x21:
    // End:0x92 [Loop If]
    if(C != none)
    {
        // End:0x7B
        if(PlayerController(C) != none)
        {
            PlayerController(C).ReceiveLocalizedMessage(class'Message_PlayerIsOut', int(PlayerController(C) != PlayerController(Out)), Out.PlayerReplicationInfo);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x21;
    }
    //return;    
}

function bool CanSpectate(PlayerController Viewer, bool bOnlySpectator, Actor ViewTarget)
{
    // End:0x44
    if((xPawn(ViewTarget) == none) && (Controller(ViewTarget) == none) || xPawn(Controller(ViewTarget).Pawn) == none)
    {
        return false;
    }
    // End:0x9D
    if(bOnlySpectator)
    {
        // End:0x88
        if(Controller(ViewTarget) != none)
        {
            return (Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer;
        }
        // End:0x9D
        else
        {
            return xPawn(ViewTarget).IsPlayerPawn();
        }
    }
    // End:0xB3
    if(Viewer.Pawn != none)
    {
        return false;
    }
    // End:0xD6
    if(bRespawning || (NextRoundTime <= 1) && bEndOfRound)
    {
        return false;
    }
    // End:0x15E
    if(Controller(ViewTarget) != none)
    {
        return ((Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer) && bEndOfRound || (Controller(ViewTarget).GetTeamNum() == Viewer.GetTeamNum()) && Viewer.GetTeamNum() != 255;
    }
    // End:0x1DB
    else
    {
        return (xPawn(ViewTarget).IsPlayerPawn() && xPawn(ViewTarget).PlayerReplicationInfo != none) && bEndOfRound || (xPawn(ViewTarget).GetTeamNum() == Viewer.GetTeamNum()) && Viewer.GetTeamNum() != 255;
    }
    //return;    
}

function bool CheckMaxLives(PlayerReplicationInfo Scorer)
{
    local Controller C;
    local PlayerReplicationInfo Living;
    local bool bNoneLeft;

    // End:0x23
    if((bWaitingToStartMatch || bEndOfRound) || EndOfRoundTime > 0)
    {
        return false;
    }
    // End:0x5C
    if((!RoundCanTie && Scorer != none) && !Scorer.bOutOfLives)
    {
        Living = Scorer;
    }
    bNoneLeft = true;
    C = Level.ControllerList;
    J0x78:
    // End:0x190 [Loop If]
    if(C != none)
    {
        // End:0x179
        if(((((C.PlayerReplicationInfo != none) && C.bIsPlayer) && !C.PlayerReplicationInfo.bOutOfLives) && C.PlayerReplicationInfo.NumLives > 0) && !C.PlayerReplicationInfo.bOnlySpectator)
        {
            // End:0x12A
            if(Living == none)
            {
                Living = C.PlayerReplicationInfo;
            }
            // End:0x179
            else
            {
                // End:0x179
                if((C.PlayerReplicationInfo != Living) && C.PlayerReplicationInfo.Team != Living.Team)
                {
                    bNoneLeft = false;
                    // [Explicit Break]
                    goto J0x190;
                }
            }
        }
        C = C.nextController;
        J0x190:
        // [Loop Continue]
        goto J0x78;
    }
    // End:0x1D4
    if(bNoneLeft)
    {
        // End:0x1B2
        if(Living != none)
        {
            QueueEndRound(Living);
        }
        // End:0x1D2
        else
        {
            // End:0x1CB
            if(!RoundCanTie)
            {
                QueueEndRound(Scorer);
            }
            // End:0x1D2
            else
            {
                QueueEndRound(none);
            }
        }
        return true;
    }
    return false;
    //return;    
}

function QueueEndRound(PlayerReplicationInfo Scorer)
{
    // End:0x24
    if(EndOfRoundDelay > 0)
    {
        EndOfRoundScorer = Scorer;
        EndOfRoundTime = EndOfRoundDelay;
    }
    // End:0x2F
    else
    {
        EndRound(Scorer);
    }
    //return;    
}

function EndRound(PlayerReplicationInfo Scorer)
{
    local Controller C;

    EndTimeOut();
    bEndOfRound = true;
    Misc_BaseGRI(GameReplicationInfo).bEndOfRound = true;
    Misc_BaseGRI(GameReplicationInfo).NetUpdateTime = Level.TimeSeconds - float(1);
    AnnounceBest();
    AnnounceSurvivors();
    C = Level.ControllerList;
    J0x6B:
    // End:0x179 [Loop If]
    if(C != none)
    {
        // End:0xEC
        if((Misc_Player(C) != none) && Misc_Player(C).ActiveThisRound)
        {
            // End:0xD6
            if(Misc_PRI(C.PlayerReplicationInfo) != none)
            {
                ++ Misc_PRI(C.PlayerReplicationInfo).PlayedRounds;
            }
            Misc_Player(C).ActiveThisRound = false;
        }
        // End:0x162
        if((Misc_Bot(C) != none) && Misc_Bot(C).ActiveThisRound)
        {
            // End:0x14C
            if(Misc_PRI(C.PlayerReplicationInfo) != none)
            {
                ++ Misc_PRI(C.PlayerReplicationInfo).PlayedRounds;
            }
            Misc_Bot(C).ActiveThisRound = false;
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x6B;
    }
    // End:0x1F0
    if(Scorer == none)
    {
        C = Level.ControllerList;
        J0x198:
        // End:0x1E3 [Loop If]
        if(C != none)
        {
            // End:0x1CC
            if(PlayerController(C) != none)
            {
                PlayerController(C).ReceiveLocalizedMessage(class'Message_RoundTied');
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x198;
        }
        NextRoundTime = NextRoundDelay;
        return;
    }
    WinningTeamIndex = Scorer.Team.TeamIndex;
    IncrementGoalsScored(Scorer);
    ScoreEvent(Scorer, 0.0, "ObjectiveScore");
    TeamScoreEvent(WinningTeamIndex, 1.0, "tdm_frag");
    Teams[WinningTeamIndex].Score += float(1);
    AnnounceScoreReliable(WinningTeamIndex);
    // End:0x32E
    if(((DarkHorse != none) && DarkHorse.PlayerReplicationInfo != none) && DarkHorse.PlayerReplicationInfo == Scorer)
    {
        // End:0x2DA
        if(Misc_Player(DarkHorse) != none)
        {
            Misc_Player(DarkHorse).BroadcastAnnouncement(class'Message_Darkhorse');
        }
        DarkHorse.AwardAdrenaline(10.0);
        ++ Misc_PRI(DarkHorse.PlayerReplicationInfo).DarkHorseCount;
        SpecialEvent(DarkHorse.PlayerReplicationInfo, "DarkHorse");
    }
    // End:0x4D9
    else
    {
        // End:0x4D9
        if((Scorer.Team.Score < float(GoalScore)) && (NumPlayers + NumBots) >= 4)
        {
            // End:0x4D9
            if(Deaths[WinningTeamIndex] == 0)
            {
                C = Level.ControllerList;
                J0x38D:
                // End:0x4D9 [Loop If]
                if(C != none)
                {
                    // End:0x497
                    if((C.PlayerReplicationInfo != none) && C.PlayerReplicationInfo.bOnlySpectator || (C.GetTeamNum() != 255) && C.GetTeamNum() == WinningTeamIndex)
                    {
                        // End:0x427
                        if(UnrealPlayer(C) != none)
                        {
                            UnrealPlayer(C).ClientDelayedAnnouncementNamed('Flawless_victory', 18);
                        }
                        // End:0x494
                        if(!C.PlayerReplicationInfo.bOnlySpectator)
                        {
                            ++ Misc_PRI(C.PlayerReplicationInfo).FlawlessCount;
                            SpecialEvent(C.PlayerReplicationInfo, "Flawless");
                            C.AwardAdrenaline(5.0);
                        }
                    }
                    // End:0x4C2
                    else
                    {
                        // End:0x4C2
                        if(UnrealPlayer(C) != none)
                        {
                            UnrealPlayer(C).ClientDelayedAnnouncementNamed('Humiliating_defeat', 18);
                        }
                    }
                    C = C.nextController;
                    // [Loop Continue]
                    goto J0x38D;
                }
            }
        }
    }
    // End:0x537
    if(Scorer.Team.Score == float(GoalScore))
    {
        WinningTeamIndex = Scorer.Team.TeamIndex;
        EndGame(Scorer, "teamscorelimit");
    }
    // End:0x54D
    else
    {
        // End:0x54D
        if(NextRoundDelay > 0)
        {
            NextRoundTime = NextRoundDelay;
        }
    }
    //return;    
}

function AnnounceScoreReliable(int ScoringTeam)
{
    local Controller C;
    local name ScoreSound;
    local int OtherTeam;

    // End:0x15
    if(ScoringTeam == 1)
    {
        OtherTeam = 0;
    }
    // End:0x1C
    else
    {
        OtherTeam = 1;
    }
    // End:0x62
    if(Teams[ScoringTeam].Score == (Teams[OtherTeam].Score + float(1)))
    {
        ScoreSound = TakeLeadName[ScoringTeam];
    }
    // End:0xBA
    else
    {
        // End:0xA9
        if(Teams[ScoringTeam].Score == (Teams[OtherTeam].Score + float(2)))
        {
            ScoreSound = IncreaseLeadName[ScoringTeam];
        }
        // End:0xBA
        else
        {
            ScoreSound = CaptureSoundName[ScoringTeam];
        }
    }
    C = Level.ControllerList;
    J0xCE:
    // End:0x11C [Loop If]
    if(C != none)
    {
        // End:0x105
        if(Misc_Player(C) != none)
        {
            Misc_Player(C).PlayStatusAnnouncementReliable(ScoreSound, 1, true);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0xCE;
    }
    //return;    
}

function AnnounceBest()
{
    local Controller C;
    local string acc, Dam, HS;
    local Misc_PRI PRI, Accuracy, Damage, HeadShots;
    local string Red, Blue, Text;
    local Color Color;

    Red = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.RedTeamColor);
    Blue = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.BlueTeamColor);
    Color = class'Canvas'.static.MakeColor(210, 210, 210);
    Text = class'DMStatsScreen'.static.MakeColorCode(Color);
    C = Level.ControllerList;
    J0x8F:
    // End:0x1BC [Loop If]
    if(C != none)
    {
        PRI = Misc_PRI(C.PlayerReplicationInfo);
        // End:0xEB
        if(((PRI == none) || PRI.Team == none) || PRI.bOnlySpectator)
        {
        }
        // End:0x1A5
        else
        {
            PRI.ProcessHitStats();
            // End:0x133
            if((Accuracy == none) || Accuracy.AveragePercent < PRI.AveragePercent)
            {
                Accuracy = PRI;
            }
            // End:0x16C
            if((Damage == none) || Damage.EnemyDamage < PRI.EnemyDamage)
            {
                Damage = PRI;
            }
            // End:0x1A5
            if((HeadShots == none) || HeadShots.HeadShots < PRI.HeadShots)
            {
                HeadShots = PRI;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x8F;
    }
    // End:0x389
    if((Accuracy != none) && Accuracy.AveragePercent > 0.0)
    {
        // End:0x2C5
        if(Accuracy.Team.TeamIndex == 0)
        {
            // End:0x26B
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                acc = ((((((Text $ "Most Accurate:") @ Red) $ Accuracy.GetColoredName()) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
            // End:0x2C2
            else
            {
                acc = ((((((Text $ "Most Accurate:") @ Red) $ Accuracy.PlayerName) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
        }
        // End:0x389
        else
        {
            // End:0x332
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                acc = ((((((Text $ "Most Accurate:") @ Blue) $ Accuracy.GetColoredName()) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
            // End:0x389
            else
            {
                acc = ((((((Text $ "Most Accurate:") @ Blue) $ Accuracy.PlayerName) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
        }
    }
    // End:0x536
    if((Damage != none) && Damage.EnemyDamage > 0)
    {
        // End:0x480
        if(Damage.Team.TeamIndex == 0)
        {
            // End:0x42D
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                Dam = (((((Text $ "Most Damage:") @ Red) $ Damage.GetColoredName()) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
            // End:0x47D
            else
            {
                Dam = (((((Text $ "Most Damage:") @ Red) $ Damage.PlayerName) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
        }
        // End:0x536
        else
        {
            // End:0x4E6
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                Dam = (((((Text $ "Most Damage:") @ Blue) $ Damage.GetColoredName()) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
            // End:0x536
            else
            {
                Dam = (((((Text $ "Most Damage:") @ Blue) $ Damage.PlayerName) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
        }
    }
    // End:0x6EF
    if((HeadShots != none) && HeadShots.HeadShots > 0)
    {
        // End:0x633
        if(HeadShots.Team.TeamIndex == 0)
        {
            // End:0x5DD
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                HS = (((((Text $ "Most Headshots:") @ Red) $ HeadShots.GetColoredName()) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
            // End:0x630
            else
            {
                HS = (((((Text $ "Most Headshots:") @ Red) $ HeadShots.PlayerName) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
        }
        // End:0x6EF
        else
        {
            // End:0x69C
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                HS = (((((Text $ "Most Headshots:") @ Blue) $ HeadShots.GetColoredName()) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
            // End:0x6EF
            else
            {
                HS = (((((Text $ "Most Headshots:") @ Blue) $ HeadShots.PlayerName) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
        }
    }
    C = Level.ControllerList;
    J0x703:
    // End:0x758 [Loop If]
    if(C != none)
    {
        // End:0x741
        if(Misc_Player(C) != none)
        {
            Misc_Player(C).ClientListBest(acc, Dam, HS);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x703;
    }
    //return;    
}

function AnnounceSurvivors()
{
    local array<Controller> lowPlayers;
    local Controller C;
    local int i;
    local Misc_PRI PRI;
    local string Red, Blue, HealthCol, Text, Result;

    local Color Color;
    local int Health, StartHealth;

    C = Level.ControllerList;
    J0x14:
    // End:0x197 [Loop If]
    if(C != none)
    {
        // End:0x86
        if((((C.PlayerReplicationInfo == none) || !C.bIsPlayer) || C.PlayerReplicationInfo.bOutOfLives) || C.PlayerReplicationInfo.bOnlySpectator)
        {
        }
        // End:0x180
        else
        {
            // End:0x9D
            if(C.Pawn == none)
            {
            }
            // End:0x180
            else
            {
                i = 0;
                J0xA4:
                // End:0x153 [Loop If]
                if(i < lowPlayers.Length)
                {
                    // End:0x149
                    if((float(lowPlayers[i].Pawn.Health) + lowPlayers[i].Pawn.ShieldStrength) > (float(C.Pawn.Health) + C.Pawn.ShieldStrength))
                    {
                        lowPlayers.Insert(i, 1);
                        lowPlayers[i] = C;
                        // [Explicit Break]
                        goto J0x153;
                    }
                    ++ i;
                    J0x153:
                    // [Loop Continue]
                    goto J0xA4;
                }
                // End:0x180
                if(i == lowPlayers.Length)
                {
                    lowPlayers.Insert(i, 1);
                    lowPlayers[i] = C;
                }
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    // End:0x1A5
    if(lowPlayers.Length == 0)
    {
        return;
    }
    Red = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.RedTeamColor);
    Blue = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.BlueTeamColor);
    Color = class'Canvas'.static.MakeColor(210, 210, 210);
    Text = class'DMStatsScreen'.static.MakeColorCode(Color);
    Result = "Survivors: ";
    i = 0;
    J0x23A:
    // End:0x4FE [Loop If]
    if(i < Min(5, lowPlayers.Length))
    {
        PRI = Misc_PRI(lowPlayers[i].PlayerReplicationInfo);
        // End:0x27B
        if(PRI == none)
        {
            // [Explicit Continue]
            goto J0x4F4;
        }
        Health = Max(0, PRI.PawnReplicationInfo.Health + PRI.PawnReplicationInfo.Shield);
        // End:0x2F6
        if(TAM_TeamInfo(PRI.Team) != none)
        {
            StartHealth = TAM_TeamInfo(PRI.Team).StartingHealth;
        }
        // End:0x37A
        else
        {
            // End:0x334
            if(TAM_TeamInfoRed(PRI.Team) != none)
            {
                StartHealth = TAM_TeamInfoRed(PRI.Team).StartingHealth;
            }
            // End:0x37A
            else
            {
                // End:0x372
                if(TAM_TeamInfoBlue(PRI.Team) != none)
                {
                    StartHealth = TAM_TeamInfoBlue(PRI.Team).StartingHealth;
                }
                // End:0x37A
                else
                {
                    StartHealth = 200;
                }
            }
        }
        // End:0x41D
        if(Health < StartHealth)
        {
            Color.B = 0;
            Color.R = byte(Clamp(int(float(400) * (float(StartHealth - Health) / float(StartHealth))), 0, 200));
            // End:0x40D
            if(Color.R == 200)
            {
                Color.G = byte(Clamp(int(float(400) * (float(Health) / float(StartHealth))), 0, 200));
            }
            // End:0x41A
            else
            {
                Color.G = 200;
            }
        }
        // End:0x431
        else
        {
            Color = class'Team_HUDBase'.default.FullHealthColor;
        }
        HealthCol = class'Misc_Util'.static.MakeColorCode(Color);
        // End:0x466
        if(i > 0)
        {
            Result = Result $ " ";
        }
        // End:0x4BD
        if(PRI.Team.TeamIndex == 0)
        {
            Result = ((((Result $ Red) $ PRI.PlayerName) $ " ") $ HealthCol) $ string(Health);
            // [Explicit Continue]
            goto J0x4F4;
        }
        Result = ((((Result $ Blue) $ PRI.PlayerName) $ " ") $ HealthCol) $ string(Health);
        J0x4F4:
        ++ i;
        // [Loop Continue]
        goto J0x23A;
    }
    C = Level.ControllerList;
    J0x512:
    // End:0x55D [Loop If]
    if(C != none)
    {
        // End:0x546
        if(PlayerController(C) != none)
        {
            PlayerController(C).ClientMessage(Result);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x512;
    }
    //return;    
}

function AnnounceWinners()
{
    local Controller C;
    local PlayerReplicationInfo PRI;
    local array<Controller> PlayerRankings;
    local int i;
    local string Red, Blue, Yellow, Text;
    local Color Color;
    local string RankingMsg;
    local int Rank;

    C = Level.ControllerList;
    J0x14:
    // End:0xFF [Loop If]
    if(C != none)
    {
        // End:0x36
        if(C.PlayerReplicationInfo == none)
        {
        }
        // End:0xE8
        else
        {
            PRI = C.PlayerReplicationInfo;
            // End:0x77
            if(PRI.bOnlySpectator || PRI.Score == float(0))
            {
            }
            // End:0xE8
            else
            {
                i = 0;
                J0x7E:
                // End:0xCB [Loop If]
                if(i < PlayerRankings.Length)
                {
                    // End:0xC1
                    if(PRI.Score >= PlayerRankings[i].PlayerReplicationInfo.Score)
                    {
                        // [Explicit Break]
                        goto J0xCB;
                    }
                    ++ i;
                    J0xCB:
                    // [Loop Continue]
                    goto J0x7E;
                }
                PlayerRankings.Insert(i, 1);
                PlayerRankings[i] = C;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    // End:0x3C5
    if(PlayerRankings.Length > 0)
    {
        Red = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.RedTeamColor);
        Blue = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.BlueTeamColor);
        Color = class'Canvas'.static.MakeColor(210, 210, 0);
        Yellow = class'DMStatsScreen'.static.MakeColorCode(Color);
        Color = class'Canvas'.static.MakeColor(210, 210, 210);
        Text = class'DMStatsScreen'.static.MakeColorCode(Color);
        Rank = 0;
        RankingMsg = Text $ "Most valuable players";
        i = 0;
        J0x1ED:
        // End:0x3B9 [Loop If]
        if((i < PlayerRankings.Length) && Rank < 5)
        {
            PRI = PlayerRankings[i].PlayerReplicationInfo;
            // End:0x31D
            if((i == 0) || PRI.Score < PlayerRankings[i - 1].PlayerReplicationInfo.Score)
            {
                ++ Rank;
                // End:0x2D3
                if(PRI.Team.TeamIndex == 0)
                {
                    RankingMsg @= (((((Yellow $ "[") $ string(Rank)) $ "]") @ Red) $ PlayerRankings[i].PlayerReplicationInfo.PlayerName);
                }
                // End:0x31A
                else
                {
                    RankingMsg @= (((((Yellow $ "[") $ string(Rank)) $ "]") @ Blue) $ PlayerRankings[i].PlayerReplicationInfo.PlayerName);
                }
                // [Explicit Continue]
                goto J0x3AF;
            }
            // End:0x376
            if(PRI.Team.TeamIndex == 0)
            {
                RankingMsg @= (((Text $ "&") @ Red) $ PlayerRankings[i].PlayerReplicationInfo.PlayerName);
                // [Explicit Continue]
                goto J0x3AF;
            }
            RankingMsg @= (((Text $ "&") @ Blue) $ PlayerRankings[i].PlayerReplicationInfo.PlayerName);
            J0x3AF:
            ++ i;
            // [Loop Continue]
            goto J0x1ED;
        }
        Broadcast(self, RankingMsg);
    }
    //return;    
}

function SetMapString(Misc_Player Sender, string S)
{
    // End:0x41
    if((Level.NetMode == NM_Standalone) || Sender.PlayerReplicationInfo.bAdmin)
    {
        NextMapString = S;
    }
    //return;    
}

function EndGame(PlayerReplicationInfo PRI, string Reason)
{
    // End:0x0B
    if(EndGameCalled)
    {
        return;
    }
    EndGameCalled = true;
    super(DeathMatch).EndGame(PRI, Reason);
    AnnounceWinners();
    ResetDefaults();
    //return;    
}

function RestartGame()
{
    ResetDefaults();
    super(UnrealMPGameInfo).RestartGame();
    //return;    
}

function ProcessServerTravel(string URL, bool bItems)
{
    RegisterMatchStats();
    // End:0x1D
    if(PlayerDataManager_ServerLink != none)
    {
        PlayerDataManager_ServerLink.Destroy();
    }
    ResetDefaults();
    super(GameInfo).ProcessServerTravel(URL, bItems);
    //return;    
}

function RegisterMatchStats()
{
    // End:0x0B
    if(MatchStatsRegistered)
    {
        return;
    }
    // End:0x30
    if(PlayerDataManager_ServerLink != none)
    {
        // End:0x30
        if(!DisablePersistentStatsForMatch)
        {
            PlayerDataManager_ServerLink.FinishMatch();
        }
    }
    MatchStatsRegistered = true;
    //return;    
}

function ResetDefaults()
{
    // End:0x0B
    if(bDefaultsReset)
    {
        return;
    }
    bDefaultsReset = true;
    class'xPawn'.default.ControllerClass = class'xBot';
    MutTAM.ResetWeaponsToDefaults(bModifyShieldGun);
    // End:0x5E
    if(NextMapString != "")
    {
        ParseOptions(NextMapString);
        SaveConfig();
        NextMapString = "";
    }
    //return;    
}

auto state PendingMatch
{
    function Timer()
    {
        local Controller P;
        local bool bReady;

        global.Timer();
        // End:0x19
        if(NumPlayers == 0)
        {
            bWaitForNetPlayers = true;
        }
        // End:0x93
        if(bWaitForNetPlayers && Level.NetMode != NM_Standalone)
        {
            // End:0x56
            if(NumPlayers >= MinNetPlayers)
            {
                ++ ElapsedTime;
            }
            // End:0x5D
            else
            {
                ElapsedTime = 0;
            }
            // End:0x90
            if((NumPlayers == MaxPlayers) || ElapsedTime > NetWait)
            {
                bWaitForNetPlayers = false;
                CountDown = default.CountDown;
            }
        }
        // End:0xC7
        else
        {
            // End:0xC7
            if(bForceRUP && bPlayersMustBeReady)
            {
                // End:0xC0
                if(NumPlayers >= ForceRUPMinPlayers)
                {
                    ++ ElapsedTime;
                }
                // End:0xC7
                else
                {
                    ElapsedTime = 0;
                }
            }
        }
        // End:0x10F
        if((Level.NetMode != NM_Standalone) && bWaitForNetPlayers || bTournament && NumPlayers < MaxPlayers)
        {
            PlayStartupMessage();
            return;
        }
        bReady = true;
        StartupStage = 1;
        // End:0x213
        if(!bStartedCountDown && (bTournament || bPlayersMustBeReady) || Level.NetMode == NM_Standalone)
        {
            P = Level.ControllerList;
            J0x16F:
            // End:0x213 [Loop If]
            if(P != none)
            {
                // End:0x1FC
                if((((P.UnresolvedNativeFunction_97('PlayerController') && P.PlayerReplicationInfo != none) && P.bIsPlayer) && P.PlayerReplicationInfo.bWaitingPlayer) && !P.PlayerReplicationInfo.bReadyToPlay)
                {
                    bReady = false;
                }
                P = P.nextController;
                // [Loop Continue]
                goto J0x16F;
            }
        }
        // End:0x24D
        if(((!bReady && bForceRUP) && bPlayersMustBeReady) && ElapsedTime >= ForceSeconds)
        {
            bReady = true;
        }
        // End:0x28D
        if((AutoBalanceTeams && !TeamsAutoBalanced) && bReady || ElapsedTime >= AutoBalanceSeconds)
        {
            BalanceTeamsMatchStart();
            TeamsAutoBalanced = true;
        }
        // End:0x2D9
        if(bReady && !bReviewingJumpSpots)
        {
            bStartedCountDown = true;
            -- CountDown;
            // End:0x2C6
            if(CountDown <= 0)
            {
                StartMatch();
            }
            // End:0x2D9
            else
            {
                StartupStage = byte(5 - CountDown);
            }
        }
        PlayStartupMessage();
        //return;        
    }
    stop;    
}

state MatchInProgress
{
    function Timer()
    {
        local Controller C;

        // End:0xC7
        if(EnforceMaxPlayers)
        {
            // End:0xC7
            if(NumPlayers < MaxPlayers)
            {
                // End:0xC7
                if((Level.Pauser == none) && TimeOutPlayer == none)
                {
                    C = Level.ControllerList;
                    J0x4D:
                    // End:0xA8 [Loop If]
                    if(C != none)
                    {
                        // End:0x91
                        if((PlayerController(C) != none) && C.PlayerReplicationInfo != none)
                        {
                            TimeOutPlayer = PlayerController(C);
                            // [Explicit Break]
                            goto J0xA8;
                        }
                        C = C.nextController;
                        J0xA8:
                        // [Loop Continue]
                        goto J0x4D;
                    }
                    // End:0xC7
                    if(TimeOutPlayer != none)
                    {
                        TimeOutTeam = 4;
                        BroadcastLocalizedMessage(class'Message_MaxPlayers', 0);
                    }
                }
            }
        }
        C = Level.ControllerList;
        J0xDB:
        // End:0x136 [Loop If]
        if(C != none)
        {
            // End:0x102
            if(Misc_Pawn(C.Pawn) == none)
            {
            }
            // End:0x11F
            else
            {
                Misc_Pawn(C.Pawn).UpdateSpawnProtection();
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0xDB;
        }
        // End:0x148
        if(ForceAutoBalanceTimer > 0)
        {
            -- ForceAutoBalanceTimer;
        }
        // End:0x19E
        if(EndOfRoundTime > 0)
        {
            GameReplicationInfo.bStopCountDown = true;
            -- EndOfRoundTime;
            // End:0x196
            if(EndOfRoundTime <= 0)
            {
                // End:0x18F
                if(CheckMaxLives(EndOfRoundScorer))
                {
                    EndRound(EndOfRoundScorer);
                }
                EndOfRoundTime = 0;
            }
            super.Timer();
            return;
        }
        // End:0x260
        if((TimeOutCount == 0) && TimeOutTeam != default.TimeOutTeam)
        {
            // End:0x1EA
            if((TimeOutTeam == 3) || TimeOutTeam == 4)
            {
                TimeOutCount = -1;
            }
            // End:0x204
            else
            {
                -- TeamTimeOuts[TimeOutTeam];
                TimeOutCount = default.TimeOutDuration;
            }
            TimeOutRemainder = 0.0;
            GameReplicationInfo.bStopCountDown = true;
            Level.Pauser = TimeOutPlayer.PlayerReplicationInfo;
            SendTimeoutStartText();
            // End:0x258
            if(TimeOutCount != -1)
            {
                SendTimeoutCountText();
            }
            super.Timer();
            return;
        }
        // End:0x2D6
        if((NextRoundTime > 0) || bEndOfRound)
        {
            // End:0x294
            if(NextRoundTime == NextRoundDelay)
            {
                // End:0x294
                if(AutoBalanceTeams)
                {
                    BalanceTeamsRoundStart();
                }
            }
            GameReplicationInfo.bStopCountDown = true;
            // End:0x2B7
            if(NextRoundTime > 0)
            {
                -- NextRoundTime;
            }
            // End:0x2CB
            if(NextRoundTime == 0)
            {
                StartNewRound();
            }
            // End:0x2D3
            else
            {
                super.Timer();
                return;
            }
        }
        // End:0x5AB
        else
        {
            // End:0x4CF
            if(bRoundOT)
            {
                GameReplicationInfo.bStopCountDown = true;
                ++ RoundOTTime;
                // End:0x4CC
                if((float(RoundOTTime) % float(OTInterval)) == float(0))
                {
                    C = Level.ControllerList;
                    J0x323:
                    // End:0x4CC [Loop If]
                    if(C != none)
                    {
                        // End:0x345
                        if(C.Pawn == none)
                        {
                        }
                        // End:0x4B5
                        else
                        {
                            // End:0x3D4
                            if((C.Pawn.Health <= OTDamage) && C.Pawn.ShieldStrength <= float(0))
                            {
                                C.Pawn.TakeDamage(1000, C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Overtime');
                            }
                            // End:0x4B5
                            else
                            {
                                // End:0x44B
                                if(int(C.Pawn.ShieldStrength) > 0)
                                {
                                    C.Pawn.ShieldStrength = float(int(C.Pawn.ShieldStrength) - Min(int(C.Pawn.ShieldStrength), OTDamage));
                                }
                                // End:0x469
                                else
                                {
                                    C.Pawn.Health -= OTDamage;
                                }
                                C.Pawn.TakeDamage(int(0.010), C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Overtime');
                            }
                        }
                        C = C.nextController;
                        // [Loop Continue]
                        goto J0x323;
                    }
                }
            }
            // End:0x5AB
            else
            {
                // End:0x5AB
                if(RoundTime > 0)
                {
                    GameReplicationInfo.bStopCountDown = false;
                    -- RoundTime;
                    Misc_BaseGRI(GameReplicationInfo).RoundTime = RoundTime;
                    // End:0x539
                    if((float(RoundTime) % float(60)) == float(0))
                    {
                        Misc_BaseGRI(GameReplicationInfo).RoundMinute = RoundTime;
                    }
                    // End:0x5AB
                    if(RoundTime == 0)
                    {
                        bRoundOT = true;
                        C = Level.ControllerList;
                        J0x560:
                        // End:0x5AB [Loop If]
                        if(C != none)
                        {
                            // End:0x594
                            if(PlayerController(C) != none)
                            {
                                PlayerController(C).ClientPlaySound(OvertimeSound);
                            }
                            C = C.nextController;
                            // [Loop Continue]
                            goto J0x560;
                        }
                    }
                }
            }
        }
        // End:0x5BC
        if(RespawnTime > 0)
        {
            RespawnTimer();
        }
        CheckForCampers();
        CleanUpPawns();
        super.Timer();
        //return;        
    }
    stop;    
}

state MatchOver
{
    function BeginState()
    {
        local Controller C;
        local Misc_PRI PRI;
        local int i, j;
        local Pawn P;
        local Projectile proj;
        local Vector HitLocation, HitNormal;
        local Actor HitResult;
        local Vector TraceStart, TraceEnd, axisX, axisY, axisZ;

        local float dist[4], backDist, frontDist;
        local Rotator Rot[4];
        local int BestIdx;

        super.BeginState();
        RegisterMatchStats();
        // End:0x19
        if(!EndCeremonyEnabled)
        {
            return;
        }
        CalcEndCeremonyRankings();
        EndCeremonyPlayerCount = Min(EndCeremonyRankings.Length, 10);
        // End:0x3C
        if(EndCeremonyPlayerCount == 0)
        {
            return;
        }
        // End:0x56
        if(EndCeremonySound.Length > 0)
        {
            EndCeremonySoundIdx = Rand(EndCeremonySound.Length);
        }
        // End:0x73
        foreach AllActors(class'Pawn', P)
        {
            P.Destroy();            
        }        
        // End:0x91
        foreach AllActors(class'Projectile', proj)
        {
            proj.Destroy();            
        }        
        i = 0;
        J0x99:
        // End:0x3C7 [Loop If]
        if(i < EndCeremonyPlayerCount)
        {
            C = EndCeremonyRankings[i];
            PRI = Misc_PRI(C.PlayerReplicationInfo);
            // End:0xF6
            if((PRI == none) || C.StartSpot == none)
            {
                // [Explicit Continue]
                goto J0x3BD;
            }
            ServerEndCeremonyInfo[i].PlayerName = PRI.PlayerName;
            ServerEndCeremonyInfo[i].CharacterName = PRI.CharacterName;
            // End:0x173
            if(PRI.Team != none)
            {
                ServerEndCeremonyInfo[i].PlayerTeam = PRI.Team.TeamIndex;
            }
            // End:0x186
            else
            {
                ServerEndCeremonyInfo[i].PlayerTeam = 255;
            }
            j = 0;
            J0x18D:
            // End:0x2BA [Loop If]
            if(j < 4)
            {
                Rot[j] = C.StartSpot.Rotation;
                Rot[j].Pitch = 0;
                Rot[j].Yaw += (j * (65536 / 4));
                TraceStart = C.StartSpot.Location + vect(0.0, 0.0, 25.0);
                GetAxes(Rot[j], axisX, axisY, axisZ);
                TraceEnd = TraceStart + (axisX * float(200));
                HitResult = C.Trace(HitLocation, HitNormal, TraceEnd, TraceStart, true);
                // End:0x296
                if(HitResult == none)
                {
                    dist[j] = 200.0;
                    // [Explicit Continue]
                    goto J0x2B0;
                }
                dist[j] = VSize(HitLocation - TraceStart);
                J0x2B0:
                ++ j;
                // [Loop Continue]
                goto J0x18D;
            }
            BestIdx = 0;
            // End:0x379
            if(dist[0] <= float(200))
            {
                backDist = 10000.0;
                frontDist = 200.0;
                j = 1;
                J0x2EE:
                // End:0x379 [Loop If]
                if(j < 4)
                {
                    // End:0x36F
                    if((dist[j] >= frontDist) && dist[int(float(j + 2) % float(4))] <= backDist)
                    {
                        frontDist = dist[j];
                        backDist = dist[int(float(j + 2) % float(4))];
                        BestIdx = j;
                    }
                    ++ j;
                    // [Loop Continue]
                    goto J0x2EE;
                }
            }
            ServerEndCeremonyInfo[i].SpawnPos = C.StartSpot.Location;
            ServerEndCeremonyInfo[i].SpawnRot = Rot[BestIdx];
            J0x3BD:
            ++ i;
            // [Loop Continue]
            goto J0x99;
        }
        C = Level.ControllerList;
        J0x3DB:
        // End:0x41D [Loop If]
        if(C != none)
        {
            // End:0x406
            if(Misc_Player(C) != none)
            {
                StartCeremonyForPlayer(Misc_Player(C));
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x3DB;
        }
        //return;        
    }

    function Timer()
    {
        // End:0x51
        if(EndCeremonyStatsEnabled)
        {
            // End:0x4A
            if((float(EndCeremonyTimer) % float(EndCeremonyStatsListDisplayTime)) == float(0))
            {
                // End:0x4A
                if(PlayerDataManager_ServerLink != none)
                {
                    PlayerDataManager_ServerLink.GetRandomStats();
                    PlayerDataManager_ServerLink.GetRandomStats();
                }
            }
            ++ EndCeremonyTimer;
        }
        super.Timer();
        //return;        
    }

    function bool ChangeTeam(Controller Other, int Num, bool bNewTeam)
    {
        local UnrealTeamInfo NewTeam;

        // End:0x1F
        if(bMustJoinBeforeStart && GameReplicationInfo.bMatchHasBegun)
        {
            return false;
        }
        // End:0x4A
        if(CurrentGameProfile != none)
        {
            // End:0x4A
            if(!CurrentGameProfile.CanChangeTeam(Other, Num))
            {
                return false;
            }
        }
        // End:0x96
        if(Other.UnresolvedNativeFunction_97('PlayerController') && Other.PlayerReplicationInfo.bOnlySpectator)
        {
            Other.PlayerReplicationInfo.Team = none;
            return true;
        }
        NewTeam = Teams[PickTeam(byte(Num), Other)];
        // End:0xD9
        if(Other.PlayerReplicationInfo.Team == NewTeam)
        {
            return false;
        }
        Other.StartSpot = none;
        // End:0x12C
        if(Other.PlayerReplicationInfo.Team != none)
        {
            Other.PlayerReplicationInfo.Team.RemoveFromTeam(Other);
        }
        // End:0x1AA
        if(NewTeam.AddToTeam(Other))
        {
            BroadcastLocalizedMessage(GameMessageClass, 3, Other.PlayerReplicationInfo, none, NewTeam);
            // End:0x1AA
            if(bNewTeam && PlayerController(Other) != none)
            {
                GameEvent("TeamChange", "" $ string(Num), Other.PlayerReplicationInfo);
            }
        }
        return true;
        //return;        
    }
    stop;    
}

defaultproperties
{
    StartingHealth=100
    MaxHealth=1.0
    AdrenalinePerDamage=1.0
    bForceRUP=true
    ForceSeconds=60
    MinsPerRound=2
    OTDamage=5
    OTInterval=3
    CampThreshold=400.0
    CampInterval=5
    bKickExcessiveCampers=true
    TimeOutTeam=255
    TimeOutCount=60
    TimeOutDuration=60
    bFirstSpawn=true
    NextRoundDelay=1
    AssaultAmmo=999
    AssaultGrenades=5
    BioAmmo=20
    ShockAmmo=20
    LinkAmmo=100
    MiniAmmo=75
    FlakAmmo=12
    RocketAmmo=12
    LightningAmmo=10
    EndOfRoundDelay=4
    RoundCanTie=true
    EnableNewNet=true
    EndCeremonyEnabled=true
    EndCeremonyStatsEnabled=true
    EndCeremonyStatsListDisplayTime=20
    bSpawnProtectionOnRez=true
    AutoBalanceTeams=true
    AutoBalanceRandomization=50.0
    AutoBalanceAvgPPRWeight=100.0
    AutoBalanceSeconds=20
    AutoBalanceOnJoins=true
    AllowForceAutoBalance=true
    ForceAutoBalanceCooldown=120
    ShowServerName=true
    FlagTextureEnabled=true
    FlagTextureShowAcronym=true
    AllowServerSaveSettings=true
    OvertimeSound=Sound'Sounds.overtime'
    bScoreTeamKills=false
    FriendlyFireScale=0.50
    DefaultEnemyRosterClass="3SPNv3210CW.TAM_TeamInfo"
    ADR_MinorError=-5.0
    LoginMenuClass="3SPNv3210CW.Menu_TAMLoginMenu"
    LocalStatsScreenClass=class'Misc_StatBoard'
    DefaultPlayerClassName="3SPNv3210CW.Misc_Pawn"
    ScoreBoardType="3SPNv3210CW.TAM_Scoreboard"
    HUDType="3SPNv3210CW.TAM_HUD"
    GoalScore=10
    TimeLimit=0
    DeathMessageClass=class'Misc_DeathMessage'
    MutatorClass="3SPNv3210CW.TAM_Mutator"
    PlayerControllerClassName="3SPNv3210CW.Misc_Player"
    GameReplicationInfoClass=class'Misc_BaseGRI'
    GameName="BASE"
    Description="One life per round. Don't waste it."
    ScreenShotName="UT2004Thumbnails.TDMShots"
    DecoTextName="XGame.TeamGame"
    Acronym="BASE"
}