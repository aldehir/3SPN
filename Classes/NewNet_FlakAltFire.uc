/*******************************************************************************
 * NewNet_FlakAltFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_FlakAltFire extends WeaponFire_FlakAlt
    dependson(WeaponFire_FlakAlt)
    dependson(NewNet_FlakCannon);

const PROJ_TIMESTEP = 0.0201;
const MAX_PROJECTILE_FUDGE = 0.075;
const SLACK = 0.035;

var float PingDT;
var bool bUseEnhancedNetCode;
var bool bSkipNextEffect;
var bool bUseReplicatedInfo;
var Rotator SavedRot;
var Vector savedVec;
var class<Projectile> FakeProjectileClass;
var NewNet_FakeProjectileManager FPM;
var Vector OldInstigatorLocation;
var Vector OldInstigatorEyePosition;
var Vector OldXAxis;
var Vector OldYAxis;
var Vector OldZAxis;
var Rotator OldAim;

function PlayFiring()
{
    super(WeaponFire).PlayFiring();
    // End:0x37
    if((Level.NetMode != NM_Client) || !class'Misc_Player'.static.UseNewNet())
    {
        return;
    }
    // End:0x4B
    if(!bSkipNextEffect)
    {
        CheckFireEffect();
    }
    // End:0x63
    else
    {
        bSkipNextEffect = false;
        Weapon.ClientStopFire(0);
    }
    //return;    
}

function CheckFireEffect()
{
    // End:0xDC
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        // End:0xD6
        if((class'NewNet_PRI'.default.PredictedPing - 0.0350) > 0.0750)
        {
            OldInstigatorLocation = Instigator.Location;
            OldInstigatorEyePosition = Instigator.EyePosition();
            Weapon.GetViewAxes(OldXAxis, OldYAxis, OldZAxis);
            OldAim = AdjustAim(OldInstigatorLocation + OldInstigatorEyePosition, aimerror);
            SetTimer((class'NewNet_PRI'.default.PredictedPing - 0.0350) - 0.0750, false);
        }
        // End:0xDC
        else
        {
            DoClientFireEffect();
        }
    }
    //return;    
}

function Timer()
{
    DoTimedClientFireEffect();
    //return;    
}

simulated function DoTimedClientFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    X = OldXAxis;
    Y = OldXAxis;
    Z = OldXAxis;
    StartTrace = OldInstigatorLocation + OldInstigatorEyePosition;
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xB7
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0xF4
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = OldAim;
    SpawnCount = Max(1, ProjPerFire * int(load));
    switch(SpreadStyle)
    {
        // End:0x1C3
        case 1:
            X = vector(Aim);
            P = 0;
            J0x136:
            // End:0x1C0 [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                SpawnFakeProjectile(StartProj, rotator(X >> R));
                ++ P;
                // [Loop Continue]
                goto J0x136;
            }
            // End:0x283
            break;
        // End:0x270
        case 2:
            P = 0;
            J0x1CF:
            // End:0x26D [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                SpawnFakeProjectile(StartProj, rotator(X >> Aim));
                ++ P;
                // [Loop Continue]
                goto J0x1CF;
            }
            // End:0x283
            break;
        // End:0xFFFF
        default:
            SpawnFakeProjectile(StartProj, Aim);
            //return;
    }    
}

function DoClientFireEffect()
{
    DoFireEffect();
    //return;    
}

function DoInstantFireEffect()
{
    CheckFireEffect();
    bSkipNextEffect = true;
    //return;    
}

function Projectile SpawnProjectile(Vector Start, Rotator Dir)
{
    local Projectile P;
    local Rotator NewDir;
    local float F, G;
    local Vector End, HitLocation, HitNormal, VZ;
    local Actor Other;

    // End:0x3E
    if((Level.NetMode == NM_Client) && class'Misc_Player'.static.UseNewNet())
    {
        return SpawnFakeProjectile(Start, Dir);
    }
    // End:0x5A
    if(!bUseEnhancedNetCode)
    {
        return super(ProjectileFire).SpawnProjectile(Start, Dir);
    }
    // End:0x28D
    if(ProjectileClass != none)
    {
        // End:0x26A
        if((PingDT > 0.0) && Weapon.Owner != none)
        {
            NewDir = Dir;
            F = 0.0;
            J0xA0:
            // End:0x14B [Loop If]
            if(F < (PingDT + 0.02010))
            {
                G = FMin(PingDT, F);
                End = Start + (Extrapolate(NewDir, 0.02010, G == 0.0));
                TimeTravel(PingDT - G);
                Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);
                // End:0x131
                if(Other != none)
                {
                    // [Explicit Break]
                    goto J0x14B;
                }
                Start = End;
                F += 0.02010;
                J0x14B:
                // [Loop Continue]
                goto J0xA0;
            }
            UnTimeTravel();
            // End:0x1C4
            if((Other != none) && Other.IsA('NewNet_PawnCollisionCopy'))
            {
                HitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
                Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
            }
            VZ.Z = ProjectileClass.default.TossZ;
            NewDir = rotator((vector(NewDir) * ProjectileClass.default.Speed) - VZ);
            // End:0x234
            if(Other == none)
            {
                P = Weapon.Spawn(ProjectileClass,,, End, NewDir);
            }
            // End:0x267
            else
            {
                P = Weapon.Spawn(ProjectileClass,,, HitLocation - (vector(Dir) * 20.0), NewDir);
            }
        }
        // End:0x28D
        else
        {
            P = Weapon.Spawn(ProjectileClass,,, Start, Dir);
        }
    }
    // End:0x29A
    if(P == none)
    {
        return none;
    }
    P.Damage *= DamageAtten;
    return P;
    //return;    
}

function Vector Extrapolate(out Rotator Dir, float dF, bool bTossZ)
{
    local Rotator oldDir;
    local Vector VZ;

    oldDir = Dir;
    // End:0x7F
    if(bTossZ)
    {
        VZ.Z = ProjectileClass.default.TossZ;
        Dir = rotator(((vector(oldDir) * ProjectileClass.default.Speed) + VZ) + (Weapon.Owner.PhysicsVolume.Gravity * dF));
    }
    // End:0xC7
    else
    {
        Dir = rotator((vector(oldDir) * ProjectileClass.default.Speed) + (Weapon.Owner.PhysicsVolume.Gravity * dF));
    }
    // End:0x12B
    if(bTossZ)
    {
        return (((vector(oldDir) * ProjectileClass.default.Speed) + VZ) * dF) + ((0.50 * Square(dF)) * Weapon.Owner.PhysicsVolume.Gravity);
    }
    // End:0x17C
    else
    {
        return ((vector(oldDir) * ProjectileClass.default.Speed) * dF) + ((0.50 * Square(dF)) * Weapon.Owner.PhysicsVolume.Gravity);
    }
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_FlakCannon(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_FlakCannon(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_FlakCannon(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_FlakCannon(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}

simulated function Projectile SpawnFakeProjectile(Vector Start, Rotator Dir)
{
    local Projectile P;

    // End:0x1E
    if(FPM == none)
    {
        FindFPM();
        // End:0x1E
        if(FPM == none)
        {
            return none;
        }
    }
    // End:0x65
    if(FPM.AllowFakeProjectile(FakeProjectileClass))
    {
        P = Weapon.Spawn(FakeProjectileClass, Weapon.Owner,, Start, Dir);
    }
    // End:0x72
    if(P == none)
    {
        return none;
    }
    FPM.RegisterFakeProjectile(P);
    return P;
    //return;    
}

function DoFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    // End:0x46
    if(bUseReplicatedInfo)
    {
        StartTrace = savedVec;
    }
    // End:0x6B
    else
    {
        StartTrace = Instigator.Location + Instigator.EyePosition();
    }
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xDE
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x11B
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    // End:0x13A
    if(bUseReplicatedInfo)
    {
        Aim = SavedRot;
        bUseReplicatedInfo = false;
    }
    // End:0x150
    else
    {
        Aim = AdjustAim(StartProj, aimerror);
    }
    SpawnCount = Max(1, ProjPerFire * int(load));
    switch(SpreadStyle)
    {
        // End:0x214
        case 1:
            X = vector(Aim);
            P = 0;
            J0x187:
            // End:0x211 [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                SpawnProjectile(StartProj, rotator(X >> R));
                ++ P;
                // [Loop Continue]
                goto J0x187;
            }
            // End:0x2D4
            break;
        // End:0x2C1
        case 2:
            P = 0;
            J0x220:
            // End:0x2BE [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                SpawnProjectile(StartProj, rotator(X >> Aim));
                ++ P;
                // [Loop Continue]
                goto J0x220;
            }
            // End:0x2D4
            break;
        // End:0xFFFF
        default:
            SpawnProjectile(StartProj, Aim);
            //return;
    }    
}

simulated function FindFPM()
{
    // End:0x1D
    foreach Weapon.DynamicActors(class'NewNet_FakeProjectileManager', FPM)
    {
        // End:0x1D
        break;        
    }    
    //return;    
}

defaultproperties
{
    FakeProjectileClass=class'NewNet_Fake_FlakShell'
    ProjectileClass=class'NewNet_FlakShell'
}