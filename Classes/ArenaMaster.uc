/*******************************************************************************
 * ArenaMaster generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class ArenaMaster extends xDeathMatch
    dependson(Misc_PickupBase)
    hidecategories(Movement,Collision,Lighting,LightColor,Karma,Force)
    config;

var config int StartingHealth;
var config int StartingArmor;
var config float MaxHealth;
var float AdrenalinePerDamage;
var config bool bDisableSpeed;
var config bool bDisableBooster;
var config bool bDisableInvis;
var config bool bDisableBerserk;
var array<string> EnabledCombos;
var config bool bChallengeMode;
var config bool bForceRUP;
var config int ForceRUPMinPlayers;
var config bool bRandomPickups;
var Misc_PickupBase Bases[3];
var string NextMapString;
var bool bDefaultsReset;
var config int MinsPerRound;
var int RoundTime;
var bool bRoundOT;
var int RoundOTTime;
var config int OTDamage;
var config int OTInterval;
var config float CampThreshold;
var int CampInterval;
var config bool bKickExcessiveCampers;
var bool bEndOfRound;
var bool bRespawning;
var int RespawnTime;
var int LockTime;
var int NextRoundTime;
var int CurrentRound;
var int RoundStartTime;
var int RoundsToWin;
var config bool bModifyShieldGun;
var config int AssaultAmmo;
var config int AssaultGrenades;
var config int BioAmmo;
var config int ShockAmmo;
var config int LinkAmmo;
var config int MiniAmmo;
var config int FlakAmmo;
var config int RocketAmmo;
var config int LightningAmmo;
var config bool EnableNewNet;
var TAM_Mutator MutTAM;
var config string ShieldTextureName;
var config string FlagTextureName;
var config bool ShowServerName;
var config bool FlagTextureEnabled;
var config bool FlagTextureShowAcronym;
var Sound OvertimeSound;

function GetServerPlayers(out ServerResponseLine ServerState)
{
    local Mutator M;
    local Controller C;
    local PlayerReplicationInfo PRI;
    local int i, TeamFlag;

    i = ServerState.PlayerInfo.Length;
    TeamFlag[0] = 1 << 29;
    TeamFlag[1] = TeamFlag[0] << 1;
    C = Level.ControllerList;
    J0x44:
    // End:0x1CF [Loop If]
    if(C != none)
    {
        PRI = C.PlayerReplicationInfo;
        // End:0x1B8
        if(((PRI != none) && !PRI.bBot) && MessagingSpectator(C) == none)
        {
            ServerState.PlayerInfo.Length = i + 1;
            ServerState.PlayerInfo[i].PlayerNum = C.PlayerNum;
            ServerState.PlayerInfo[i].PlayerName = Misc_PRI(PRI).GetColoredName();
            ServerState.PlayerInfo[i].Score = int(PRI.Score);
            ServerState.PlayerInfo[i].Ping = 4 * PRI.Ping;
            // End:0x1B1
            if(bTeamGame && PRI.Team != none)
            {
                ServerState.PlayerInfo[i].StatsID = ServerState.PlayerInfo[i].StatsID | TeamFlag[PRI.Team.TeamIndex];
            }
            ++ i;
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x44;
    }
    M = BaseMutator.NextMutator;
    J0x1E3:
    // End:0x219 [Loop If]
    if(M != none)
    {
        M.GetServerPlayers(ServerState);
        M = M.NextMutator;
        // [Loop Continue]
        goto J0x1E3;
    }
    //return;    
}

function InitGameReplicationInfo()
{
    super(DeathMatch).InitGameReplicationInfo();
    SpawnProtectionTime = 0.0;
    // End:0x23
    if(TAM_GRI(GameReplicationInfo) == none)
    {
        return;
    }
    TAM_GRI(GameReplicationInfo).RoundTime = MinsPerRound * 60;
    TAM_GRI(GameReplicationInfo).StartingHealth = StartingHealth;
    TAM_GRI(GameReplicationInfo).StartingArmor = StartingArmor;
    TAM_GRI(GameReplicationInfo).bChallengeMode = bChallengeMode;
    TAM_GRI(GameReplicationInfo).MaxHealth = MaxHealth;
    TAM_GRI(GameReplicationInfo).MinsPerRound = MinsPerRound;
    TAM_GRI(GameReplicationInfo).OTDamage = OTDamage;
    TAM_GRI(GameReplicationInfo).OTInterval = OTInterval;
    TAM_GRI(GameReplicationInfo).CampThreshold = CampThreshold;
    TAM_GRI(GameReplicationInfo).bKickExcessiveCampers = bKickExcessiveCampers;
    TAM_GRI(GameReplicationInfo).bDisableTeamCombos = true;
    TAM_GRI(GameReplicationInfo).bDisableSpeed = bDisableSpeed;
    TAM_GRI(GameReplicationInfo).bDisableInvis = bDisableInvis;
    TAM_GRI(GameReplicationInfo).bDisableBooster = bDisableBooster;
    TAM_GRI(GameReplicationInfo).bDisableBerserk = bDisableBerserk;
    TAM_GRI(GameReplicationInfo).bForceRUP = bForceRUP;
    TAM_GRI(GameReplicationInfo).ForceRUPMinPlayers = ForceRUPMinPlayers;
    TAM_GRI(GameReplicationInfo).bRandomPickups = bRandomPickups;
    TAM_GRI(GameReplicationInfo).GoalScore = RoundsToWin;
    Misc_BaseGRI(GameReplicationInfo).NetUpdateTime = Level.TimeSeconds - float(1);
    Misc_BaseGRI(GameReplicationInfo).Acronym = Acronym;
    Misc_BaseGRI(GameReplicationInfo).EnableNewNet = EnableNewNet;
    Misc_BaseGRI(GameReplicationInfo).ShieldTextureName = ShieldTextureName;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureName = FlagTextureName;
    Misc_BaseGRI(GameReplicationInfo).ShowServerName = ShowServerName;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureEnabled = FlagTextureEnabled;
    Misc_BaseGRI(GameReplicationInfo).FlagTextureShowAcronym = FlagTextureShowAcronym;
    //return;    
}

function GetServerDetails(out ServerResponseLine ServerState)
{
    super(DeathMatch).GetServerDetails(ServerState);
    AddServerDetail(ServerState, "3SPN Version", class'TAM_GRI'.default.Version);
    AddServerDetail(ServerState, "Challenge Mode", string(bChallengeMode));
    AddServerDetail(ServerState, "Random Pickups", string(bRandomPickups));
    //return;    
}

static function FillPlayInfo(PlayInfo Pi)
{
    super(DeathMatch).FillPlayInfo(Pi);
    Pi.AddSetting("3SPN", "StartingHealth", "Starting Health", 0, 100, "Text", "3;0:999");
    Pi.AddSetting("3SPN", "StartingArmor", "Starting Armor", 0, 101, "Text", "3;0:999");
    Pi.AddSetting("3SPN", "MaxHealth", "Max Health", 0, 102, "Text", "8;0.0:2.0");
    Pi.AddSetting("3SPN", "bChallengeMode", "Challenge Mode", 0, 103, "Check");
    Pi.AddSetting("3SPN", "MinsPerRound", "Minutes per Round", 0, 120, "Text", "3;0:999");
    Pi.AddSetting("3SPN", "OTDamage", "Overtime Damage", 0, 121, "Text", "3;0:999");
    Pi.AddSetting("3SPN", "OTInterval", "Overtime Damage Interval", 0, 122, "Text", "3;0:999");
    Pi.AddSetting("3SPN", "CampThreshold", "Camp Area", 0, 150, "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "bKickExcessiveCampers", "Kick Excessive Campers", 0, 151, "Check",,, true);
    Pi.AddSetting("3SPN", "bForceRUP", "Force Ready", 0, 175, "Check",,, true);
    Pi.AddSetting("3SPN", "ForceRUPMinPlayers", "Force Ready Min Players", 0, 176, "Text", "3;0;999",, true);
    Pi.AddSetting("3SPN", "bRandomPickups", "Random Pickups", 0, 177, "Check");
    Pi.AddSetting("3SPN", "bDisableSpeed", "Disable Speed", 0, 200, "Check");
    Pi.AddSetting("3SPN", "bDisableInvis", "Disable Invis", 0, 201, "Check");
    Pi.AddSetting("3SPN", "bDisableBerserk", "Disable Berserk", 0, 202, "Check");
    Pi.AddSetting("3SPN", "bDisableBooster", "Disable Booster", 0, 203, "Check");
    Pi.AddSetting("3SPN", "bModifyShieldGun", "Use Modified Shield Gun", 0, byte(299), "Check",,, true);
    Pi.AddSetting("3SPN", "AssaultAmmo", "Assault Ammunition", 0, byte(300), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "AssaultGrenades", "Assault Grenades", 0, byte(301), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "BioAmmo", "Bio Ammunition", 0, byte(302), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "ShockAmmo", "Shock Ammunition", 0, byte(303), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "LinkAmmo", "Link Ammunition", 0, byte(304), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "MiniAmmo", "Mini Ammunition", 0, byte(305), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "FlakAmmo", "Flak Ammunition", 0, byte(306), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "RocketAmmo", "Rocket Ammunition", 0, byte(307), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "LightningAmmo", "Lightning Ammunition", 0, byte(308), "Text", "3;0:999",, true);
    Pi.AddSetting("3SPN", "EnableNewNet", "Enable New Net", 0, byte(400), "Check");
    //return;    
}

static event string GetDescriptionText(string PropName)
{
    switch(PropName)
    {
        // End:0x38
        case "StartingHealth":
            return "Base health at round start.";
        // End:0x67
        case "StartingArmor":
            return "Base armor at round start.";
        // End:0xA7
        case "bChallengeMode":
            return "Round winners take a health/armor penalty.";
        // End:0xDC
        case "MinsPerRound":
            return "Round time-limit before overtime.";
        // End:0x119
        case "OTDamage":
            return "The amount of damage all players while in OT.";
        // End:0x154
        case "OTInterval":
            return "The interval at which OT damage is given.";
        // End:0x19E
        case "MaxHealth":
            return "The maximum amount of health and armor a player can have.";
        // End:0x1EB
        case "CampThreshold":
            return "The area a player must stay in to be considered camping.";
        // End:0x233
        case "bKickExcessiveCampers":
            return "Kick players that camp 4 consecutive times.";
        // End:0x26B
        case "bDisableSpeed":
            return "Disable the Speed adrenaline combo.";
        // End:0x2AA
        case "bDisableInvis":
            return "Disable the Invisibility adrenaline combo.";
        // End:0x2E6
        case "bDisableBooster":
            return "Disable the Booster adrenaline combo.";
        // End:0x322
        case "bDisableBerserk":
            return "Disable the Berserk adrenaline combo.";
        // End:0x35E
        case "bForceRUP":
            return "Force players to ready up after 45 seconds.";
        // End:0x3BC
        case "ForceRUPMinPlayers":
            return "Force players to ready only when at least this many players present.";
        // End:0x433
        case "bRandomPickups":
            return "Spawns three pickups which give random effect when picked up: Health +15, Shield +15 or Adren +10";
        // End:0x48A
        case "bModifyShieldGun":
            return "The Shield Gun will have more kick back for higher shield jumps";
        // End:0x4CD
        case "AssaultAmmo":
            return "Amount of Assault Ammunition to give in a round.";
        // End:0x512
        case "AssaultGrenades":
            return "Amount of Assault Grenades to give in a round.";
        // End:0x553
        case "BioAmmo":
            return "Amount of Bio Rifle Ammunition to give in a round.";
        // End:0x594
        case "LinkAmmo":
            return "Amount of Link Gun Ammunition to give in a round.";
        // End:0x5D3
        case "ShockAmmo":
            return "Amount of Shock Ammunition to give in a round.";
        // End:0x610
        case "MiniAmmo":
            return "Amount of Mini Ammunition to give in a round.";
        // End:0x64D
        case "FlakAmmo":
            return "Amount of Flak Ammunition to give in a round.";
        // End:0x68E
        case "RocketAmmo":
            return "Amount of Rocket Ammunition to give in a round.";
        // End:0x6D5
        case "LightningAmmo":
            return "Amount of Lightning Ammunition to give in a round.";
        // End:0x715
        case "EnableNewNet":
            return "Make enhanced netcode available for players.";
        // End:0xFFFF
        default:
            return super(DeathMatch).GetDescriptionText(PropName);
    }
    //return;    
}

function ParseOptions(string Options)
{
    local string InOpt;

    InOpt = ParseOption(Options, "StartingHealth");
    // End:0x3A
    if(InOpt != "")
    {
        StartingHealth = int(InOpt);
    }
    InOpt = ParseOption(Options, "StartingArmor");
    // End:0x73
    if(InOpt != "")
    {
        StartingArmor = int(InOpt);
    }
    InOpt = ParseOption(Options, "ChallengeMode");
    // End:0xAD
    if(InOpt != "")
    {
        bChallengeMode = bool(InOpt);
    }
    InOpt = ParseOption(Options, "MaxHealth");
    // End:0xE2
    if(InOpt != "")
    {
        MaxHealth = float(InOpt);
    }
    InOpt = ParseOption(Options, "MinsPerRound");
    // End:0x11A
    if(InOpt != "")
    {
        MinsPerRound = int(InOpt);
    }
    InOpt = ParseOption(Options, "OTDamage");
    // End:0x14E
    if(InOpt != "")
    {
        OTDamage = int(InOpt);
    }
    InOpt = ParseOption(Options, "OTInterval");
    // End:0x184
    if(InOpt != "")
    {
        OTInterval = int(InOpt);
    }
    InOpt = ParseOption(Options, "CampThreshold");
    // End:0x1BD
    if(InOpt != "")
    {
        CampThreshold = float(InOpt);
    }
    InOpt = ParseOption(Options, "ForceRUP");
    // End:0x1F2
    if(InOpt != "")
    {
        bForceRUP = bool(InOpt);
    }
    InOpt = ParseOption(Options, "ForceRUPMinPlayers");
    // End:0x230
    if(InOpt != "")
    {
        ForceRUPMinPlayers = int(InOpt);
    }
    InOpt = ParseOption(Options, "KickExcessiveCampers");
    // End:0x271
    if(InOpt != "")
    {
        bKickExcessiveCampers = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableSpeed");
    // End:0x2AA
    if(InOpt != "")
    {
        bDisableSpeed = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableInvis");
    // End:0x2E3
    if(InOpt != "")
    {
        bDisableInvis = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableBerserk");
    // End:0x31E
    if(InOpt != "")
    {
        bDisableBerserk = bool(InOpt);
    }
    InOpt = ParseOption(Options, "DisableBooster");
    // End:0x359
    if(InOpt != "")
    {
        bDisableBooster = bool(InOpt);
    }
    InOpt = ParseOption(Options, "RandomPickups");
    // End:0x393
    if(InOpt != "")
    {
        bRandomPickups = bool(InOpt);
    }
    //return;    
}

function SpawnRandomPickupBases()
{
    local float Score[3], Eval;
    local NavigationPoint Best[3], N;

    N = Level.NavigationPointList;
    J0x14:
    // End:0x28A [Loop If]
    if(N != none)
    {
        // End:0x4D
        if((InventorySpot(N) == none) || InventorySpot(N).myPickupBase == none)
        {
        }
        // End:0x273
        else
        {
            Eval = FRand() * 5000.0;
            // End:0xA4
            if(Best[0] != none)
            {
                Eval += (VSize(Best[0].Location - N.Location) * ((FRand() * 4.0) - 2.0));
            }
            // End:0xEC
            if(Best[1] != none)
            {
                Eval += (VSize(Best[1].Location - N.Location) * ((FRand() * 3.50) - 1.750));
            }
            // End:0x136
            if(Best[2] != none)
            {
                Eval += (VSize(Best[2].Location - N.Location) * ((FRand() * 3.0) - 1.50));
            }
            // End:0x152
            if(Best[0] == N)
            {
                Eval = 0.0;
            }
            // End:0x16E
            if(Best[1] == N)
            {
                Eval = 0.0;
            }
            // End:0x18B
            if(Best[2] == N)
            {
                Eval = 0.0;
            }
            // End:0x1F7
            if(Eval > Score[0])
            {
                Score[2] = Score[1];
                Score[1] = Score[0];
                Score[0] = Eval;
                Best[2] = Best[1];
                Best[1] = Best[0];
                Best[0] = N;
            }
            // End:0x273
            else
            {
                // End:0x245
                if(Eval > Score[1])
                {
                    Score[2] = Score[1];
                    Score[1] = Eval;
                    Best[2] = Best[1];
                    Best[1] = N;
                }
                // End:0x273
                else
                {
                    // End:0x273
                    if(Eval > Score[2])
                    {
                        Score[2] = Eval;
                        Best[2] = N;
                    }
                }
            }
        }
        N = N.nextNavigationPoint;
        // [Loop Continue]
        goto J0x14;
    }
    // End:0x2E6
    if(Best[0] != none)
    {
        Bases[0] = Spawn(class'Misc_PickupBase',,, Best[0].Location, Best[0].Rotation);
        Bases[0].myMarker = InventorySpot(Best[0]);
    }
    // End:0x342
    if(Best[1] != none)
    {
        Bases[1] = Spawn(class'Misc_PickupBase',,, Best[1].Location, Best[1].Rotation);
        Bases[1].myMarker = InventorySpot(Best[1]);
    }
    // End:0x3A4
    if(Best[2] != none)
    {
        Bases[2] = Spawn(class'Misc_PickupBase',,, Best[2].Location, Best[2].Rotation);
        Bases[2].myMarker = InventorySpot(Best[2]);
    }
    //return;    
}

event InitGame(string Options, out string Error)
{
    class'TAM_Mutator'.default.EnableNewNet = EnableNewNet;
    bAllowBehindView = true;
    super(DeathMatch).InitGame(Options, Error);
    ParseOptions(Options);
    // End:0x4D
    foreach DynamicActors(class'TAM_Mutator', MutTAM)
    {
        // End:0x4D
        break;        
    }    
    class'xPawn'.default.ControllerClass = class'Misc_Bot';
    MaxLives = 1;
    bForceRespawn = true;
    bAllowWeaponThrowing = true;
    // End:0x88
    if(bRandomPickups)
    {
        SpawnRandomPickupBases();
    }
    MutTAM.InitWeapons(AssaultAmmo, AssaultGrenades, BioAmmo, ShockAmmo, LinkAmmo, MiniAmmo, FlakAmmo, RocketAmmo, LightningAmmo);
    // End:0x145
    if(bModifyShieldGun)
    {
        class'ShieldFire'.default.SelfForceScale = 1.50;
        class'ShieldFire'.default.SelfDamageScale = 0.10;
        class'ShieldFire'.default.MinSelfDamage = 0.0;
        class'WeaponFire_Shield'.default.SelfForceScale = 1.50;
        class'WeaponFire_Shield'.default.SelfDamageScale = 0.10;
        class'WeaponFire_Shield'.default.MinSelfDamage = 0.0;
    }
    // End:0x16F
    if(!bDisableSpeed)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboSpeed";
    }
    // End:0x19D
    if(!bDisableBooster)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboDefensive";
    }
    // End:0x1C9
    if(!bDisableBerserk)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboBerserk";
    }
    // End:0x1F3
    if(!bDisableInvis)
    {
        EnabledCombos[EnabledCombos.Length] = "xGame.ComboInvis";
    }
    SaveConfig();
    RoundsToWin = GoalScore;
    GoalScore = 0;
    //return;    
}

function int ReduceDamage(int Damage, Pawn injured, Pawn instigatedBy, Vector HitLocation, out Vector Momentum, class<DamageType> DamageType)
{
    local Misc_PRI PRI;
    local int OldDamage, NewDamage, RealDamage;
    local float Score;

    // End:0x0B
    if(bEndOfRound)
    {
        return 0;
    }
    // End:0x3F
    if(DamageType == class'DamTypeSuperShockBeam')
    {
        return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
    }
    // End:0xA62
    if(Misc_Pawn(instigatedBy) != none)
    {
        PRI = Misc_PRI(instigatedBy.PlayerReplicationInfo);
        // End:0x98
        if(PRI == none)
        {
            return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
        }
        // End:0x2D7
        if(injured == instigatedBy)
        {
            OldDamage = Misc_PRI(instigatedBy.PlayerReplicationInfo).AllyDamage;
            RealDamage = OldDamage + Damage;
            // End:0x122
            if((class<DamType_Camping>(DamageType) != none) || class<DamType_Overtime>(DamageType) != none)
            {
                return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
            }
            // End:0x140
            if(class<DamTypeShieldImpact>(DamageType) != none)
            {
                NewDamage = OldDamage;
            }
            // End:0x14B
            else
            {
                NewDamage = RealDamage;
            }
            PRI.AllyDamage = NewDamage;
            Score = float(NewDamage - OldDamage);
            // End:0x2AF
            if(Score > 0.0)
            {
                // End:0x266
                if(Misc_Player(instigatedBy.Controller) != none)
                {
                    Misc_Player(instigatedBy.Controller).NewFriendlyDamage += (Score * 0.010);
                    // End:0x266
                    if(Misc_Player(instigatedBy.Controller).NewFriendlyDamage >= 1.0)
                    {
                        ScoreEvent(PRI, float(-int(Misc_Player(instigatedBy.Controller).NewFriendlyDamage)), "FriendlyDamage");
                        Misc_Player(instigatedBy.Controller).NewFriendlyDamage -= float(int(Misc_Player(instigatedBy.Controller).NewFriendlyDamage));
                    }
                }
                PRI.Score -= (Score * 0.010);
                instigatedBy.Controller.AwardAdrenaline((-Score * 0.10) * AdrenalinePerDamage);
            }
            return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
        }
        // End:0xA62
        else
        {
            // End:0xA62
            if(instigatedBy != injured)
            {
                PRI = Misc_PRI(instigatedBy.PlayerReplicationInfo);
                // End:0x32F
                if(PRI == none)
                {
                    return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
                }
                OldDamage = PRI.EnemyDamage;
                NewDamage = OldDamage + Damage;
                PRI.EnemyDamage = NewDamage;
                Score = float(NewDamage - OldDamage);
                // End:0x4F4
                if(Score > 0.0)
                {
                    // End:0x4AD
                    if(Misc_Player(instigatedBy.Controller) != none)
                    {
                        Misc_Player(instigatedBy.Controller).NewEnemyDamage += (Score * 0.010);
                        // End:0x46B
                        if(Misc_Player(instigatedBy.Controller).NewEnemyDamage >= 1.0)
                        {
                            ScoreEvent(PRI, float(int(Misc_Player(instigatedBy.Controller).NewEnemyDamage)), "EnemyDamage");
                            Misc_Player(instigatedBy.Controller).NewEnemyDamage -= float(int(Misc_Player(instigatedBy.Controller).NewEnemyDamage));
                        }
                        // End:0x4AD
                        if(instigatedBy.FastTrace(injured.Location))
                        {
                            Misc_Player(instigatedBy.Controller).hitdamage += int(Score);
                        }
                    }
                    PRI.Score += (Score * 0.010);
                    instigatedBy.Controller.AwardAdrenaline((Score * 0.10) * AdrenalinePerDamage);
                }
                // End:0x5BA
                if((float(Damage) > ((float(injured.Health) + injured.ShieldStrength) + float(50))) && (float(Damage) / (float(injured.Health) + injured.ShieldStrength)) > float(2))
                {
                    ++ PRI.OverkillCount;
                    SpecialEvent(PRI, "Overkill");
                    // End:0x5BA
                    if(Misc_Player(instigatedBy.Controller) != none)
                    {
                        Misc_Player(instigatedBy.Controller).ReceiveLocalizedMessage(class'Message_Overkill');
                    }
                }
                // End:0x605
                if(DamageType == class'DamType_FlakChunk')
                {
                    ++ PRI.Flak.primary.Hit;
                    PRI.Flak.primary.Damage += Damage;
                }
                // End:0xA62
                else
                {
                    // End:0x650
                    if(DamageType == class'DamType_FlakShell')
                    {
                        ++ PRI.Flak.Secondary.Hit;
                        PRI.Flak.Secondary.Damage += Damage;
                    }
                    // End:0xA62
                    else
                    {
                        // End:0x691
                        if(DamageType == class'DamType_Rocket')
                        {
                            ++ PRI.Rockets.Hit;
                            PRI.Rockets.Damage += Damage;
                        }
                        // End:0xA62
                        else
                        {
                            // End:0x6D2
                            if(DamageType == class'DamTypeSniperShot')
                            {
                                ++ PRI.Sniper.Hit;
                                PRI.Sniper.Damage += Damage;
                            }
                            // End:0xA62
                            else
                            {
                                // End:0x71D
                                if(DamageType == class'DamTypeShockBeam')
                                {
                                    ++ PRI.Shock.primary.Hit;
                                    PRI.Shock.primary.Damage += Damage;
                                }
                                // End:0xA62
                                else
                                {
                                    // End:0x768
                                    if(DamageType == class'DamTypeShockBall')
                                    {
                                        ++ PRI.Shock.Secondary.Hit;
                                        PRI.Shock.Secondary.Damage += Damage;
                                    }
                                    // End:0xA62
                                    else
                                    {
                                        // End:0x7A9
                                        if(DamageType == class'DamType_ShockCombo')
                                        {
                                            ++ PRI.Combo.Hit;
                                            PRI.Combo.Damage += Damage;
                                        }
                                        // End:0xA62
                                        else
                                        {
                                            // End:0x7F4
                                            if(DamageType == class'DamTypeMinigunBullet')
                                            {
                                                ++ PRI.Mini.primary.Hit;
                                                PRI.Mini.primary.Damage += Damage;
                                            }
                                            // End:0xA62
                                            else
                                            {
                                                // End:0x83F
                                                if(DamageType == class'DamTypeMinigunAlt')
                                                {
                                                    ++ PRI.Mini.Secondary.Hit;
                                                    PRI.Mini.Secondary.Damage += Damage;
                                                }
                                                // End:0xA62
                                                else
                                                {
                                                    // End:0x88A
                                                    if(DamageType == class'DamTypeLinkPlasma')
                                                    {
                                                        ++ PRI.Link.Secondary.Hit;
                                                        PRI.Link.Secondary.Damage += Damage;
                                                    }
                                                    // End:0xA62
                                                    else
                                                    {
                                                        // End:0x8D5
                                                        if(DamageType == class'DamTypeLinkShaft')
                                                        {
                                                            ++ PRI.Link.primary.Hit;
                                                            PRI.Link.primary.Damage += Damage;
                                                        }
                                                        // End:0xA62
                                                        else
                                                        {
                                                            // End:0x926
                                                            if(DamageType == class'DamType_Headshot')
                                                            {
                                                                ++ PRI.HeadShots;
                                                                ++ PRI.Sniper.Hit;
                                                                PRI.Sniper.Damage += Damage;
                                                            }
                                                            // End:0xA62
                                                            else
                                                            {
                                                                // End:0x967
                                                                if(DamageType == class'DamType_BioGlob')
                                                                {
                                                                    ++ PRI.Bio.Hit;
                                                                    PRI.Bio.Damage += Damage;
                                                                }
                                                                // End:0xA62
                                                                else
                                                                {
                                                                    // End:0x9B2
                                                                    if(DamageType == class'DamTypeAssaultBullet')
                                                                    {
                                                                        ++ PRI.Assault.primary.Hit;
                                                                        PRI.Assault.primary.Damage += Damage;
                                                                    }
                                                                    // End:0xA62
                                                                    else
                                                                    {
                                                                        // End:0x9FD
                                                                        if(DamageType == class'DamTypeAssaultGrenade')
                                                                        {
                                                                            ++ PRI.Assault.Secondary.Hit;
                                                                            PRI.Assault.Secondary.Damage += Damage;
                                                                        }
                                                                        // End:0xA62
                                                                        else
                                                                        {
                                                                            // End:0xA3E
                                                                            if(DamageType == class'DamType_RocketHoming')
                                                                            {
                                                                                ++ PRI.Rockets.Hit;
                                                                                PRI.Rockets.Damage += Damage;
                                                                            }
                                                                            // End:0xA62
                                                                            else
                                                                            {
                                                                                // End:0xA62
                                                                                if(DamageType == class'DamTypeShieldImpact')
                                                                                {
                                                                                    PRI.SGDamage += Damage;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return super(DeathMatch).ReduceDamage(Damage, injured, instigatedBy, HitLocation, Momentum, DamageType);
    //return;    
}

function StartMatch()
{
    super(DeathMatch).StartMatch();
    CurrentRound = 1;
    TAM_GRI(GameReplicationInfo).CurrentRound = 1;
    GameEvent("NewRound", string(CurrentRound), none);
    RoundTime = 60 * MinsPerRound;
    TAM_GRI(GameReplicationInfo).RoundTime = RoundTime;
    RespawnTime = 2;
    LockTime = default.LockTime;
    RoundStartTime = int(Level.TimeSeconds);
    //return;    
}

function StartNewRound()
{
    RespawnTime = 4;
    LockTime = default.LockTime;
    bRoundOT = false;
    RoundOTTime = 0;
    RoundTime = 60 * MinsPerRound;
    RoundStartTime = int(Level.TimeSeconds);
    ++ CurrentRound;
    TAM_GRI(GameReplicationInfo).CurrentRound = CurrentRound;
    bEndOfRound = false;
    TAM_GRI(GameReplicationInfo).bEndOfRound = false;
    TAM_GRI(GameReplicationInfo).RoundTime = RoundTime;
    TAM_GRI(GameReplicationInfo).RoundMinute = RoundTime;
    Misc_BaseGRI(GameReplicationInfo).NetUpdateTime = Level.TimeSeconds - float(1);
    GameEvent("NewRound", string(CurrentRound), none);
    //return;    
}

event PlayerController Login(string Portal, string Options, out string Error)
{
    local string InName;
    local PlayerController PC;

    Options = class'Misc_Util'.static.SanitizeLoginOptions(Options);
    InName = Left(ParseOption(Options, "Name"), 20);
    ReplaceText(InName, " ", "_");
    ReplaceText(InName, "|", "I");
    PC = super(DeathMatch).Login(Portal, Options, Error);
    // End:0xEA
    if(PC != none)
    {
        // End:0xB8
        if(Misc_PRI(PC.PlayerReplicationInfo) != none)
        {
            Misc_PRI(PC.PlayerReplicationInfo).ColoredName = InName;
        }
        // End:0xEA
        if(Misc_Player(PC) != none)
        {
            Misc_Player(PC).LoginTime = Level.TimeSeconds;
        }
    }
    return PC;
    //return;    
}

event PostLogin(PlayerController NewPlayer)
{
    super(DeathMatch).PostLogin(NewPlayer);
    // End:0x69
    if(!bRespawning && CurrentRound > 0)
    {
        NewPlayer.PlayerReplicationInfo.bOutOfLives = true;
        NewPlayer.PlayerReplicationInfo.NumLives = 0;
        NewPlayer.GotoState('Spectating');
    }
    // End:0x7F
    else
    {
        // End:0x7F
        if(CurrentRound > 0)
        {
            RestartPlayer(NewPlayer);
        }
    }
    // End:0xA3
    if(Misc_Player(NewPlayer) != none)
    {
        Misc_Player(NewPlayer).ClientKillBases();
    }
    CheckMaxLives(none);
    //return;    
}

function Logout(Controller Exiting)
{
    super(DeathMatch).Logout(Exiting);
    CheckMaxLives(none);
    // End:0x4A
    if((((NumPlayers <= 0) && !bWaitingToStartMatch) && !bGameEnded) && !bGameRestarted)
    {
        RestartGame();
    }
    //return;    
}

function bool BecomeSpectator(PlayerController P)
{
    // End:0x3D
    if((P.PlayerReplicationInfo == none) || NumSpectators >= MaxSpectators)
    {
        P.ReceiveLocalizedMessage(GameMessageClass, 12);
        return false;
    }
    // End:0x65
    if(GameStats != none)
    {
        GameStats.DisconnectEvent(P.PlayerReplicationInfo);
    }
    P.PlayerReplicationInfo.bOnlySpectator = true;
    ++ NumSpectators;
    -- NumPlayers;
    // End:0x9F
    if(!bKillBots)
    {
        ++ RemainingBots;
    }
    // End:0xBC
    if(!NeedPlayers() || AddBot())
    {
        -- RemainingBots;
    }
    return true;
    //return;    
}

function bool AllowBecomeActivePlayer(PlayerController P)
{
    local bool B;

    B = true;
    // End:0x4B
    if((P.PlayerReplicationInfo == none) || NumPlayers >= MaxPlayers)
    {
        P.ReceiveLocalizedMessage(GameMessageClass, 13);
        B = false;
    }
    // End:0x8F
    if((B && Level.NetMode == NM_Standalone) && NumBots > InitialBots)
    {
        -- RemainingBots;
        bPlayerBecameActive = true;
    }
    return B;
    //return;    
}

function bool AddBot(optional string botname)
{
    local Bot NewBot;

    NewBot = SpawnBot(botname);
    // End:0x36
    if(NewBot == none)
    {
        Warn("Failed to spawn bot.");
        return false;
    }
    BroadcastLocalizedMessage(GameMessageClass, 1, NewBot.PlayerReplicationInfo);
    NewBot.PlayerReplicationInfo.PlayerID = ++ CurrentID;
    ++ NumBots;
    // End:0x100
    if(!bRespawning && CurrentRound > 0)
    {
        NewBot.PlayerReplicationInfo.bOutOfLives = true;
        NewBot.PlayerReplicationInfo.NumLives = 0;
        // End:0xE8
        if(Level.NetMode == NM_Standalone)
        {
            RestartPlayer(NewBot);
        }
        // End:0xFD
        else
        {
            NewBot.GotoState('Dead', 'MPStart');
        }
    }
    // End:0x10B
    else
    {
        RestartPlayer(NewBot);
    }
    CheckMaxLives(none);
    return true;
    //return;    
}

function string SwapDefaultCombo(string ComboName)
{
    // End:0x3D
    if(ComboName ~= "xGame.ComboSpeed")
    {
        return "3SPNv3210CW.Misc_ComboSpeed";
    }
    // End:0x7B
    else
    {
        // End:0x7B
        if(ComboName ~= "xGame.ComboBerserk")
        {
            return "3SPNv3210CW.Misc_ComboBerserk";
        }
    }
    return ComboName;
    //return;    
}

function string RecommendCombo(string ComboName)
{
    local int i;
    local bool bEnabled;

    // End:0x18
    if(EnabledCombos.Length == 0)
    {
        return super(GameInfo).RecommendCombo(ComboName);
    }
    i = 0;
    J0x1F:
    // End:0x59 [Loop If]
    if(i < EnabledCombos.Length)
    {
        // End:0x4F
        if(EnabledCombos[i] ~= ComboName)
        {
            bEnabled = true;
            // [Explicit Break]
            goto J0x59;
        }
        ++ i;
        J0x59:
        // [Loop Continue]
        goto J0x1F;
    }
    // End:0x78
    if(!bEnabled)
    {
        ComboName = EnabledCombos[Rand(EnabledCombos.Length)];
    }
    return SwapDefaultCombo(ComboName);
    //return;    
}

function AddGameSpecificInventory(Pawn P)
{
    super(DeathMatch).AddGameSpecificInventory(P);
    // End:0x4D
    if(((P == none) || P.Controller == none) || P.Controller.PlayerReplicationInfo == none)
    {
        return;
    }
    SetupPlayer(P);
    //return;    
}

function AddDefaultInventory(Pawn P)
{
    super(DeathMatch).AddDefaultInventory(P);
    MutTAM.GiveAmmo(P);
    //return;    
}

function SetupPlayer(Pawn P)
{
    local byte Won;
    local int Health, Armor;
    local float formula;

    // End:0x143
    if(bChallengeMode)
    {
        Won = byte(int(P.PlayerReplicationInfo.Score / float(10000)));
        // End:0x55
        if(RoundsToWin > 0)
        {
            formula = 0.50 / float(RoundsToWin);
        }
        // End:0x60
        else
        {
            formula = 0.0;
        }
        Health = int(float(StartingHealth) - ((float(StartingHealth) * formula) * float(Won)));
        Armor = int(float(StartingArmor) - ((float(StartingArmor) * formula) * float(Won)));
        P.Health = Max(40, Health);
        P.HealthMax = float(Max(40, Health));
        P.SuperHealthMax = float(int(float(Health) * MaxHealth));
        xPawn(P).ShieldStrengthMax = float(int(float(Armor) * MaxHealth));
        P.AddShieldStrength(Max(0, Armor));
    }
    // End:0x1C0
    else
    {
        P.Health = StartingHealth;
        P.HealthMax = float(StartingHealth);
        P.SuperHealthMax = float(StartingHealth) * MaxHealth;
        xPawn(P).ShieldStrengthMax = float(StartingArmor) * MaxHealth;
        P.AddShieldStrength(StartingArmor);
    }
    // End:0x209
    if(Misc_Player(P.Controller) != none)
    {
        xPawn(P).Spree = Misc_Player(P.Controller).Spree;
    }
    //return;    
}

function RespawnTimer()
{
    local Controller C;
    local Actor Reset;

    -- RespawnTime;
    bRespawning = RespawnTime > 0;
    // End:0x22B
    if(RespawnTime == 3)
    {
        C = Level.ControllerList;
        J0x36:
        // End:0x1DF [Loop If]
        if(C != none)
        {
            // End:0x83
            if(Misc_Player(C) != none)
            {
                Misc_Player(C).Spree = 0;
                Misc_Player(C).ClientResetClock(MinsPerRound * 60);
            }
            // End:0xB7
            if((C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.bOnlySpectator)
            {
            }
            // End:0x1C8
            else
            {
                // End:0x13D
                if(xPawn(C.Pawn) != none)
                {
                    C.Pawn.RemovePowerups();
                    // End:0x128
                    if(Misc_Player(C) != none)
                    {
                        Misc_Player(C).Spree = xPawn(C.Pawn).Spree;
                    }
                    C.Pawn.Destroy();
                }
                C.PlayerReplicationInfo.bOutOfLives = false;
                C.PlayerReplicationInfo.NumLives = 1;
                // End:0x194
                if(PlayerController(C) != none)
                {
                    PlayerController(C).ClientReset();
                }
                C.Reset();
                // End:0x1C8
                if(PlayerController(C) != none)
                {
                    PlayerController(C).GotoState('Spectating');
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x36;
        }
        // End:0x22A
        foreach AllActors(class'Actor', Reset)
        {
            // End:0x20C
            if(DestroyActor(Reset))
            {
                Reset.Destroy();
                // End:0x229
                continue;
            }
            // End:0x229
            if(ResetActor(Reset))
            {
                Reset.Reset();
            }            
        }        
    }
    // End:0x392
    if(RespawnTime <= 3)
    {
        C = Level.ControllerList;
        J0x24B:
        // End:0x392 [Loop If]
        if(C != none)
        {
            // End:0x297
            if(((C == none) || C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.bOnlySpectator)
            {
            }
            // End:0x37B
            else
            {
                // End:0x37B
                if((PlayerController(C) != none) && (C.Pawn == none) || C.Pawn.Weapon == none)
                {
                    // End:0x305
                    if(C.Pawn != none)
                    {
                        C.Pawn.Destroy();
                    }
                    C.PlayerReplicationInfo.bOutOfLives = false;
                    C.PlayerReplicationInfo.NumLives = 1;
                    PlayerController(C).ClientReset();
                    C.Reset();
                    PlayerController(C).GotoState('Spectating');
                    RestartPlayer(C);
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x24B;
        }
    }
    //return;    
}

function CleanUpPawns()
{
    local Pawn P;

    // End:0x5C
    foreach AllActors(class'Pawn', P)
    {
        // End:0x28
        if(P.Controller != none)
        {
            continue;            
        }
        // End:0x5B
        if((Level.TimeSeconds - P.LastStartTime) > float(3))
        {
            P.Destroy();
        }        
    }    
    //return;    
}

function RestartPlayer(Controller C)
{
    // End:0x26
    if(Misc_Player(C) != none)
    {
        Misc_Player(C).ActiveThisRound = true;
    }
    // End:0x4C
    if(Misc_Bot(C) != none)
    {
        Misc_Bot(C).ActiveThisRound = true;
    }
    super(DeathMatch).RestartPlayer(C);
    //return;    
}

function bool DestroyActor(Actor A)
{
    // End:0x15
    if(Projectile(A) != none)
    {
        return true;
    }
    // End:0x3C
    else
    {
        // End:0x2A
        if(Pawn(A) != none)
        {
            return true;
        }
        // End:0x3C
        else
        {
            // End:0x3C
            if(Inventory(A) != none)
            {
                return true;
            }
        }
    }
    return false;
    //return;    
}

function bool ResetActor(Actor A)
{
    // End:0x24
    if((Mover(A) != none) || DECO_ExplodingBarrel(A) != none)
    {
        return true;
    }
    return false;
    //return;    
}

function CheckForCampers()
{
    local Controller C;
    local Misc_Pawn P;
    local Misc_PRI PRI;
    local Box HistoryBox;
    local float maxDim;
    local int i;

    C = Level.ControllerList;
    J0x14:
    // End:0x4C6 [Loop If]
    if(C != none)
    {
        // End:0x90
        if((((Misc_PRI(C.PlayerReplicationInfo) == none) || Misc_Pawn(C.Pawn) == none) || C.PlayerReplicationInfo.bOnlySpectator) || C.PlayerReplicationInfo.bOutOfLives)
        {
        }
        // End:0x4AF
        else
        {
            P = Misc_Pawn(C.Pawn);
            PRI = Misc_PRI(C.PlayerReplicationInfo);
            P.LocationHistory[P.NextLocHistSlot] = P.Location;
            ++ P.NextLocHistSlot;
            // End:0x134
            if(P.NextLocHistSlot == 10)
            {
                P.NextLocHistSlot = 0;
                P.bWarmedUp = true;
            }
            // End:0x4AF
            if(P.bWarmedUp)
            {
                HistoryBox.Min.X = P.LocationHistory[0].X;
                HistoryBox.Min.Y = P.LocationHistory[0].Y;
                HistoryBox.Min.Z = P.LocationHistory[0].Z;
                HistoryBox.Max.X = P.LocationHistory[0].X;
                HistoryBox.Max.Y = P.LocationHistory[0].Y;
                HistoryBox.Max.Z = P.LocationHistory[0].Z;
                i = 1;
                J0x22B:
                // End:0x39D [Loop If]
                if(i < 10)
                {
                    HistoryBox.Min.X = FMin(HistoryBox.Min.X, P.LocationHistory[i].X);
                    HistoryBox.Min.Y = FMin(HistoryBox.Min.Y, P.LocationHistory[i].Y);
                    HistoryBox.Min.Z = FMin(HistoryBox.Min.Z, P.LocationHistory[i].Z);
                    HistoryBox.Max.X = FMax(HistoryBox.Max.X, P.LocationHistory[i].X);
                    HistoryBox.Max.Y = FMax(HistoryBox.Max.Y, P.LocationHistory[i].Y);
                    HistoryBox.Max.Z = FMax(HistoryBox.Max.Z, P.LocationHistory[i].Z);
                    ++ i;
                    // [Loop Continue]
                    goto J0x22B;
                }
                maxDim = FMax(FMax(HistoryBox.Max.X - HistoryBox.Min.X, HistoryBox.Max.Y - HistoryBox.Min.Y), HistoryBox.Max.Z - HistoryBox.Min.Z);
                // End:0x458
                if((maxDim < CampThreshold) && P.ReWarnTime == 0)
                {
                    PunishCamper(C, P, PRI);
                    P.ReWarnTime = CampInterval;
                }
                // End:0x4AF
                else
                {
                    // End:0x48B
                    if(maxDim > CampThreshold)
                    {
                        PRI.bWarned = false;
                        PRI.ConsecutiveCampCount = 0;
                    }
                    // End:0x4AF
                    else
                    {
                        // End:0x4AF
                        if(P.ReWarnTime > 0)
                        {
                            -- P.ReWarnTime;
                        }
                    }
                }
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    //return;    
}

function PunishCamper(Controller C, Misc_Pawn P, Misc_PRI PRI)
{
    SendCamperWarning(C);
    // End:0xAA
    if((C.Pawn.Health <= (10 * (PRI.CampCount + 1))) && C.Pawn.ShieldStrength <= float(0))
    {
        C.Pawn.TakeDamage(1000, C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Camping');
    }
    // End:0x18C
    else
    {
        // End:0x112
        if(int(C.Pawn.ShieldStrength) > 0)
        {
            C.Pawn.ShieldStrength = float(Max(0, int(P.ShieldStrength - float(10 * (PRI.CampCount + 1)))));
        }
        // End:0x140
        else
        {
            C.Pawn.Health -= (10 * (PRI.CampCount + 1));
        }
        C.Pawn.TakeDamage(int(0.010), C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Camping');
    }
    // End:0x1B3
    if(!PRI.bWarned)
    {
        PRI.bWarned = true;
        return;
    }
    // End:0x2BC
    if((Level.NetMode == NM_DedicatedServer) && (PRI.Ping * 4) < 999)
    {
        ++ PRI.CampCount;
        ++ PRI.ConsecutiveCampCount;
        // End:0x2BC
        if(bKickExcessiveCampers && PRI.ConsecutiveCampCount >= 4)
        {
            Log("Kicking Camper (Possibly Idle): " $ C.PlayerReplicationInfo.PlayerName);
            AccessControl.DefaultKickReason = AccessControl.IdleKickReason;
            AccessControl.KickPlayer(PlayerController(C));
            AccessControl.DefaultKickReason = AccessControl.default.DefaultKickReason;
        }
    }
    //return;    
}

function SendCamperWarning(Controller Camper)
{
    local Controller C;

    C = Level.ControllerList;
    J0x14:
    // End:0x7E [Loop If]
    if(C != none)
    {
        // End:0x32
        if(Misc_Player(C) == none)
        {
        }
        // End:0x67
        else
        {
            Misc_Player(C).ReceiveLocalizedMessage(class'Message_Camper', int(C != Camper), Camper.PlayerReplicationInfo);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    //return;    
}

function Killed(Controller Killer, Controller Killed, Pawn KilledPawn, class<DamageType> DamageType)
{
    super(DeathMatch).Killed(Killer, Killed, KilledPawn, DamageType);
    // End:0x112
    if((Killed != none) && Killed.PlayerReplicationInfo != none)
    {
        // End:0xDF
        if(bRespawning)
        {
            Killed.PlayerReplicationInfo.bOutOfLives = false;
            Killed.PlayerReplicationInfo.NumLives = 1;
            // End:0x9B
            if(PlayerController(Killed) != none)
            {
                PlayerController(Killed).ClientReset();
            }
            Killed.Reset();
            // End:0xCF
            if(PlayerController(Killed) != none)
            {
                PlayerController(Killed).GotoState('Spectating');
            }
            RestartPlayer(Killed);
            return;
        }
        // End:0x112
        else
        {
            Killed.PlayerReplicationInfo.bOutOfLives = true;
            Killed.PlayerReplicationInfo.NumLives = 0;
        }
    }
    //return;    
}

function NotifyKilled(Controller Killer, Controller Other, Pawn OtherPawn)
{
    super(GameInfo).NotifyKilled(Killer, Other, OtherPawn);
    SendPlayerIsOutText(Other);
    //return;    
}

function SendPlayerIsOutText(Controller Out)
{
    local Controller C;

    // End:0x0D
    if(Out == none)
    {
        return;
    }
    C = Level.ControllerList;
    J0x21:
    // End:0x92 [Loop If]
    if(C != none)
    {
        // End:0x7B
        if(PlayerController(C) != none)
        {
            PlayerController(C).ReceiveLocalizedMessage(class'Message_PlayerIsOut', int(PlayerController(C) != PlayerController(Out)), Out.PlayerReplicationInfo);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x21;
    }
    //return;    
}

function bool CanSpectate(PlayerController Viewer, bool bOnlySpectator, Actor ViewTarget)
{
    // End:0x44
    if((xPawn(ViewTarget) == none) && (Controller(ViewTarget) == none) || xPawn(Controller(ViewTarget).Pawn) == none)
    {
        return false;
    }
    // End:0x9D
    if(bOnlySpectator)
    {
        // End:0x88
        if(Controller(ViewTarget) != none)
        {
            return (Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer;
        }
        // End:0x9D
        else
        {
            return xPawn(ViewTarget).IsPlayerPawn();
        }
    }
    // End:0xB3
    if(Viewer.Pawn != none)
    {
        return false;
    }
    // End:0xD6
    if(bRespawning && (NextRoundTime <= 1) && bEndOfRound)
    {
        return false;
    }
    // End:0x111
    if(Controller(ViewTarget) != none)
    {
        return (Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer;
    }
    // End:0x141
    else
    {
        return xPawn(ViewTarget).IsPlayerPawn() && xPawn(ViewTarget).PlayerReplicationInfo != none;
    }
    //return;    
}

function bool CheckMaxLives(PlayerReplicationInfo Scorer)
{
    local Controller C;
    local PlayerReplicationInfo Living;
    local bool bNoneLeft;

    // End:0x16
    if(bWaitingToStartMatch || bEndOfRound)
    {
        return false;
    }
    // End:0x42
    if((Scorer != none) && !Scorer.bOutOfLives)
    {
        Living = Scorer;
    }
    bNoneLeft = true;
    C = Level.ControllerList;
    J0x5E:
    // End:0x12B [Loop If]
    if(C != none)
    {
        // End:0x114
        if((((C.PlayerReplicationInfo != none) && C.bIsPlayer) && !C.PlayerReplicationInfo.bOutOfLives) && !C.PlayerReplicationInfo.bOnlySpectator)
        {
            // End:0xF1
            if(Living == none)
            {
                Living = C.PlayerReplicationInfo;
            }
            // End:0x114
            else
            {
                // End:0x114
                if(C.PlayerReplicationInfo != Living)
                {
                    bNoneLeft = false;
                    // [Explicit Break]
                    goto J0x12B;
                }
            }
        }
        C = C.nextController;
        J0x12B:
        // [Loop Continue]
        goto J0x5E;
    }
    // End:0x15A
    if(bNoneLeft)
    {
        // End:0x14D
        if(Living != none)
        {
            EndRound(Living);
        }
        // End:0x158
        else
        {
            EndRound(Scorer);
        }
        return true;
    }
    return false;
    //return;    
}

function EndRound(PlayerReplicationInfo Scorer)
{
    local Controller C;
    local PlayerController PC;

    C = Level.ControllerList;
    J0x14:
    // End:0x1AC [Loop If]
    if(C != none)
    {
        // End:0x95
        if((Misc_Player(C) != none) && Misc_Player(C).ActiveThisRound)
        {
            // End:0x7F
            if(Misc_PRI(C.PlayerReplicationInfo) != none)
            {
                ++ Misc_PRI(C.PlayerReplicationInfo).PlayedRounds;
            }
            Misc_Player(C).ActiveThisRound = false;
        }
        // End:0x10B
        if((Misc_Bot(C) != none) && Misc_Bot(C).ActiveThisRound)
        {
            // End:0xF5
            if(Misc_PRI(C.PlayerReplicationInfo) != none)
            {
                ++ Misc_PRI(C.PlayerReplicationInfo).PlayedRounds;
            }
            Misc_Bot(C).ActiveThisRound = false;
        }
        // End:0x13F
        if((C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.bOnlySpectator)
        {
        }
        // End:0x195
        else
        {
            // End:0x195
            if((PlayerController(C) != none) && C.PlayerReplicationInfo.bOutOfLives)
            {
                PlayerController(C).GotoState('PlayerWaiting');
                PlayerController(C).ClientReset();
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x14;
    }
    bEndOfRound = true;
    TAM_GRI(GameReplicationInfo).bEndOfRound = true;
    AnnounceBest();
    // End:0x212
    if(Scorer != none)
    {
        Scorer.Score += float(10000);
        ScoreEvent(Scorer, 0.0, "ObjectiveScore");
    }
    // End:0x227
    if(Scorer == none)
    {
        NextRoundTime = 7;
        return;
    }
    // End:0x261
    if(int(Scorer.Score / float(10000)) >= RoundsToWin)
    {
        EndGame(Scorer, "LastMan");
    }
    // End:0x3B8
    else
    {
        C = Level.ControllerList;
        J0x275:
        // End:0x3B0 [Loop If]
        if(C != none)
        {
            PC = PlayerController(C);
            // End:0x399
            if((PC != none) && PC.PlayerReplicationInfo != none)
            {
                // End:0x384
                if((PC.PlayerReplicationInfo == Scorer) || (PC.PlayerReplicationInfo.bOnlySpectator && (xPawn(PC.ViewTarget) != none) && xPawn(PC.ViewTarget).PlayerReplicationInfo == Scorer) || (Controller(PC.ViewTarget) != none) && Controller(PC.ViewTarget).PlayerReplicationInfo == Scorer)
                {
                    PC.ReceiveLocalizedMessage(class'Message_YouveXTheRound', 1);
                }
                // End:0x399
                else
                {
                    PC.ReceiveLocalizedMessage(class'Message_YouveXTheRound', 0);
                }
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x275;
        }
        NextRoundTime = 7;
    }
    //return;    
}

function AnnounceBest()
{
    local Controller C;
    local string acc, Dam, HS;
    local Misc_PRI PRI, Accuracy, Damage, HeadShots;
    local string Text, Green;
    local Color Color;

    Color.R = 100;
    Color.G = 200;
    Color.B = 100;
    Green = class'DMStatsScreen'.static.MakeColorCode(Color);
    Color.B = 210;
    Color.R = 210;
    Color.G = 210;
    Text = class'DMStatsScreen'.static.MakeColorCode(Color);
    C = Level.ControllerList;
    J0x96:
    // End:0x1AD [Loop If]
    if(C != none)
    {
        PRI = Misc_PRI(C.PlayerReplicationInfo);
        // End:0xDC
        if((PRI == none) || PRI.bOnlySpectator)
        {
        }
        // End:0x196
        else
        {
            PRI.ProcessHitStats();
            // End:0x124
            if((Accuracy == none) || Accuracy.AveragePercent < PRI.AveragePercent)
            {
                Accuracy = PRI;
            }
            // End:0x15D
            if((Damage == none) || Damage.EnemyDamage < PRI.EnemyDamage)
            {
                Damage = PRI;
            }
            // End:0x196
            if((HeadShots == none) || HeadShots.HeadShots < PRI.HeadShots)
            {
                HeadShots = PRI;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x96;
    }
    // End:0x296
    if((Accuracy != none) && Accuracy.AveragePercent > 0.0)
    {
        // End:0x23F
        if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
        {
            acc = ((((((Text $ "Most Accurate:") @ Green) $ Accuracy.GetColoredName()) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
        }
        // End:0x296
        else
        {
            acc = ((((((Text $ "Most Accurate:") @ Green) $ Accuracy.PlayerName) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
        }
    }
    // End:0x36D
    if((Damage != none) && Damage.EnemyDamage > 0)
    {
        // End:0x31D
        if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
        {
            Dam = (((((Text $ "Most Damage:") @ Green) $ Damage.GetColoredName()) $ Text) $ ";") @ string(Damage.EnemyDamage);
        }
        // End:0x36D
        else
        {
            Dam = (((((Text $ "Most Damage:") @ Green) $ Damage.PlayerName) $ Text) $ ";") @ string(Damage.EnemyDamage);
        }
    }
    // End:0x44A
    if((HeadShots != none) && HeadShots.HeadShots > 0)
    {
        // End:0x3F7
        if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
        {
            HS = (((((Text $ "Most Headshots:") @ Green) $ HeadShots.GetColoredName()) $ Text) $ ";") @ string(HeadShots.HeadShots);
        }
        // End:0x44A
        else
        {
            HS = (((((Text $ "Most Headshots:") @ Green) $ HeadShots.PlayerName) $ Text) $ ";") @ string(HeadShots.HeadShots);
        }
    }
    C = Level.ControllerList;
    J0x45E:
    // End:0x4B3 [Loop If]
    if(C != none)
    {
        // End:0x49C
        if(Misc_Player(C) != none)
        {
            Misc_Player(C).ClientListBest(acc, Dam, HS);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x45E;
    }
    //return;    
}

function SetMapString(Misc_Player Sender, string S)
{
    // End:0x41
    if((Level.NetMode == NM_Standalone) || Sender.PlayerReplicationInfo.bAdmin)
    {
        NextMapString = S;
    }
    //return;    
}

function EndGame(PlayerReplicationInfo PRI, string Reason)
{
    super(DeathMatch).EndGame(PRI, Reason);
    ResetDefaults();
    //return;    
}

function RestartGame()
{
    ResetDefaults();
    super(UnrealMPGameInfo).RestartGame();
    //return;    
}

function ProcessServerTravel(string URL, bool bItems)
{
    ResetDefaults();
    super(GameInfo).ProcessServerTravel(URL, bItems);
    //return;    
}

function ResetDefaults()
{
    // End:0x0B
    if(bDefaultsReset)
    {
        return;
    }
    bDefaultsReset = true;
    class'xPawn'.default.ControllerClass = class'xBot';
    class'ComboSpeed'.default.Duration = 16.0;
    GoalScore = RoundsToWin;
    MutTAM.ResetWeaponsToDefaults(bModifyShieldGun);
    // End:0x7D
    if(NextMapString != "")
    {
        ParseOptions(NextMapString);
        SaveConfig();
        NextMapString = "";
    }
    //return;    
}

auto state PendingMatch
{
    function Timer()
    {
        local Controller P;
        local bool bReady;

        global.Timer();
        // End:0x19
        if(NumPlayers == 0)
        {
            bWaitForNetPlayers = true;
        }
        // End:0x93
        if(bWaitForNetPlayers && Level.NetMode != NM_Standalone)
        {
            // End:0x56
            if(NumPlayers >= MinNetPlayers)
            {
                ++ ElapsedTime;
            }
            // End:0x5D
            else
            {
                ElapsedTime = 0;
            }
            // End:0x90
            if((NumPlayers == MaxPlayers) || ElapsedTime > NetWait)
            {
                bWaitForNetPlayers = false;
                CountDown = default.CountDown;
            }
        }
        // End:0xC7
        else
        {
            // End:0xC7
            if(bForceRUP && bPlayersMustBeReady)
            {
                // End:0xC0
                if(NumPlayers >= ForceRUPMinPlayers)
                {
                    ++ ElapsedTime;
                }
                // End:0xC7
                else
                {
                    ElapsedTime = 0;
                }
            }
        }
        // End:0x10F
        if((Level.NetMode != NM_Standalone) && bWaitForNetPlayers || bTournament && NumPlayers < MaxPlayers)
        {
            PlayStartupMessage();
            return;
        }
        bReady = true;
        StartupStage = 1;
        // End:0x213
        if(!bStartedCountDown && (bTournament || bPlayersMustBeReady) || Level.NetMode == NM_Standalone)
        {
            P = Level.ControllerList;
            J0x16F:
            // End:0x213 [Loop If]
            if(P != none)
            {
                // End:0x1FC
                if((((P.IsA('PlayerController') && P.PlayerReplicationInfo != none) && P.bIsPlayer) && P.PlayerReplicationInfo.bWaitingPlayer) && !P.PlayerReplicationInfo.bReadyToPlay)
                {
                    bReady = false;
                }
                P = P.nextController;
                // [Loop Continue]
                goto J0x16F;
            }
        }
        // End:0x24A
        if(((!bReady && bForceRUP) && bPlayersMustBeReady) && ElapsedTime > 60)
        {
            bReady = true;
        }
        // End:0x296
        if(bReady && !bReviewingJumpSpots)
        {
            bStartedCountDown = true;
            -- CountDown;
            // End:0x283
            if(CountDown <= 0)
            {
                StartMatch();
            }
            // End:0x296
            else
            {
                StartupStage = byte(5 - CountDown);
            }
        }
        PlayStartupMessage();
        //return;        
    }
    stop;    
}

state MatchInProgress
{
    function Timer()
    {
        local Controller C;

        C = Level.ControllerList;
        J0x14:
        // End:0x6F [Loop If]
        if(C != none)
        {
            // End:0x3B
            if(Misc_Pawn(C.Pawn) == none)
            {
            }
            // End:0x58
            else
            {
                Misc_Pawn(C.Pawn).UpdateSpawnProtection();
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x14;
        }
        // End:0xB1
        if(NextRoundTime > 0)
        {
            GameReplicationInfo.bStopCountDown = true;
            -- NextRoundTime;
            // End:0xA6
            if(NextRoundTime == 0)
            {
                StartNewRound();
            }
            // End:0xAE
            else
            {
                super.Timer();
                return;
            }
        }
        // End:0x386
        else
        {
            // End:0x2AA
            if(bRoundOT)
            {
                GameReplicationInfo.bStopCountDown = false;
                ++ RoundOTTime;
                // End:0x2A7
                if((float(RoundOTTime) % float(OTInterval)) == float(0))
                {
                    C = Level.ControllerList;
                    J0xFE:
                    // End:0x2A7 [Loop If]
                    if(C != none)
                    {
                        // End:0x120
                        if(C.Pawn == none)
                        {
                        }
                        // End:0x290
                        else
                        {
                            // End:0x1AF
                            if((C.Pawn.Health <= OTDamage) && C.Pawn.ShieldStrength <= float(0))
                            {
                                C.Pawn.TakeDamage(1000, C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Overtime');
                            }
                            // End:0x290
                            else
                            {
                                // End:0x226
                                if(int(C.Pawn.ShieldStrength) > 0)
                                {
                                    C.Pawn.ShieldStrength = float(int(C.Pawn.ShieldStrength) - Min(int(C.Pawn.ShieldStrength), OTDamage));
                                }
                                // End:0x244
                                else
                                {
                                    C.Pawn.Health -= OTDamage;
                                }
                                C.Pawn.TakeDamage(int(0.010), C.Pawn, vect(0.0, 0.0, 0.0), vect(0.0, 0.0, 0.0), class'DamType_Overtime');
                            }
                        }
                        C = C.nextController;
                        // [Loop Continue]
                        goto J0xFE;
                    }
                }
            }
            // End:0x386
            else
            {
                // End:0x386
                if(RoundTime > 0)
                {
                    GameReplicationInfo.bStopCountDown = false;
                    -- RoundTime;
                    TAM_GRI(GameReplicationInfo).RoundTime = RoundTime;
                    // End:0x314
                    if((float(RoundTime) % float(60)) == float(0))
                    {
                        TAM_GRI(GameReplicationInfo).RoundMinute = RoundTime;
                    }
                    // End:0x386
                    if(RoundTime == 0)
                    {
                        bRoundOT = true;
                        C = Level.ControllerList;
                        J0x33B:
                        // End:0x386 [Loop If]
                        if(C != none)
                        {
                            // End:0x36F
                            if(PlayerController(C) != none)
                            {
                                PlayerController(C).ClientPlaySound(default.OvertimeSound);
                            }
                            C = C.nextController;
                            // [Loop Continue]
                            goto J0x33B;
                        }
                    }
                }
            }
        }
        CheckForCampers();
        CleanUpPawns();
        // End:0x3A3
        if(RespawnTime > 0)
        {
            RespawnTimer();
        }
        super.Timer();
        //return;        
    }
    stop;    
}

defaultproperties
{
    StartingHealth=100
    StartingArmor=100
    MaxHealth=1.250
    AdrenalinePerDamage=1.0
    bForceRUP=true
    MinsPerRound=2
    OTDamage=5
    OTInterval=3
    CampThreshold=400.0
    CampInterval=5
    bKickExcessiveCampers=true
    LockTime=4
    AssaultAmmo=999
    AssaultGrenades=5
    BioAmmo=20
    ShockAmmo=20
    LinkAmmo=100
    MiniAmmo=75
    FlakAmmo=12
    RocketAmmo=12
    LightningAmmo=10
    EnableNewNet=true
    ShowServerName=true
    FlagTextureEnabled=true
    FlagTextureShowAcronym=true
    OvertimeSound=Sound'Sounds.overtime'
    ADR_MinorError=-5.0
    LoginMenuClass="3SPNv3210CW.Menu_TAMLoginMenu"
    LocalStatsScreenClass=class'Misc_StatBoard'
    DefaultPlayerClassName="3SPNv3210CW.Misc_Pawn"
    ScoreBoardType="3SPNv3210CW.AM_Scoreboard"
    HUDType="3SPNv3210CW.AM_HUD"
    MapListType="3SPNv3210CW.MapListArenaMaster"
    GoalScore=5
    MaxLives=1
    TimeLimit=0
    DeathMessageClass=class'Misc_DeathMessage'
    MutatorClass="3SPNv3210CW.TAM_Mutator"
    PlayerControllerClassName="3SPNv3210CW.Misc_Player"
    GameReplicationInfoClass=class'TAM_GRI'
    GameName="ArenaMaster v3"
    Description="One life per round. Don't waste it"
    Acronym="AM"
}