/*******************************************************************************
 * NewNet_AssaultGrenade generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_AssaultGrenade extends WeaponFire_AssaultAlt
    dependson(WeaponFire_AssaultAlt);

const PROJ_TIMESTEP = 0.0201;
const MAX_PROJECTILE_FUDGE = 0.0750;

var float PingDT;
var bool bUseEnhancedNetCode;

function Projectile SpawnProjectile(Vector Start, Rotator Dir)
{
    local Grenade G;
    local Vector X, Y, Z;
    local float pawnSpeed;
    local Vector Velocity;
    local float Speed;
    local Rotator NewDir;
    local Actor Other;
    local Vector HitNormal, HitLocation, End;
    local float H, F;

    // End:0x1C
    if(!bUseEnhancedNetCode)
    {
        return super(AssaultGrenade).SpawnProjectile(Start, Dir);
    }
    Weapon.GetViewAxes(X, Y, Z);
    pawnSpeed = X Dot Instigator.Velocity;
    // End:0x7C
    if(Bot(Instigator.Controller) != none)
    {
        Speed = mHoldSpeedMax;
    }
    // End:0x95
    else
    {
        Speed = mHoldSpeedMin + (HoldTime * mHoldSpeedGainPerSec);
    }
    Speed = FClamp(Speed, mHoldSpeedMin, mHoldSpeedMax);
    Speed = pawnSpeed + Speed;
    Velocity = Speed * vector(Dir);
    // End:0x2A5
    if((PingDT > 0.0) && Weapon.Owner != none)
    {
        NewDir = Dir;
        F = 0.0;
        J0x10D:
        // End:0x1B1 [Loop If]
        if(F < (PingDT + 0.02010))
        {
            H = FMin(PingDT, F);
            End = Start + (Extrapolate(NewDir, 0.02010, Speed));
            TimeTravel(PingDT - H);
            Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);
            // End:0x197
            if(Other != none)
            {
                // [Explicit Break]
                goto J0x1B1;
            }
            Start = End;
            F += 0.02010;
            J0x1B1:
            // [Loop Continue]
            goto J0x10D;
        }
        UnTimeTravel();
        // End:0x22A
        if((Other != none) && Other.IsA('NewNet_PawnCollisionCopy'))
        {
            HitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
            Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
        }
        Velocity = Speed * vector(NewDir);
        // End:0x26F
        if(Other == none)
        {
            G = Weapon.Spawn(class'Grenade',,, End, NewDir);
        }
        // End:0x2A2
        else
        {
            G = Weapon.Spawn(class'Grenade',,, HitLocation - (vector(NewDir) * 16.0), NewDir);
        }
    }
    // End:0x2CC
    else
    {
        G = Weapon.Spawn(class'Grenade', Instigator,, Start, Dir);
    }
    // End:0x2D9
    if(G == none)
    {
        return none;
    }
    G.Speed = Speed;
    G.Velocity = Velocity;
    G.Damage *= DamageAtten;
    return G;
    //return;    
}

function Vector Extrapolate(out Rotator Dir, float dF, float Speed)
{
    local Rotator oldDir;

    oldDir = Dir;
    Dir = rotator((vector(oldDir) * Speed) + (Weapon.Owner.PhysicsVolume.Gravity * dF));
    return ((vector(oldDir) * Speed) * dF) + ((0.50 * Square(dF)) * Weapon.Owner.PhysicsVolume.Gravity);
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_AssaultRifle(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_AssaultRifle(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_AssaultRifle(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_AssaultRifle(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}
