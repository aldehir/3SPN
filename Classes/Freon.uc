/*******************************************************************************
 * Freon generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Freon extends TeamArenaMaster
    dependson(TeamArenaMaster)
    dependson(Freon_Player)
    dependson(Freon_Trigger)
    dependson(Misc_DynComboManager)
    dependson(Freon_GRI)
    hidecategories(Movement,Collision,Lighting,LightColor,Karma,Force)
    config;

var config float AutoThawTime;
var config float ThawSpeed;
var config float MinHealthOnThaw;
var bool bTeamHeal;
var array<Freon_Pawn> FrozenPawns;
var config int NextRoundDelayFreon;
var config bool TeleportOnThaw;
var config bool bSpawnProtectionOnThaw;
var config bool KillGitters;
var config int MaxGitsAllowed;
var config Color KillGitterMsgColour;
var config string KillGitterMsg;
var Sound TeleportSound;

function InitGameReplicationInfo()
{
    super.InitGameReplicationInfo();
    // End:0x18
    if(Freon_GRI(GameReplicationInfo) == none)
    {
        return;
    }
    Freon_GRI(GameReplicationInfo).AutoThawTime = AutoThawTime;
    Freon_GRI(GameReplicationInfo).ThawSpeed = ThawSpeed;
    Freon_GRI(GameReplicationInfo).bTeamHeal = bTeamHeal;
    //return;    
}

function StartNewRound()
{
    FrozenPawns.Remove(0, FrozenPawns.Length);
    super.StartNewRound();
    //return;    
}

static function FillPlayInfo(PlayInfo Pi)
{
    super.FillPlayInfo(Pi);
    Pi.AddSetting("3SPN", "bSpawnProtectionOnThaw", "Enable Spawn Protection After Thawing", 0, byte(500), "Check");
    Pi.AddSetting("3SPN", "TeleportOnThaw", "Teleport After Thawing", 0, byte(501), "Check");
    Pi.AddSetting("3SPN", "AutoThawTime", "Automatic Thawing Time", 0, byte(502), "Text", "3;0:999");
    Pi.AddSetting("3SPN", "ThawSpeed", "Touch Thawing Time", 0, byte(503), "Text", "3;0:999");
    Pi.AddSetting("3SPN", "MinHealthOnThaw", "Minimum Health After Thawing", 0, byte(504), "Text", "3;0:999");
    Pi.AddSetting("3SPN", "KillGitters", "Kill Gitters", 0, byte(505), "Check");
    Pi.AddSetting("3SPN", "MaxGitsAllowed", "Max Gits Allowed", 0, byte(506), "Text", "3;0:999");
    //return;    
}

static event string GetDescriptionText(string PropName)
{
    switch(PropName)
    {
        // End:0x4A
        case "bSpawnProtectionOnThaw":
            return "Enable Spawn Protection After Thawing";
        // End:0x76
        case "TeleportOnThaw":
            return "Teleport After Thawing";
        // End:0xA0
        case "AutoThawTime":
            return "Automatic Thawing Time";
        // End:0xC3
        case "ThawSpeed":
            return "Touch Thawing Time";
        // End:0xF6
        case "MinHealthOnThaw":
            return "Minimum Health After Thawing";
        // End:0x115
        case "KillGitters":
            return "Kill Gitters";
        // End:0x13B
        case "MaxGitsAllowed":
            return "Max Gits Allowed";
        // End:0xFFFF
        default:
            return super.GetDescriptionText(PropName);
    }
    //return;    
}

function ParseOptions(string Options)
{
    local string InOpt;

    super.ParseOptions(Options);
    InOpt = ParseOption(Options, "AutoThawTime");
    // End:0x43
    if(InOpt != "")
    {
        AutoThawTime = float(InOpt);
    }
    InOpt = ParseOption(Options, "ThawSpeed");
    // End:0x78
    if(InOpt != "")
    {
        ThawSpeed = float(InOpt);
    }
    InOpt = ParseOption(Options, "TeamHeal");
    // End:0xAD
    if(InOpt != "")
    {
        bTeamHeal = bool(InOpt);
    }
    //return;    
}

event InitGame(string Options, out string Error)
{
    super.InitGame(Options, Error);
    class'xPawn'.default.ControllerClass = class'Freon_Bot';
    NextRoundDelay = NextRoundDelayFreon;
    //return;    
}

function string SwapDefaultCombo(string ComboName)
{
    // End:0x3E
    if(ComboName ~= "xGame.ComboSpeed")
    {
        return "3SPNv3210CW.Freon_ComboSpeed";
    }
    // End:0x7C
    else
    {
        // End:0x7C
        if(ComboName ~= "xGame.ComboBerserk")
        {
            return "3SPNv3210CW.Misc_ComboBerserk";
        }
    }
    return ComboName;
    //return;    
}

function PawnFroze(Freon_Pawn Frozen)
{
    local int i;

    i = 0;
    J0x07:
    // End:0x38 [Loop If]
    if(i < FrozenPawns.Length)
    {
        // End:0x2E
        if(FrozenPawns[i] == Frozen)
        {
            return;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    FrozenPawns[FrozenPawns.Length] = Frozen;
    Frozen.Spree = 0;
    // End:0x91
    if(Misc_Player(Frozen.Controller) != none)
    {
        Misc_Player(Frozen.Controller).Spree = 0;
    }
    //return;    
}

function RestartFrozenPlayer(Controller aPlayer, Vector loc, Rotator Rot, NavigationPoint Anchor)
{
    local int TeamNum;
    local class<Pawn> DefaultPlayerClass;
    local Vehicle V, Best;
    local Vector ViewDir;
    local float BestDist, dist;
    local TeamInfo BotTeam, OtherTeam;

    // End:0xE8
    if((((!bPlayersVsBots || Level.NetMode == NM_Standalone) && bBalanceTeams) && Bot(aPlayer) != none) && !bCustomBots || Level.NetMode != NM_Standalone)
    {
        BotTeam = aPlayer.PlayerReplicationInfo.Team;
        // End:0xA9
        if(BotTeam == Teams[0])
        {
            OtherTeam = Teams[1];
        }
        // End:0xB6
        else
        {
            OtherTeam = Teams[0];
        }
        // End:0xE8
        if(OtherTeam.Size < (BotTeam.Size - 1))
        {
            aPlayer.Destroy();
            return;
        }
    }
    // End:0x11E
    if((bMustJoinBeforeStart && UnrealPlayer(aPlayer) != none) && UnrealPlayer(aPlayer).bLatecomer)
    {
        return;
    }
    // End:0x13B
    if(aPlayer.PlayerReplicationInfo.bOutOfLives)
    {
        return;
    }
    // End:0x16D
    if(aPlayer.IsA('Bot') && TooManyBots(aPlayer))
    {
        aPlayer.Destroy();
        return;
    }
    // End:0x1AE
    if((bRestartLevel && Level.NetMode != NM_DedicatedServer) && Level.NetMode != NM_ListenServer)
    {
        return;
    }
    // End:0x1EC
    if((aPlayer.PlayerReplicationInfo == none) || aPlayer.PlayerReplicationInfo.Team == none)
    {
        TeamNum = 255;
    }
    // End:0x212
    else
    {
        TeamNum = aPlayer.PlayerReplicationInfo.Team.TeamIndex;
    }
    // End:0x25D
    if((aPlayer.PreviousPawnClass != none) && aPlayer.PawnClass != aPlayer.PreviousPawnClass)
    {
        BaseMutator.PlayerChangedClass(aPlayer);
    }
    // End:0x29D
    if(aPlayer.PawnClass != none)
    {
        aPlayer.Pawn = Spawn(aPlayer.PawnClass,,, loc, Rot);
    }
    // End:0x2E5
    if(aPlayer.Pawn == none)
    {
        DefaultPlayerClass = GetDefaultPlayerClass(aPlayer);
        aPlayer.Pawn = Spawn(DefaultPlayerClass,,, loc, Rot);
    }
    // End:0x37E
    if(aPlayer.Pawn == none)
    {
        Log((("Couldn't spawn player of type " $ string(aPlayer.PawnClass)) $ " at ") $ string(Location));
        aPlayer.GotoState('Dead');
        // End:0x37C
        if(PlayerController(aPlayer) != none)
        {
            PlayerController(aPlayer).ClientGotoState('Dead', 'Begin');
        }
        return;
    }
    // End:0x3A7
    if(PlayerController(aPlayer) != none)
    {
        PlayerController(aPlayer).TimeMargin = -0.10;
    }
    // End:0x3CF
    if(Anchor != none)
    {
        aPlayer.Pawn.Anchor = Anchor;
    }
    aPlayer.Pawn.LastStartTime = Level.TimeSeconds;
    aPlayer.PreviousPawnClass = aPlayer.Pawn.Class;
    aPlayer.Possess(aPlayer.Pawn);
    aPlayer.PawnClass = aPlayer.Pawn.Class;
    aPlayer.ClientSetRotation(aPlayer.Pawn.Rotation);
    AddDefaultInventory(aPlayer.Pawn);
    // End:0x620
    if((bAllowVehicles && Level.NetMode == NM_Standalone) && PlayerController(aPlayer) != none)
    {
        BestDist = 2000.0;
        ViewDir = vector(aPlayer.Pawn.Rotation);
        V = VehicleList;
        J0x503:
        // End:0x5F2 [Loop If]
        if(V != none)
        {
            // End:0x5DB
            if(V.bTeamLocked && aPlayer.GetTeamNum() == V.Team)
            {
                dist = VSize(V.Location - aPlayer.Pawn.Location);
                // End:0x5B6
                if((ViewDir Dot (V.Location - aPlayer.Pawn.Location)) < float(0))
                {
                    dist *= float(2);
                }
                // End:0x5DB
                if(dist < BestDist)
                {
                    Best = V;
                    BestDist = dist;
                }
            }
            V = V.NextVehicle;
            // [Loop Continue]
            goto J0x503;
        }
        // End:0x620
        if(Best != none)
        {
            Best.PlayerStartTime = Level.TimeSeconds + float(8);
        }
    }
    //return;    
}

function PlayerThawed(Freon_Pawn Thawed, optional float Health, optional float Shield, optional bool Dying)
{
    local Vector pos, Vel;
    local Rotator Rot;
    local Controller C;
    local array<WeaponData> WD;
    local Inventory Inv;
    local int i;
    local NavigationPoint N;
    local Controller LastHitBy;
    local int Team;
    local bool bGivesGit;
    local int TeamNum;
    local NavigationPoint StartSpot;

    // End:0x0B
    if(bEndOfRound)
    {
        return;
    }
    // End:0xB1
    if(!Dying && Health == 0.0)
    {
        C = Level.ControllerList;
        J0x3B:
        // End:0x98 [Loop If]
        if(C != none)
        {
            // End:0x81
            if(C.Pawn != none)
            {
                Health += float(C.Pawn.Health);
                ++ i;
            }
            C = C.nextController;
            // [Loop Continue]
            goto J0x3B;
        }
        // End:0xB1
        if(i > 0)
        {
            Health /= float(i);
        }
    }
    // End:0x169
    if(!Dying && TeleportOnThaw)
    {
        C = Thawed.Controller;
        // End:0x119
        if((C.PlayerReplicationInfo == none) || C.PlayerReplicationInfo.Team == none)
        {
            TeamNum = 255;
        }
        // End:0x13F
        else
        {
            TeamNum = C.PlayerReplicationInfo.Team.TeamIndex;
        }
        StartSpot = Level.Game.FindPlayerStart(C, byte(TeamNum));
    }
    // End:0x1DB
    if(StartSpot != none)
    {
        pos = StartSpot.Location;
        Rot = StartSpot.Rotation;
        Vel = vect(0.0, 0.0, 0.0);
        Thawed.PlaySound(TeleportSound, 0, 300.0);
        Thawed.PlayTeleportEffect(true, false);
    }
    // End:0x217
    else
    {
        pos = Thawed.Location;
        Rot = Thawed.Rotation;
        Vel = Thawed.Velocity;
    }
    C = Thawed.Controller;
    N = Thawed.Anchor;
    LastHitBy = Thawed.LastHitBy;
    bGivesGit = Thawed.bGivesGit;
    // End:0x27F
    if(C.PlayerReplicationInfo == none)
    {
        return;
    }
    WD = Thawed.MyWD;
    i = 0;
    J0x29A:
    // End:0x2D5 [Loop If]
    if(i < FrozenPawns.Length)
    {
        // End:0x2CB
        if(FrozenPawns[i] == Thawed)
        {
            FrozenPawns.Remove(i, 1);
        }
        ++ i;
        // [Loop Continue]
        goto J0x29A;
    }
    Thawed.Destroy();
    C.PlayerReplicationInfo.bOutOfLives = false;
    C.PlayerReplicationInfo.NumLives = 1;
    // End:0x338
    if(PlayerController(C) != none)
    {
        PlayerController(C).ClientReset();
    }
    RestartFrozenPlayer(C, pos, Rot, N);
    // End:0x5CB
    if(C.Pawn != none)
    {
        C.Pawn.SetLocation(pos);
        C.Pawn.SetRotation(Rot);
        C.Pawn.AddVelocity(Vel);
        C.Pawn.LastHitBy = LastHitBy;
        // End:0x53F
        if(!Dying)
        {
            Inv = C.Pawn.Inventory;
            J0x3FC:
            // End:0x4C9 [Loop If]
            if(Inv != none)
            {
                // End:0x419
                if(Weapon(Inv) == none)
                {
                    return;
                }
                i = 0;
                J0x420:
                // End:0x4B2 [Loop If]
                if(i < WD.Length)
                {
                    // End:0x4A8
                    if(WD[i].WeaponName ~= string(Inv.Class))
                    {
                        Weapon(Inv).AmmoCharge[0] = WD[i].Ammo[0];
                        Weapon(Inv).AmmoCharge[1] = WD[i].Ammo[1];
                        // [Explicit Break]
                        goto J0x4B2;
                    }
                    ++ i;
                    J0x4B2:
                    // [Loop Continue]
                    goto J0x420;
                }
                Inv = Inv.Inventory;
                // [Loop Continue]
                goto J0x3FC;
            }
            // End:0x503
            if(Health != 0.0)
            {
                C.Pawn.Health = Max(int(MinHealthOnThaw), int(Health));
            }
            // End:0x522
            else
            {
                C.Pawn.Health = int(MinHealthOnThaw);
            }
            C.Pawn.ShieldStrength = Shield;
        }
        // End:0x57C
        if(Freon_Pawn(C.Pawn) != none)
        {
            Freon_Pawn(C.Pawn).bGivesGit = bGivesGit;
        }
        // End:0x5CB
        if(Dying || (bSpawnProtectionOnThaw == false) && Misc_Pawn(C.Pawn) != none)
        {
            Misc_Pawn(C.Pawn).DeactivateSpawnProtection();
        }
    }
    // End:0x5F4
    if(PlayerController(C) != none)
    {
        PlayerController(C).ClientSetRotation(Rot);
    }
    Team = C.GetTeamNum();
    // End:0x617
    if(Team == 255)
    {
        return;
    }
    // End:0x679
    if((TAM_TeamInfo(Teams[Team]) != none) && TAM_TeamInfo(Teams[Team]).ComboManager != none)
    {
        TAM_TeamInfo(Teams[Team]).ComboManager.PlayerSpawned(C);
    }
    // End:0x73A
    else
    {
        // End:0x6DB
        if((TAM_TeamInfoRed(Teams[Team]) != none) && TAM_TeamInfoRed(Teams[Team]).ComboManager != none)
        {
            TAM_TeamInfoRed(Teams[Team]).ComboManager.PlayerSpawned(C);
        }
        // End:0x73A
        else
        {
            // End:0x73A
            if((TAM_TeamInfoBlue(Teams[Team]) != none) && TAM_TeamInfoBlue(Teams[Team]).ComboManager != none)
            {
                TAM_TeamInfoBlue(Teams[Team]).ComboManager.PlayerSpawned(C);
            }
        }
    }
    // End:0x769
    if(!Dying)
    {
        BroadcastLocalizedMessage(class'Freon_ThawMessage', 255, C.Pawn.PlayerReplicationInfo);
    }
    //return;    
}

function PlayerThawedByTouch(Freon_Pawn Thawed, array<Freon_Pawn> Thawers, optional float Health, optional float Shield)
{
    local Controller C;
    local int i;
    local Freon_PRI xPRI;
    local class<LocalMessage> Message;

    // End:0x0B
    if(bEndOfRound)
    {
        return;
    }
    C = Thawed.Controller;
    PlayerThawed(Thawed, Health, Shield);
    // End:0x6E
    if(PlayerController(C) != none)
    {
        PlayerController(C).ReceiveLocalizedMessage(class'Freon_ThawMessage', 0, Thawers[0].PlayerReplicationInfo);
    }
    // End:0x84
    if(C.PlayerReplicationInfo == none)
    {
        return;
    }
    i = 0;
    J0x8B:
    // End:0x24C [Loop If]
    if(i < Thawers.Length)
    {
        // End:0xD9
        if(Thawers[i].PlayerReplicationInfo != none)
        {
            Thawers[i].PlayerReplicationInfo.Score += 2.0;
        }
        // End:0x116
        if(Thawers[i].Controller != none)
        {
            Thawers[i].Controller.AwardAdrenaline(5.0);
        }
        xPRI = Freon_PRI(Thawers[i].PlayerReplicationInfo);
        // End:0x1EC
        if(xPRI != none)
        {
            Message = none;
            ++ xPRI.Thaws;
            // End:0x17A
            if(xPRI.Thaws == 15)
            {
                Message = class'Message_Thawsome';
            }
            // End:0x19A
            else
            {
                // End:0x19A
                if(xPRI.Thaws == 20)
                {
                    Message = class'Message_Godofthaw';
                }
            }
            // End:0x1EC
            if(Message != none)
            {
                // End:0x1EC
                if(Misc_Player(Thawers[i].Controller) != none)
                {
                    Misc_Player(Thawers[i].Controller).BroadcastAnnouncement(Message);
                }
            }
        }
        // End:0x242
        if(PlayerController(Thawers[i].Controller) != none)
        {
            PlayerController(Thawers[i].Controller).ReceiveLocalizedMessage(class'Freon_ThawMessage', 1, C.PlayerReplicationInfo);
        }
        ++ i;
        // [Loop Continue]
        goto J0x8B;
    }
    //return;    
}

function bool CanSpectate(PlayerController Viewer, bool bOnlySpectator, Actor ViewTarget)
{
    // End:0x44
    if((xPawn(ViewTarget) == none) && (Controller(ViewTarget) == none) || xPawn(Controller(ViewTarget).Pawn) == none)
    {
        return false;
    }
    // End:0x9D
    if(bOnlySpectator)
    {
        // End:0x88
        if(Controller(ViewTarget) != none)
        {
            return (Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer;
        }
        // End:0x9D
        else
        {
            return xPawn(ViewTarget).IsPlayerPawn();
        }
    }
    // End:0xB3
    if(Viewer.Pawn != none)
    {
        return false;
    }
    // End:0xD6
    if(bRespawning || (NextRoundTime <= 1) && bEndOfRound)
    {
        return false;
    }
    // End:0x15E
    if(Controller(ViewTarget) != none)
    {
        return ((Controller(ViewTarget).PlayerReplicationInfo != none) && ViewTarget != Viewer) && bEndOfRound || (Controller(ViewTarget).GetTeamNum() == Viewer.GetTeamNum()) && Viewer.GetTeamNum() != 255;
    }
    // End:0x1DB
    else
    {
        return (xPawn(ViewTarget).IsPlayerPawn() && xPawn(ViewTarget).PlayerReplicationInfo != none) && bEndOfRound || (xPawn(ViewTarget).GetTeamNum() == Viewer.GetTeamNum()) && Viewer.GetTeamNum() != 255;
    }
    //return;    
}

function bool DestroyActor(Actor A)
{
    // End:0x2B
    if((Freon_Pawn(A) != none) && Freon_Pawn(A).bFrozen)
    {
        return true;
    }
    return super(Team_GameBase).DestroyActor(A);
    //return;    
}

function EndRound(PlayerReplicationInfo Scorer)
{
    local Freon_Trigger FT;

    // End:0x1D
    foreach DynamicActors(class'Freon_Trigger', FT)
    {
        FT.Destroy();        
    }    
    super(Team_GameBase).EndRound(Scorer);
    //return;    
}

function AnnounceBest()
{
    local Controller C;
    local string acc, Dam, HS, th, gt;

    local Freon_PRI PRI;
    local Misc_PRI Accuracy, Damage, HeadShots;
    local Freon_PRI Thaws, Git;
    local string Red, Blue, Text;
    local Color Color;

    Red = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.RedTeamColor);
    Blue = class'DMStatsScreen'.static.MakeColorCode(class'SayMessagePlus'.default.BlueTeamColor);
    Color = class'Canvas'.static.MakeColor(210, 210, 210);
    Text = class'DMStatsScreen'.static.MakeColorCode(Color);
    C = Level.ControllerList;
    J0x8F:
    // End:0x22E [Loop If]
    if(C != none)
    {
        PRI = Freon_PRI(C.PlayerReplicationInfo);
        // End:0xEB
        if(((PRI == none) || PRI.Team == none) || PRI.bOnlySpectator)
        {
        }
        // End:0x217
        else
        {
            PRI.ProcessHitStats();
            // End:0x133
            if((Accuracy == none) || Accuracy.AveragePercent < PRI.AveragePercent)
            {
                Accuracy = PRI;
            }
            // End:0x16C
            if((Damage == none) || Damage.EnemyDamage < PRI.EnemyDamage)
            {
                Damage = PRI;
            }
            // End:0x1A5
            if((HeadShots == none) || HeadShots.HeadShots < PRI.HeadShots)
            {
                HeadShots = PRI;
            }
            // End:0x1DE
            if((Thaws == none) || Thaws.Thaws < PRI.Thaws)
            {
                Thaws = PRI;
            }
            // End:0x217
            if((Git == none) || Git.Git < PRI.Git)
            {
                Git = PRI;
            }
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0x8F;
    }
    // End:0x3FB
    if((Accuracy != none) && Accuracy.AveragePercent > 0.0)
    {
        // End:0x337
        if(Accuracy.Team.TeamIndex == 0)
        {
            // End:0x2DD
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                acc = ((((((Text $ "Most Accurate:") @ Red) $ Accuracy.GetColoredName()) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
            // End:0x334
            else
            {
                acc = ((((((Text $ "Most Accurate:") @ Red) $ Accuracy.PlayerName) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
        }
        // End:0x3FB
        else
        {
            // End:0x3A4
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                acc = ((((((Text $ "Most Accurate:") @ Blue) $ Accuracy.GetColoredName()) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
            // End:0x3FB
            else
            {
                acc = ((((((Text $ "Most Accurate:") @ Blue) $ Accuracy.PlayerName) $ Text) $ ";") @ string(Accuracy.AveragePercent)) $ "%";
            }
        }
    }
    // End:0x5A8
    if((Damage != none) && Damage.EnemyDamage > 0)
    {
        // End:0x4F2
        if(Damage.Team.TeamIndex == 0)
        {
            // End:0x49F
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                Dam = (((((Text $ "Most Damage:") @ Red) $ Damage.GetColoredName()) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
            // End:0x4EF
            else
            {
                Dam = (((((Text $ "Most Damage:") @ Red) $ Damage.PlayerName) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
        }
        // End:0x5A8
        else
        {
            // End:0x558
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                Dam = (((((Text $ "Most Damage:") @ Blue) $ Damage.GetColoredName()) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
            // End:0x5A8
            else
            {
                Dam = (((((Text $ "Most Damage:") @ Blue) $ Damage.PlayerName) $ Text) $ ";") @ string(Damage.EnemyDamage);
            }
        }
    }
    // End:0x761
    if((HeadShots != none) && HeadShots.HeadShots > 0)
    {
        // End:0x6A5
        if(HeadShots.Team.TeamIndex == 0)
        {
            // End:0x64F
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                HS = (((((Text $ "Most Headshots:") @ Red) $ HeadShots.GetColoredName()) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
            // End:0x6A2
            else
            {
                HS = (((((Text $ "Most Headshots:") @ Red) $ HeadShots.PlayerName) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
        }
        // End:0x761
        else
        {
            // End:0x70E
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                HS = (((((Text $ "Most Headshots:") @ Blue) $ HeadShots.GetColoredName()) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
            // End:0x761
            else
            {
                HS = (((((Text $ "Most Headshots:") @ Blue) $ HeadShots.PlayerName) $ Text) $ ";") @ string(HeadShots.HeadShots);
            }
        }
    }
    // End:0x91E
    if((Thaws != none) && Thaws.Thaws > 0)
    {
        // End:0x860
        if(Thaws.Team.TeamIndex == 0)
        {
            // End:0x809
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                th = ((((((Text $ "Most Thaws:") @ Red) $ Thaws.GetColoredName()) $ Text) $ ";") @ string(Thaws.Thaws)) @ " ";
            }
            // End:0x85D
            else
            {
                th = ((((((Text $ "Most Thaws:") @ Red) $ Thaws.PlayerName) $ Text) $ ";") @ string(Thaws.Thaws)) @ " ";
            }
        }
        // End:0x91E
        else
        {
            // End:0x8CA
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                th = ((((((Text $ "Most Thaws:") @ Blue) $ Thaws.GetColoredName()) $ Text) $ ";") @ string(Thaws.Thaws)) @ " ";
            }
            // End:0x91E
            else
            {
                th = ((((((Text $ "Most Thaws:") @ Blue) $ Thaws.PlayerName) $ Text) $ ";") @ string(Thaws.Thaws)) @ " ";
            }
        }
    }
    // End:0xADF
    if((Git != none) && Git.Git > 0)
    {
        // End:0xA1F
        if(Git.Team.TeamIndex == 0)
        {
            // End:0x9C7
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                gt = ((((((Text $ "Biggest Git:") @ Red) $ Git.GetColoredName()) $ Text) $ ";") @ string(Git.Git)) @ " ";
            }
            // End:0xA1C
            else
            {
                gt = ((((((Text $ "Biggest Git:") @ Red) $ Git.PlayerName) $ Text) $ ";") @ string(Git.Git)) @ " ";
            }
        }
        // End:0xADF
        else
        {
            // End:0xA8A
            if(class'Misc_Player'.default.bEnableColoredNamesInTalk)
            {
                gt = ((((((Text $ "Biggest Git:") @ Blue) $ Git.GetColoredName()) $ Text) $ ";") @ string(Git.Git)) @ " ";
            }
            // End:0xADF
            else
            {
                gt = ((((((Text $ "Biggest Git:") @ Blue) $ Git.PlayerName) $ Text) $ ";") @ string(Git.Git)) @ " ";
            }
        }
    }
    C = Level.ControllerList;
    J0xAF3:
    // End:0xB52 [Loop If]
    if(C != none)
    {
        // End:0xB3B
        if(Freon_Player(C) != none)
        {
            Freon_Player(C).ClientListBestFreon(acc, Dam, HS, th, gt);
        }
        C = C.nextController;
        // [Loop Continue]
        goto J0xAF3;
    }
    //return;    
}

defaultproperties
{
    AutoThawTime=90.0
    ThawSpeed=5.0
    MinHealthOnThaw=25.0
    bTeamHeal=true
    NextRoundDelayFreon=1
    TeleportOnThaw=true
    bSpawnProtectionOnThaw=true
    MaxGitsAllowed=1
    KillGitterMsgColour=(R=226,G=2,B=232,A=0)
    KillGitterMsg="You will die on Gits from now on."
    TeleportSound=Sound'Teleport'
    bDisableTeamCombos=false
    TeamAIType[0]=class'Freon_TeamAI'
    TeamAIType[1]=class'Freon_TeamAI'
    DefaultPlayerClassName="3SPNv3210CW.Freon_Pawn"
    ScoreBoardType="3SPNv3210CW.Freon_Scoreboard"
    HUDType="3SPNv3210CW.Freon_HUD"
    MapListType="3SPNv3210CW.MapListFreon"
    PlayerControllerClassName="3SPNv3210CW.Freon_Player"
    GameReplicationInfoClass=class'Freon_GRI'
    GameName="Freon"
    Description="Freeze the other team, score a point. Chill well and serve."
    Acronym="Freon"
}