/*******************************************************************************
 * Freon_Pawn generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Freon_Pawn extends Misc_Pawn
    dependson(Misc_Pawn)
    dependson(Freon_Player)
    dependson(Freon_Bot)
    dependson(Freon)
    dependson(Freon_Trigger)
    dependson(Freon_PRI)
    dependson(Freon_PawnReplicationInfo)
    config(User);

var bool bFrozen;
var bool bClientFrozen;
var bool bGivesGit;
var Freon_Trigger MyTrigger;
var float DecimalHealth;
var Material FrostMaterial;
var Material FrostMap;
var bool bThawFast;
var array<WeaponData> MyWD;
var Sound ImpactSounds[6];

replication
{
    // Pos:0x000
    reliable if(bNetDirty && Role == ROLE_Authority)
        bFrozen
}

simulated function UpdatePrecacheMaterials()
{
    super(Actor).UpdatePrecacheMaterials();
    Level.AddPrecacheMaterial(FrostMaterial);
    Level.AddPrecacheMaterial(FrostMap);
    //return;    
}

simulated function Destroyed()
{
    // End:0x1E
    if(MyTrigger != none)
    {
        MyTrigger.Destroy();
        MyTrigger = none;
    }
    super.Destroyed();
    //return;    
}

function PossessedBy(Controller C)
{
    super.PossessedBy(C);
    // End:0x30
    if(MyTrigger == none)
    {
        MyTrigger = Spawn(class'Freon_Trigger', self,, Location, Rotation);
    }
    //return;    
}

function TakeDamage(int Damage, Pawn instigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType)
{
    local Vector zeroVec;
    local int actualDamage;
    local Controller Killer;

    zeroVec = vect(0.0, 0.0, 0.0);
    // End:0x39
    if(IsSpawnProtectionEnabled())
    {
        super.TakeDamage(0, instigatedBy, HitLocation, zeroVec, DamageType);
        return;
    }
    // End:0xA6
    if(DamageType == none)
    {
        // End:0x9B
        if(instigatedBy != none)
        {
            Warn((("No DamageType for damage by " $ string(instigatedBy)) $ " with weapon ") $ string(instigatedBy.Weapon));
        }
        DamageType = class'DamageType';
    }
    // End:0xEE
    if(Role < ROLE_Authority)
    {
        Log((((string(self) $ " client DamageType ") $ string(DamageType)) $ " by ") $ string(instigatedBy));
        return;
    }
    // End:0xFB
    if(Health <= 0)
    {
        return;
    }
    // End:0x151
    if((((instigatedBy == none) || instigatedBy.Controller == none) && DamageType.default.bDelayedDamage) && DelayedDamageInstigatorController != none)
    {
        instigatedBy = DelayedDamageInstigatorController.Pawn;
    }
    // End:0x174
    if((Physics == 0) && DrivenVehicle == none)
    {
        SetMovementPhysics();
    }
    // End:0x1BD
    if((Physics == 1) && DamageType.default.bExtraMomentumZ)
    {
        Momentum.Z = FMax(Momentum.Z, 0.40 * VSize(Momentum));
    }
    // End:0x1D4
    if(instigatedBy == self)
    {
        Momentum *= 0.60;
    }
    Momentum = Momentum / Mass;
    // End:0x219
    if(Weapon != none)
    {
        Weapon.AdjustPlayerDamage(Damage, instigatedBy, HitLocation, Momentum, DamageType);
    }
    // End:0x24C
    if(DrivenVehicle != none)
    {
        DrivenVehicle.AdjustDriverDamage(Damage, instigatedBy, HitLocation, Momentum, DamageType);
    }
    // End:0x276
    if((instigatedBy != none) && instigatedBy.HasUDamage())
    {
        Damage *= float(2);
    }
    actualDamage = Level.Game.ReduceDamage(Damage, self, instigatedBy, HitLocation, Momentum, DamageType);
    // End:0x2DE
    if(DamageType.default.bArmorStops && actualDamage > 0)
    {
        actualDamage = ShieldAbsorb(actualDamage);
    }
    Health -= actualDamage;
    // End:0x30C
    if(HitLocation == vect(0.0, 0.0, 0.0))
    {
        HitLocation = Location;
    }
    // End:0x487
    if(Health <= 0)
    {
        // End:0x35E
        if((DamageType.default.bCausedByWorld && (instigatedBy == none) || instigatedBy == self) && LastHitBy != none)
        {
            Killer = LastHitBy;
        }
        // End:0x37E
        else
        {
            // End:0x37E
            if(instigatedBy != none)
            {
                Killer = instigatedBy.GetKillerController();
            }
        }
        // End:0x3A8
        if((Killer == none) && DamageType.default.bDelayedDamage)
        {
            Killer = DelayedDamageInstigatorController;
        }
        // End:0x419
        if(Level.Game.PreventDeath(self, Killer, DamageType, HitLocation))
        {
            Health = Max(Health, 1);
            PlayHit(float(actualDamage), instigatedBy, HitLocation, DamageType, Momentum);
            // End:0x416
            if(bPhysicsAnimUpdate)
            {
                TearOffMomentum = Momentum;
            }
        }
        // End:0x484
        else
        {
            // End:0x43A
            if(Froze(Killer, DamageType, HitLocation))
            {
                PlayFreezingHit();
            }
            // End:0x484
            else
            {
                PlayHit(float(actualDamage), instigatedBy, HitLocation, DamageType, Momentum);
                // End:0x46F
                if(bPhysicsAnimUpdate)
                {
                    TearOffMomentum = Momentum;
                }
                Died(Killer, DamageType, HitLocation);
            }
        }
    }
    // End:0x512
    else
    {
        PlayHit(float(actualDamage), instigatedBy, HitLocation, DamageType, Momentum);
        AddVelocity(Momentum);
        // End:0x4E6
        if(Controller != none)
        {
            Controller.NotifyTakeHit(instigatedBy, HitLocation, actualDamage, DamageType, Momentum);
        }
        // End:0x512
        if((instigatedBy != none) && instigatedBy != self)
        {
            LastHitBy = instigatedBy.Controller;
        }
    }
    MakeNoise(1.0);
    //return;    
}

function Died(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local Freon_PRI xPRI;
    local Freon Freon;
    local Controller Gitter;

    // End:0x229
    if(bGivesGit)
    {
        // End:0x22
        if(Killer != none)
        {
            Gitter = Killer;
        }
        // End:0x42
        else
        {
            // End:0x3B
            if(LastHitBy != none)
            {
                Gitter = LastHitBy;
            }
            // End:0x42
            else
            {
                Gitter = none;
            }
        }
        // End:0x229
        if(((Gitter != none) && Misc_Player(Gitter) != none) && self.Controller != Gitter)
        {
            xPRI = Freon_PRI(Gitter.PlayerReplicationInfo);
            // End:0x229
            if(xPRI != none)
            {
                ++ xPRI.Git;
                Freon = Freon(Level.Game);
                // End:0x1B8
                if(Freon.KillGitters)
                {
                    // End:0x145
                    if(xPRI.Git == Freon.MaxGitsAllowed)
                    {
                        Misc_Player(Gitter).ClientMessage(("Warning:" @ class'GameInfo'.static.MakeColorCode(Freon.KillGitterMsgColour)) $ Freon.KillGitterMsg);
                    }
                    // End:0x1B5
                    else
                    {
                        // End:0x1B5
                        if(xPRI.Git > Freon.MaxGitsAllowed)
                        {
                            Misc_Player(Gitter).BroadcastAnnouncement(class'Message_Git');
                            // End:0x1B5
                            if(Misc_Player(Gitter).Pawn != none)
                            {
                                Misc_Player(Gitter).Pawn.Suicide();
                            }
                        }
                    }
                }
                // End:0x229
                else
                {
                    // End:0x229
                    if((float(xPRI.Git) % float(4)) == float(0))
                    {
                        // End:0x1FF
                        if(Misc_Player(Gitter) != none)
                        {
                            Misc_Player(Gitter).BroadcastAnnouncement(class'Message_Git');
                        }
                        Gitter.Adrenaline = float(Max(0, int(Gitter.Adrenaline - float(24))));
                    }
                }
            }
        }
    }
    // End:0x243
    if(MyTrigger != none)
    {
        MyTrigger.OwnerDied();
    }
    super.Died(Killer, DamageType, HitLocation);
    //return;    
}

function bool Froze(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    local Trigger t;
    local NavigationPoint N;

    // End:0x35
    if((bDeleteMe || Level.bLevelChange) || Level.Game == none)
    {
        return false;
    }
    // End:0x4F
    if((Controller == none) || DrivenVehicle != none)
    {
        return false;
    }
    // End:0x74
    if((DamageType == class'DamageType') || DamageType.default.bCausedByWorld)
    {
        return false;
    }
    // End:0x7F
    if(IsInPain())
    {
        return false;
    }
    bFrozen = true;
    // End:0xC7
    if(Freon_PawnReplicationInfo(Freon_PRI(PlayerReplicationInfo).PawnReplicationInfo) != none)
    {
        Freon_PawnReplicationInfo(Freon_PRI(PlayerReplicationInfo).PawnReplicationInfo).PawnFroze();
    }
    FillWeaponData();
    Health = 0;
    AmbientSound = none;
    bProjTarget = false;
    bCanPickupInventory = false;
    PlayerReplicationInfo.bOutOfLives = true;
    NetUpdateTime = Level.TimeSeconds - float(1);
    Controller.WasKilledBy(Killer);
    Level.Game.Killed(Killer, Controller, self, DamageType);
    // End:0x179
    if(Killer != none)
    {
        TriggerEvent(Event, self, Killer.Pawn);
    }
    // End:0x186
    else
    {
        TriggerEvent(Event, self, none);
    }
    // End:0x200
    if((IsPlayerPawn()) || WasPlayerPawn())
    {
        PhysicsVolume.PlayerPawnDiedInVolume(self);
        // End:0x1CB
        foreach TouchingActors(class'Trigger', t)
        {
            t.PlayerToucherDied(self);            
        }        
        // End:0x1FF
        foreach TouchingActors(class'NavigationPoint', N)
        {
            // End:0x1FE
            if(N.bReceivePlayerToucherDiedNotify)
            {
                N.PlayerToucherDied(self);
            }            
        }        
    }
    RemovePowerups();
    // End:0x223
    if(IsHumanControlled())
    {
        PlayerController(Controller).ForceDeathUpdate();
    }
    Freon(Level.Game).PawnFroze(self);
    Freeze();
    return true;
    //return;    
}

function PlayFreezingHit()
{
    // End:0x39
    if(PhysicsVolume.bDestructive && PhysicsVolume.ExitActor != none)
    {
        Spawn(PhysicsVolume.ExitActor);
    }
    //return;    
}

function Freeze()
{
    // End:0x1A
    if(MyTrigger != none)
    {
        MyTrigger.OwnerFroze();
    }
    bPlayedDeath = true;
    StopAnimating(true);
    GotoState('Frozen');
    //return;    
}

function FillWeaponData()
{
    local Inventory Inv;
    local int i;

    Inv = Inventory;
    J0x0B:
    // End:0xCC [Loop If]
    if(Inv != none)
    {
        // End:0x29
        if(Weapon(Inv) == none)
        {
        }
        // End:0xB5
        else
        {
            i = MyWD.Length;
            MyWD.Length = i + 1;
            MyWD[i].WeaponName = string(Inv.Class);
            MyWD[i].Ammo[0] = Weapon(Inv).AmmoCharge[0];
            MyWD[i].Ammo[1] = Weapon(Inv).AmmoCharge[1];
        }
        Inv = Inv.Inventory;
        // [Loop Continue]
        goto J0x0B;
    }
    //return;    
}

simulated function Tick(float DeltaTime)
{
    super.Tick(DeltaTime);
    // End:0x26
    if(Level.NetMode == NM_DedicatedServer)
    {
        return;
    }
    // End:0x97
    if(bFrozen && !bClientFrozen)
    {
        bPhysicsAnimUpdate = false;
        bClientFrozen = true;
        StopAnimating(true);
        // End:0x89
        if(Level.bDropDetail || Level.DetailMode == 0)
        {
            ApplyLowQualityIce();
        }
        // End:0x8F
        else
        {
            ApplyHighQualityIce();
        }
        bScriptPostRender = true;
    }
    //return;    
}

simulated function ApplyLowQualityIce()
{
    local Combiner Body, head;

    // End:0x2D
    if((MyOwner != none) && MyOwner.PlayerReplicationInfo == PlayerReplicationInfo)
    {
        ApplyHighQualityIce();
        return;
    }
    Body = new (none) class'Combiner';
    head = new (none) class'Combiner';
    SetOverlayMaterial(none, 0.0, true);
    SetStandardSkin();
    Body.CombineOperation = 3;
    Body.Material1 = Skins[0];
    Body.Material2 = FrostMaterial;
    head.CombineOperation = 3;
    head.Material1 = Skins[1];
    head.Material2 = FrostMaterial;
    Skins[0] = Body;
    Skins[1] = head;
    //return;    
}

simulated function ApplyHighQualityIce()
{
    local Combiner Body, head, Ice;

    Body = new (none) class'Combiner';
    head = new (none) class'Combiner';
    Ice = new (none) class'Combiner';
    SetOverlayMaterial(none, 0.0, true);
    SetStandardSkin();
    Ice.CombineOperation = 4;
    Ice.Material1 = FrostMap;
    Ice.Material2 = FrostMaterial;
    Body.CombineOperation = 3;
    Body.Material1 = Skins[0];
    Body.Material2 = Ice;
    head.CombineOperation = 3;
    head.Material1 = Skins[1];
    head.Material2 = Ice;
    Skins[0] = Body;
    Skins[1] = head;
    //return;    
}

simulated function SetSkin(int OverrideTeamIndex)
{
    // End:0x0B
    if(bClientFrozen)
    {
        return;
    }
    super.SetSkin(OverrideTeamIndex);
    //return;    
}

function DiedFrozen(Controller Killer, class<DamageType> DamageType, Vector HitLocation)
{
    // End:0x41
    if(Freon(Level.Game) != none)
    {
        Freon(Level.Game).PlayerThawed(self, 0.0, 0.0);
    }
    Died(Killer, DamageType, HitLocation);
    //return;    
}

function Thaw()
{
    bGivesGit = false;
    // End:0x49
    if(Freon(Level.Game) != none)
    {
        Freon(Level.Game).PlayerThawed(self, 0.0, 0.0);
    }
    //return;    
}

function ThawByTouch(array<Freon_Pawn> Thawers, optional float mosthealth)
{
    bGivesGit = false;
    // End:0x4E
    if(Freon(Level.Game) != none)
    {
        Freon(Level.Game).PlayerThawedByTouch(self, Thawers, mosthealth, ShieldStrength);
    }
    //return;    
}

simulated function ChunkUp(Rotator HitRotation, float ChunkPerterbation)
{
    // End:0x57
    if((Level.NetMode != NM_Client) && Controller != none)
    {
        // End:0x4B
        if(Controller.bIsPlayer)
        {
            Controller.PawnDied(self);
        }
        // End:0x57
        else
        {
            Controller.Destroy();
        }
    }
    bTearOff = true;
    // End:0x9A
    if((Level.NetMode == NM_DedicatedServer) || Level.NetMode == NM_ListenServer)
    {
        GotoState('TimingOut');
    }
    // End:0xB5
    if(Level.NetMode == NM_DedicatedServer)
    {
        return;
    }
    // End:0xCC
    if(class'GameInfo'.static.UseLowGore())
    {
        Destroy();
        return;
    }
    SpawnGibs(HitRotation, ChunkPerterbation);
    // End:0xF8
    if(Level.NetMode != NM_ListenServer)
    {
        Destroy();
    }
    //return;    
}

state Frozen
{
    ignores BreathTimer;

    event ChangeAnimation()
    {
        //return;        
    }

    event StopPlayFiring()
    {
        //return;        
    }

    function PlayFiring(float Rate, name FiringMode)
    {
        //return;        
    }

    function PlayWeaponSwitch(Weapon newWeapon)
    {
        //return;        
    }

    function PlayTakeHit(Vector HitLoc, int Damage, class<DamageType> DamageType)
    {
        //return;        
    }

    simulated function PlayNextAnimation()
    {
        //return;        
    }

    function TakeFallingDamage()
    {
        //return;        
    }

    event Landed(Vector HitNormal)
    {
        Velocity = vect(0.0, 0.0, 0.0);
        SetPhysics(1);
        LastHitBy = none;
        PlaySound(default.ImpactSounds[Rand(6)], 2, 1.50 * TransientSoundVolume);
        //return;        
    }

    event Tick(float DeltaTime)
    {
        // End:0x3C
        if(((Physics == 1) || Physics == 3) || Physics == 0)
        {
            bGivesGit = true;
        }
        super(Misc_Pawn).Tick(DeltaTime);
        //return;        
    }

    function TakeDamage(int Damage, Pawn instigatedBy, Vector HitLocation, Vector Momentum, class<DamageType> DamageType)
    {
        // End:0x6D
        if(DamageType == none)
        {
            // End:0x62
            if(instigatedBy != none)
            {
                Warn((("No DamageType for damage by " $ string(instigatedBy)) $ " with weapon ") $ string(instigatedBy.Weapon));
            }
            DamageType = class'DamageType';
        }
        // End:0xB5
        if(Role < ROLE_Authority)
        {
            Log((((string(self) $ " client DamageType ") $ string(DamageType)) $ " by ") $ string(instigatedBy));
            return;
        }
        // End:0xD7
        if(HitLocation == vect(0.0, 0.0, 0.0))
        {
            HitLocation = Location;
        }
        // End:0x114
        if(DamageType.default.bCausedByWorld)
        {
            // End:0x101
            if(DamageType == class'FellLava')
            {
                Thaw();
            }
            // End:0x112
            else
            {
                DiedFrozen(none, DamageType, HitLocation);
            }
            return;
        }
        // End:0x15D
        if((Physics == 1) && DamageType.default.bExtraMomentumZ)
        {
            Momentum.Z = FMax(Momentum.Z, 0.40 * VSize(Momentum));
        }
        Momentum = Momentum / (Mass * 1.50);
        SetPhysics(2);
        Velocity += Momentum;
        // End:0x1DD
        if((((instigatedBy == none) || instigatedBy.Controller == none) && DamageType.default.bDelayedDamage) && DelayedDamageInstigatorController != none)
        {
            instigatedBy = DelayedDamageInstigatorController.Pawn;
        }
        // End:0x209
        if((instigatedBy != none) && instigatedBy != self)
        {
            LastHitBy = instigatedBy.Controller;
        }
        //return;        
    }

    function BeginState()
    {
        SetPhysics(2);
        LastHitBy = none;
        Acceleration = vect(0.0, 0.0, 0.0);
        TearOffMomentum = vect(0.0, 0.0, 0.0);
        // End:0x6E
        if(Freon_Player(Controller) != none)
        {
            Freon_Player(Controller).FrozenPawn = self;
            Freon_Player(Controller).Freeze();
        }
        // End:0x92
        else
        {
            // End:0x92
            if(Freon_Bot(Controller) != none)
            {
                Freon_Bot(Controller).Freeze();
            }
        }
        //return;        
    }
    stop;    
}

defaultproperties
{
    FrostMaterial=Texture'AlleriaTerrain.ground.icebrg01'
    FrostMap=TexEnvMap'CubeMaps.Kretzig.Kretzig2TexENV'
    ImpactSounds[0]=Sound'PlayerSounds.BFootsteps.BFootstepSnow1'
    ImpactSounds[1]=Sound'PlayerSounds.BFootsteps.BFootstepSnow2'
    ImpactSounds[2]=Sound'PlayerSounds.BFootsteps.BFootstepSnow3'
    ImpactSounds[3]=Sound'PlayerSounds.BFootsteps.BFootstepSnow4'
    ImpactSounds[4]=Sound'PlayerSounds.BFootsteps.BFootstepSnow5'
    ImpactSounds[5]=Sound'PlayerSounds.BFootsteps.BFootstepSnow6'
}