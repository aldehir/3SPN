/*******************************************************************************
 * NewNet_ShockProjFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_ShockProjFire extends WeaponFire_ShockAlt;

var class<Projectile> FakeProjectileClass;
var NewNet_FakeProjectileManager FPM;

function PlayFiring()
{
    super(WeaponFire).PlayFiring();
    // End:0x37
    if((Level.NetMode != NM_Client) || !class'Misc_Player'.static.UseNewNet())
    {
        return;
    }
    CheckFireEffect();
    //return;    
}

simulated function CheckFireEffect()
{
    // End:0x33
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        DoClientFireEffect();
    }
    //return;    
}

simulated function DoClientFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    StartTrace = Instigator.Location + Instigator.EyePosition();
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xC7
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x104
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = AdjustAim(StartProj, aimerror);
    SpawnCount = Max(1, ProjPerFire * int(load));
    switch(SpreadStyle)
    {
        // End:0x1DE
        case 1:
            X = vector(Aim);
            P = 0;
            J0x151:
            // End:0x1DB [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                SpawnFakeProjectile(StartProj, rotator(X >> R));
                ++ P;
                // [Loop Continue]
                goto J0x151;
            }
            // End:0x29E
            break;
        // End:0x28B
        case 2:
            P = 0;
            J0x1EA:
            // End:0x288 [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                SpawnFakeProjectile(StartProj, rotator(X >> Aim));
                ++ P;
                // [Loop Continue]
                goto J0x1EA;
            }
            // End:0x29E
            break;
        // End:0xFFFF
        default:
            SpawnFakeProjectile(StartProj, Aim);
            //return;
    }    
}

simulated function Projectile SpawnFakeProjectile(Vector Start, Rotator Dir)
{
    local Projectile P;

    // End:0x1E
    if(FPM == none)
    {
        FindFPM();
        // End:0x1E
        if(FPM == none)
        {
            return none;
        }
    }
    // End:0x58
    if(FPM.AllowFakeProjectile(FakeProjectileClass))
    {
        P = Weapon.Spawn(FakeProjectileClass,,, Start, Dir);
    }
    // End:0x65
    if(P == none)
    {
        return none;
    }
    FPM.RegisterFakeProjectile(P);
    return P;
    //return;    
}

simulated function FindFPM()
{
    // End:0x1D
    foreach Weapon.DynamicActors(class'NewNet_FakeProjectileManager', FPM)
    {
        // End:0x1D
        break;        
    }    
    //return;    
}

defaultproperties
{
    FakeProjectileClass=class'NewNet_Fake_ShockProjectile'
    ProjectileClass=class'NewNet_ShockProjectile'
}