/*******************************************************************************
 * NewNet_ShockBeamFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_ShockBeamFire extends WeaponFire_Shock
    dependson(WeaponFire_Shock)
    dependson(NewNet_ShockRifle);

var bool bUseReplicatedInfo;
var Rotator SavedRot;
var Vector savedVec;
var float PingDT;
var bool bSkipNextEffect;
var bool bUseEnhancedNetCode;

function PlayFiring()
{
    super(WeaponFire).PlayFiring();
    // End:0x37
    if((Level.NetMode != NM_Client) || !class'Misc_Player'.static.UseNewNet())
    {
        return;
    }
    // End:0x4B
    if(!bSkipNextEffect)
    {
        CheckFireEffect();
    }
    // End:0x63
    else
    {
        bSkipNextEffect = false;
        Weapon.ClientStopFire(0);
    }
    //return;    
}

function CheckFireEffect()
{
    // End:0x33
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        DoFireEffect();
    }
    //return;    
}

function DoTrace(Vector Start, Rotator Dir)
{
    local Vector X, End, HitLocation, HitNormal, RefNormal;

    local Actor Other;
    local int Damage;
    local bool bDoReflect;
    local int ReflectNum;
    local Vector PawnHitLocation;

    // End:0x1D
    if(!bUseEnhancedNetCode)
    {
        super(InstantFire).DoTrace(Start, Dir);
        return;
    }
    MaxRange();
    ReflectNum = 0;
    J0x2A:
    // End:0x3EA [Loop If]
    if(true)
    {
        TimeTravel(PingDT);
        bDoReflect = false;
        X = vector(Dir);
        End = Start + (TraceRange * X);
        // End:0xA0
        if(PingDT <= 0.0)
        {
            Other = Weapon.Trace(HitLocation, HitNormal, End, Start, true);
        }
        // End:0xC0
        else
        {
            Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);
        }
        // End:0x136
        if((Other != none) && Other.IsA('NewNet_PawnCollisionCopy'))
        {
            PawnHitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
            Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
        }
        // End:0x141
        else
        {
            PawnHitLocation = HitLocation;
        }
        UnTimeTravel();
        // End:0x347
        if((Other != none) && (Other != Instigator) || ReflectNum > 0)
        {
            // End:0x1E0
            if((bReflective && Other.IsA('xPawn')) && xPawn(Other).CheckReflect(PawnHitLocation, RefNormal, int(float(DamageMin) * 0.250)))
            {
                bDoReflect = true;
                HitNormal = vect(0.0, 0.0, 0.0);
            }
            // End:0x344
            else
            {
                // End:0x2FF
                if(!Other.bWorldGeometry)
                {
                    Damage = DamageMin;
                    // End:0x234
                    if((DamageMin != DamageMax) && FRand() > 0.50)
                    {
                        Damage += Rand((1 + DamageMax) - DamageMin);
                    }
                    Damage = int(float(Damage) * DamageAtten);
                    // End:0x2BA
                    if(Other.IsA('Vehicle') || !Other.IsA('Pawn') && !Other.IsA('HitScanBlockingVolume'))
                    {
                        WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, PawnHitLocation, HitNormal);
                    }
                    Other.TakeDamage(Damage, Instigator, PawnHitLocation, Momentum * X, DamageType);
                    HitNormal = vect(0.0, 0.0, 0.0);
                }
                // End:0x344
                else
                {
                    // End:0x344
                    if(WeaponAttachment(Weapon.ThirdPersonActor) != none)
                    {
                        WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, PawnHitLocation, HitNormal);
                    }
                }
            }
        }
        // End:0x391
        else
        {
            HitLocation = End;
            HitNormal = vect(0.0, 0.0, 0.0);
            WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, PawnHitLocation, HitNormal);
        }
        SpawnBeamEffect(Start, Dir, HitLocation, HitNormal, ReflectNum);
        // End:0x3E4
        if(bDoReflect && ++ ReflectNum < 4)
        {
            Start = HitLocation;
            Dir = rotator(RefNormal);
        }
        // End:0x3E7
        else
        {
            // [Explicit Break]
            goto J0x3EA;
        }
        J0x3EA:
        // [Loop Continue]
        goto J0x2A;
    }
    //return;    
}

function DoInstantFireEffect()
{
    // End:0x3B
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        DoFireEffect();
        bSkipNextEffect = true;
    }
    //return;    
}

function DoFireEffect()
{
    local Vector StartTrace;
    local Rotator R, Aim;

    // End:0x2E
    if(!bUseEnhancedNetCode && Level.NetMode != NM_Client)
    {
        super(ShockBeamFire).DoFireEffect();
        return;
    }
    Instigator.MakeNoise(1.0);
    // End:0x69
    if(bUseReplicatedInfo)
    {
        StartTrace = savedVec;
        R = SavedRot;
        bUseReplicatedInfo = false;
    }
    // End:0xC2
    else
    {
        StartTrace = Instigator.Location + Instigator.EyePosition();
        Aim = AdjustAim(StartTrace, aimerror);
        R = rotator(vector(Aim) + ((VRand() * FRand()) * Spread));
    }
    // End:0xEE
    if(Level.NetMode == NM_Client)
    {
        DoClientTrace(StartTrace, R);
    }
    // End:0xFE
    else
    {
        DoTrace(StartTrace, R);
    }
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_ShockRifle(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_ShockRifle(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_ShockRifle(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_ShockRifle(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}

simulated function DoClientTrace(Vector Start, Rotator Dir)
{
    local Vector X, End, HitLocation, HitNormal, RefNormal;

    local Actor Other;
    local bool bDoReflect;
    local int ReflectNum;

    MaxRange();
    ReflectNum = 0;
    J0x0D:
    // End:0x284 [Loop If]
    if(true)
    {
        bDoReflect = false;
        X = vector(Dir);
        End = Start + (TraceRange * X);
        Other = Weapon.Trace(HitLocation, HitNormal, End, Start, true);
        // End:0x1E1
        if((Other != none) && (Other != Instigator) || ReflectNum > 0)
        {
            // End:0xFF
            if((bReflective && Other.IsA('xPawn')) && xPawn(Other).CheckReflect(HitLocation, RefNormal, int(float(DamageMin) * 0.250)))
            {
                bDoReflect = true;
                HitNormal = vect(0.0, 0.0, 0.0);
            }
            // End:0x1DE
            else
            {
                // End:0x199
                if(!Other.bWorldGeometry)
                {
                    // End:0x183
                    if(Other.IsA('Vehicle') || !Other.IsA('Pawn') && !Other.IsA('HitScanBlockingVolume'))
                    {
                        WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, HitLocation, HitNormal);
                    }
                    HitNormal = vect(0.0, 0.0, 0.0);
                }
                // End:0x1DE
                else
                {
                    // End:0x1DE
                    if(WeaponAttachment(Weapon.ThirdPersonActor) != none)
                    {
                        WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, HitLocation, HitNormal);
                    }
                }
            }
        }
        // End:0x22B
        else
        {
            HitLocation = End;
            HitNormal = vect(0.0, 0.0, 0.0);
            WeaponAttachment(Weapon.ThirdPersonActor).UpdateHit(Other, HitLocation, HitNormal);
        }
        SpawnClientBeamEffect(Start, Dir, HitLocation, HitNormal, ReflectNum);
        // End:0x27E
        if(bDoReflect && ++ ReflectNum < 4)
        {
            Start = HitLocation;
            Dir = rotator(RefNormal);
        }
        // End:0x281
        else
        {
            // [Explicit Break]
            goto J0x284;
        }
        J0x284:
        // [Loop Continue]
        goto J0x0D;
    }
    //return;    
}

simulated function SpawnClientBeamEffect(Vector Start, Rotator Dir, Vector HitLocation, Vector HitNormal, int ReflectNum)
{
    NewNet_ShockRifle(Weapon).SpawnBeamEffect(HitLocation, HitNormal, Start, Dir, ReflectNum);
    //return;    
}

function SpawnBeamEffect(Vector Start, Rotator Dir, Vector HitLocation, Vector HitNormal, int ReflectNum)
{
    local ShockBeamEffect Beam;

    // End:0x6F
    if(!bUseEnhancedNetCode)
    {
        // End:0x6D
        if(Weapon != none)
        {
            Beam = Weapon.Spawn(class'ShockBeamEffect',,, Start, Dir);
            // End:0x54
            if(ReflectNum != 0)
            {
                Beam.Instigator = none;
            }
            Beam.AimAt(HitLocation, HitNormal);
        }
        return;
    }
    // End:0xDE
    if(Weapon != none)
    {
        Beam = Weapon.Spawn(BeamEffectClass, Weapon.Owner,, Start, Dir);
        // End:0xC5
        if(ReflectNum != 0)
        {
            Beam.Instigator = none;
        }
        Beam.AimAt(HitLocation, HitNormal);
    }
    //return;    
}

defaultproperties
{
    BeamEffectClass=class'NewNet_ShockBeamEffect'
}