/*******************************************************************************
 * NewNet_SniperFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_SniperFire extends WeaponFire_Lightning
    dependson(WeaponFire_Lightning)
    dependson(NewNet_SniperRifle);

var bool bUseReplicatedInfo;
var Rotator SavedRot;
var Vector savedVec;
var float PingDT;
var bool bSkipNextEffect;
var bool bUseEnhancedNetCode;
var bool bBelievesHit;
var Actor BelievedHitActor;
var vector BelievedHitLocation;
var float averdt;
var bool bFirstGo;

function PlayFiring()
{
    super(SniperFire).PlayFiring();
    // End:0x37
    if((Level.NetMode != NM_Client) || !class'Misc_Player'.static.UseNewNet())
    {
        return;
    }
    // End:0x4B
    if(!bSkipNextEffect)
    {
        CheckFireEffect();
    }
    // End:0x63
    else
    {
        bSkipNextEffect = false;
        Weapon.ClientStopFire(0);
    }
    //return;    
}

function DoClientTrace(Vector Start, Rotator Dir)
{
    local Vector X, Y, Z, End, HitLocation, HitNormal,
	    RefNormal;

    local Actor Other, mainArcHitTarget;
    local int ReflectNum, arcsRemaining;
    local bool bDoReflect;
    local class<Actor> tmpHitEmitClass;
    local float tmpTraceRange;
    local Vector arcEnd, mainArcHit, EffectOffset;

    // End:0x29
    if(class'PlayerController'.default.bSmallWeapons)
    {
        EffectOffset = Weapon.SmallEffectOffset;
    }
    // End:0x3D
    else
    {
        EffectOffset = Weapon.EffectOffset;
    }
    Weapon.GetViewAxes(X, Y, Z);
    // End:0xB0
    if(Weapon.WeaponCentered() || SniperRifle(Weapon).zoomed)
    {
        arcEnd = Instigator.Location + (EffectOffset.Z * Z);
    }
    // End:0x1B9
    else
    {
        // End:0x146
        if(Weapon.hand == float(0))
        {
            // End:0x102
            if(class'PlayerController'.default.bSmallWeapons)
            {
                arcEnd = Instigator.Location + (EffectOffset.X * X);
            }
            // End:0x143
            else
            {
                arcEnd = (Instigator.Location + (EffectOffset.X * X)) - ((0.50 * EffectOffset.Z) * Z);
            }
        }
        // End:0x1B9
        else
        {
            arcEnd = (((Instigator.Location + Instigator.CalcDrawOffset(Weapon)) + (EffectOffset.X * X)) + ((Weapon.hand * EffectOffset.Y) * Y)) + (EffectOffset.Z * Z);
        }
    }
    arcsRemaining = NumArcs;
    tmpHitEmitClass = class'NewNet_Client_LightningBolt';
    tmpTraceRange = TraceRange;
    ReflectNum = 0;
    J0x1E1:
    // End:0x45D [Loop If]
    if(true)
    {
        bDoReflect = false;
        X = vector(Dir);
        End = Start + (tmpTraceRange * X);
        Other = Weapon.Trace(HitLocation, HitNormal, End, Start, true);
        // End:0x302
        if((Other != none) && (Other != Instigator) || ReflectNum > 0)
        {
            // End:0x2C0
            if((bReflective && Other.UnresolvedNativeFunction_97('xPawn')) && xPawn(Other).CheckReflect(HitLocation, RefNormal, int(float(DamageMin) * 0.250)))
            {
                bDoReflect = true;
            }
            // End:0x2FF
            else
            {
                // End:0x2FF
                if(Other != mainArcHitTarget)
                {
                    // End:0x2E6
                    if(!Other.bWorldGeometry)
                    {
                    }
                    // End:0x2FF
                    else
                    {
                        HitLocation = HitLocation + (2.0 * HitNormal);
                    }
                }
            }
        }
        // End:0x321
        else
        {
            HitLocation = End;
            HitNormal = Normal(Start - End);
        }
        // End:0x32E
        if(Weapon == none)
        {
            return;
        }
        NewNet_SniperRifle(Weapon).SpawnLGEffect(tmpHitEmitClass, arcEnd, HitNormal, HitLocation);
        // End:0x368
        if(HitScanBlockingVolume(Other) != none)
        {
            return;
        }
        // End:0x3BC
        if(arcsRemaining == NumArcs)
        {
            mainArcHit = HitLocation + (HitNormal * 2.0);
            // End:0x3BC
            if((Other != none) && !Other.bWorldGeometry)
            {
                mainArcHitTarget = Other;
            }
        }
        // End:0x40C
        if(bDoReflect && ++ ReflectNum < 4)
        {
            Start = HitLocation;
            Dir = rotator(X - ((2.0 * RefNormal) * (X Dot RefNormal)));
        }
        // End:0x45A
        else
        {
            // End:0x457
            if(arcsRemaining > 0)
            {
                -- arcsRemaining;
                Start = mainArcHit;
                Dir = rotator(VRand());
                tmpHitEmitClass = SecHitEmitterClass;
                tmpTraceRange = SecTraceDist;
                arcEnd = mainArcHit;
            }
            // End:0x45A
            else
            {
                // [Explicit Break]
                goto J0x45D;
            }
        }
        J0x45D:
        // [Loop Continue]
        goto J0x1E1;
    }
    //return;    
}

function CheckFireEffect()
{
    // End:0x33
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        DoFireEffect();
    }
    //return;    
}

function DoInstantFireEffect()
{
    // End:0x3B
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        DoFireEffect();
        bSkipNextEffect = true;
    }
    //return;    
}

function DoFireEffect()
{
    local Vector StartTrace;
    local Rotator R, Aim;

    // End:0x2E
    if(!bUseEnhancedNetCode && Level.NetMode != NM_Client)
    {
        super(InstantFire).DoFireEffect();
        return;
    }
    Instigator.MakeNoise(1.0);
    // End:0x69
    if(bUseReplicatedInfo)
    {
        StartTrace = savedVec;
        R = SavedRot;
        bUseReplicatedInfo = false;
    }
    // End:0xC2
    else
    {
        StartTrace = Instigator.Location + Instigator.EyePosition();
        Aim = AdjustAim(StartTrace, aimerror);
        R = rotator(vector(Aim) + ((VRand() * FRand()) * Spread));
    }
    // End:0xEE
    if(Level.NetMode == NM_Client)
    {
        DoClientTrace(StartTrace, R);
    }
    // End:0xFE
    else
    {
        DoTrace(StartTrace, R);
    }
    //return;    
}

function DoTrace(Vector Start, Rotator Dir)
{
    local Vector X, Y, Z, End, HitLocation, HitNormal,
	    RefNormal;

    local Actor Other, mainArcHitTarget;
    local int Damage, ReflectNum, arcsRemaining;
    local bool bDoReflect;
    local xEmitter hitEmitter;
    local class<Actor> tmpHitEmitClass;
    local float tmpTraceRange;
    local Vector arcEnd, mainArcHit;
    local Pawn HeadShotPawn;
    local Vector EffectOffset, PawnHitLocation;

    // End:0x1D
    if(!bUseEnhancedNetCode)
    {
        super(SniperFire).DoTrace(Start, Dir);
        return;
    }
    // End:0x46
    if(class'PlayerController'.default.bSmallWeapons)
    {
        EffectOffset = Weapon.SmallEffectOffset;
    }
    // End:0x5A
    else
    {
        EffectOffset = Weapon.EffectOffset;
    }
    Weapon.GetViewAxes(X, Y, Z);
    // End:0xCD
    if(Weapon.WeaponCentered() || SniperRifle(Weapon).zoomed)
    {
        arcEnd = Instigator.Location + (EffectOffset.Z * Z);
    }
    // End:0x1D6
    else
    {
        // End:0x163
        if(Weapon.hand == float(0))
        {
            // End:0x11F
            if(class'PlayerController'.default.bSmallWeapons)
            {
                arcEnd = Instigator.Location + (EffectOffset.X * X);
            }
            // End:0x160
            else
            {
                arcEnd = (Instigator.Location + (EffectOffset.X * X)) - ((0.50 * EffectOffset.Z) * Z);
            }
        }
        // End:0x1D6
        else
        {
            arcEnd = (((Instigator.Location + Instigator.CalcDrawOffset(Weapon)) + (EffectOffset.X * X)) + ((Weapon.hand * EffectOffset.Y) * Y)) + (EffectOffset.Z * Z);
        }
    }
    arcsRemaining = NumArcs;
    tmpHitEmitClass = class'NewNet_NewLightningBolt';
    tmpTraceRange = TraceRange;
    ReflectNum = 0;
    TimeTravel(PingDT);
    
    while (true)
    {
        bDoReflect = false;
        X = Vector(Dir);
        End = Start + tmpTraceRange * X;

        if(PingDT <=0.0)
            Other = Weapon.Trace(HitLocation,HitNormal,End,Start,true);
        else
            Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);

        if(Other!=None && Other.IsA('PawnCollisionCopy'))
        {
            //Maintain the same ray, but move to the real pawn
            //ToDo: handle crouching differences
            PawnHitLocation = HitLocation + PawnCollisionCopy(Other).CopiedPawn.Location - Other.Location;
            Other=PawnCollisionCopy(Other).CopiedPawn;

        }
        else
        {
            PawnHitLocation = HitLocation;
        }

        if(bFirstGo && bBelievesHit && !(Other == BelievedHitActor))
        {
            if(ArcsRemaining == NumArcs)
            {
                f = 0.02;
                while(abs(f) < (0.04 + 2.0*AverDT))
                {

                    TimeTravel(PingDT-f);
                    if((PingDT-f) <=0.0)
                          AltOther = Weapon.Trace(AltHitLocation,AltHitNormal,End,Start,true);
                    else
                          AltOther = DoTimeTravelTrace(AltHitLocation, AltHitNormal, End, Start);

                    if(AltOther!=None && AltOther.IsA('PawnCollisionCopy'))
                    {
                         AltPawnHitLocation = AltHitLocation + PawnCollisionCopy(AltOther).CopiedPawn.Location - AltOther.Location;
                         AltOther=PawnCollisionCopy(AltOther).CopiedPawn;
                    }
                    else
                    {
                        AltPawnHitLocation=AltHitLocation;
                    }

                    if(altOther == BelievedHitACtor)
                    {
                    //   Log("Fixed At"@f@"with max"@(0.04 + 2.0*AverDT));
                       Other=altOther;
                       PawnHitLocation=AltPawnHitLocation;
                       HitLocation=AltHitLocation;
                       f=10.0;
                    }
                    if(f > 0.00)
                        f = -1.0*f;
                    else
                        f = -1.0*f+0.02;
                }
            }
        }
        else if(bFirstGo && !bBelievesHit && Other!=None &&(Other.IsA('xpawn') || Other.IsA('Vehicle')))
        {
            if(ArcsRemaining == NumArcs)
            {
                f = 0.02;
                while(abs(f) < (0.04 + 2.0*AverDT))
                {
                    AltOther=None;
                    TimeTravel(PingDT-f);
                    if((PingDT-f) <=0.0)
                          AltOther = Weapon.Trace(AltHitLocation,AltHitNormal,End,Start,true);
                    else
                          AltOther = DoTimeTravelTrace(AltHitLocation, AltHitNormal, End, Start);

                    if(AltOther!=None && AltOther.IsA('PawnCollisionCopy'))
                    {
                         AltPawnHitLocation = AltHitLocation + PawnCollisionCopy(AltOther).CopiedPawn.Location - AltOther.Location;
                         AltOther=PawnCollisionCopy(AltOther).CopiedPawn;
                    }
                    else
                    {
                         AltPAwnHitLocation=AltHitLocation;
                    }

                    if(altOther == None || !(altOther.IsA('xpawn') || altOther.IsA('Vehicle')))
                    {
                    //   Log("Reverse Fixed At"@f);
                       Other=altOther;
                       PawnHitLocation=AltPawnHitLocation;
                       HitLocation=AltHitLocation;
                       f=10.0;
                    }
                    if(f > 0.00)
                        f = -1.0*f;
                    else
                        f = -1.0*f+0.02;
                }
            }
        }
        bFirstGo=false;
        if ( Other != None && (Other != Instigator || ReflectNum > 0) )
        {
            if (bReflective && Other.IsA('xPawn') && xPawn(Other).CheckReflect(PawnHitLocation, RefNormal, DamageMin*0.25))
            {
                bDoReflect = true;
            }
            else if ( Other != mainArcHitTarget )
            {
                if ( !Other.bWorldGeometry )
                {
                    Damage = (DamageMin + Rand(DamageMax - DamageMin)) * DamageAtten;

                    if (Vehicle(Other) != None)
                        HeadShotPawn = Vehicle(Other).CheckForHeadShot(PawnHitLocation, X, 1.0);

                    if (HeadShotPawn != None)
                        HeadShotPawn.TakeDamage(Damage * HeadShotDamageMult, Instigator, PawnHitLocation, Momentum*X, DamageTypeHeadShot);
					else if ( (Pawn(Other) != None) && (arcsRemaining == NumArcs)
						&& Pawn(Other).IsHeadShot(PawnHitLocation, X, 1.0) )
                        Other.TakeDamage(Damage * HeadShotDamageMult, Instigator, PawnHitLocation, Momentum*X, DamageTypeHeadShot);
                    else
                    {
						if ( arcsRemaining < NumArcs )
							Damage *= SecDamageMult;
                        Other.TakeDamage(Damage, Instigator, PawnHitLocation, Momentum*X, DamageType);
					}
                }
                else
					HitLocation = HitLocation + 2.0 * HitNormal;
            }
        }
        else
        {
            HitLocation = End;
            HitNormal = Normal(Start - End);
        }
        if ( Weapon == None )
			return;
        hitEmitter = xEmitter(Weapon.Spawn(tmpHitEmitClass,,, arcEnd, Rotator(HitNormal)));
        if ( hitEmitter != None )
			hitEmitter.mSpawnVecA = HitLocation;
		if ( HitScanBlockingVolume(Other) != None )
		{
        	UnTimeTravel();
            return;
        }

        if( arcsRemaining == NumArcs )
        {
            mainArcHit = HitLocation + (HitNormal * 2.0);
            if ( Other != None && !Other.bWorldGeometry )
                mainArcHitTarget = Other;
        }

        if (bDoReflect && ++ReflectNum < 4)
        {
            //Log("reflecting off"@Other@Start@HitLocation);
            Start = HitLocation;
            Dir = Rotator( X - 2.0*RefNormal*(X dot RefNormal) );
        }
        else if ( arcsRemaining > 0 )
        {
            arcsRemaining--;

            // done parent arc, now move trace point to arc trace hit location and try child arcs from there
            Start = mainArcHit;
            Dir = Rotator(VRand());
            tmpHitEmitClass = class'NewNet_ChildLightningBolt';//SecHitEmitterClass;
            tmpTraceRange = SecTraceDist;
            arcEnd = mainArcHit;
        }
        else
        {
            break;
        }
    }
    UnTimeTravel();
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_SniperRifle(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_SniperRifle(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_SniperRifle(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_SniperRifle(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}
