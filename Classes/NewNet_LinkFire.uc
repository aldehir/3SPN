/*******************************************************************************
 * NewNet_LinkFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_LinkFire extends WeaponFire_Link
    dependson(WeaponFire_Link);

var float PingDT;
var bool bUseEnhancedNetCode;

simulated function ModeTick(float dt)
{
    local Vector StartTrace, EndTrace, V, X, Y, Z,
	    HitLocation, HitNormal, EndEffect;

    local Actor Other;
    local Rotator Aim;
    local LinkGun LinkGun;
    local float Step, ls;
    local Bot B;
    local bool bShouldStop, bIsHealingObjective;
    local int AdjustedDamage;
    local LinkBeamEffect LB;
    local DestroyableObjective HealObjective;
    local Vehicle LinkedVehicle;
    local bool bNeedRevert;
    local Vector PawnHitLocation;

    // End:0x33
    if(!bUseEnhancedNetCode || Instigator.Role < ROLE_Authority)
    {
        super(LinkFire).ModeTick(dt);
        return;
    }
    // End:0x48
    if(!bIsFiring)
    {
        bInitAimError = true;
        return;
    }
    LinkGun = LinkGun(Weapon);
    // End:0xBB
    if(LinkGun.Links < 0)
    {
        Log(((("warning:" @ string(Instigator)) @ "linkgun had") @ string(LinkGun.Links)) @ "links");
        LinkGun.Links = 0;
    }
    ls = LinkScale[Min(LinkGun.Links, 5)];
    // End:0x124D
    if((myHasAmmo(LinkGun)) && (UpTime > 0.0) || Instigator.Role < ROLE_Authority)
    {
        UpTime -= dt;
        LinkGun.GetViewAxes(X, Y, Z);
        StartTrace = GetFireStart(X, Y, Z);
        TraceRange = default.TraceRange + float(LinkGun.Links * 250);
        // End:0x229
        if(Instigator.Role < ROLE_Authority)
        {
            // End:0x20A
            if(Beam == none)
            {
                // End:0x209
                foreach Weapon.DynamicActors(class'LinkBeamEffect', LB)
                {
                    // End:0x208
                    if((!LB.bDeleteMe && LB.Instigator != none) && LB.Instigator == Instigator)
                    {
                        Beam = LB;
                        // End:0x209
                        break;
                    }                    
                }                
            }
            // End:0x229
            if(Beam != none)
            {
                LockedPawn = Beam.LinkedPawn;
            }
        }
        // End:0x240
        if(LockedPawn != none)
        {
            TraceRange *= 1.50;
        }
        // End:0x579
        if(Instigator.Role == ROLE_Authority)
        {
            // End:0x27D
            if(bDoHit)
            {
                LinkGun.ConsumeAmmo(ThisModeNum, float(AmmoPerFire));
            }
            B = Bot(Instigator.Controller);
            // End:0x579
            if(((B != none) && PlayerController(B.Squad.SquadLeader) != none) && B.Squad.SquadLeader.Pawn != none)
            {
                // End:0x53E
                if(((IsLinkable(B.Squad.SquadLeader.Pawn)) && (B.Squad.SquadLeader.Pawn.Weapon != none) && B.Squad.SquadLeader.Pawn.Weapon.GetFireMode(1).bIsFiring) && VSize(B.Squad.SquadLeader.Pawn.Location - StartTrace) < TraceRange)
                {
                    Other = Weapon.Trace(HitLocation, HitNormal, B.Squad.SquadLeader.Pawn.Location, StartTrace, true);
                    // End:0x500
                    if(Other == B.Squad.SquadLeader.Pawn)
                    {
                        B.Focus = B.Squad.SquadLeader.Pawn;
                        // End:0x4AB
                        if(B.Focus != LockedPawn)
                        {
                            SetLinkTo(B.Squad.SquadLeader.Pawn);
                        }
                        B.SetRotation(rotator(B.Focus.Location - StartTrace));
                        X = Normal(B.Focus.Location - StartTrace);
                    }
                    // End:0x53B
                    else
                    {
                        // End:0x53B
                        if(B.Focus == B.Squad.SquadLeader.Pawn)
                        {
                            bShouldStop = true;
                        }
                    }
                }
                // End:0x579
                else
                {
                    // End:0x579
                    if(B.Focus == B.Squad.SquadLeader.Pawn)
                    {
                        bShouldStop = true;
                    }
                }
            }
        }
        // End:0x64C
        if(LockedPawn != none)
        {
            EndTrace = LockedPawn.Location + (LockedPawn.BaseEyeHeight * vect(0.0, 0.0, 0.50));
            // End:0x64C
            if(Instigator.Role == ROLE_Authority)
            {
                V = Normal(EndTrace - StartTrace);
                // End:0x64C
                if(((((V Dot X) < LinkFlexibility) || LockedPawn.Health <= 0) || LockedPawn.bDeleteMe) || VSize(EndTrace - StartTrace) > (1.50 * TraceRange))
                {
                    SetLinkTo(none);
                }
            }
        }
        // End:0x91A
        if(LockedPawn == none)
        {
            // End:0x8DE
            if(Bot(Instigator.Controller) != none)
            {
                // End:0x69A
                if(bInitAimError)
                {
                    CurrentAimError = AdjustAim(StartTrace, aimerror);
                    bInitAimError = false;
                }
                // End:0x6CA
                else
                {
                    BoundError();
                    CurrentAimError.Yaw = CurrentAimError.Yaw + Instigator.Rotation.Yaw;
                }
                Step = 7500.0 * dt;
                // End:0x759
                if(ClockwiseFrom_IntInt(DesiredAimError.Yaw, CurrentAimError.Yaw))
                {
                    CurrentAimError.Yaw += int(Step);
                    // End:0x756
                    if(!ClockwiseFrom_IntInt(DesiredAimError.Yaw, CurrentAimError.Yaw))
                    {
                        CurrentAimError.Yaw = DesiredAimError.Yaw;
                        DesiredAimError = AdjustAim(StartTrace, aimerror);
                    }
                }
                // End:0x7B4
                else
                {
                    CurrentAimError.Yaw -= int(Step);
                    // End:0x7B4
                    if(ClockwiseFrom_IntInt(DesiredAimError.Yaw, CurrentAimError.Yaw))
                    {
                        CurrentAimError.Yaw = DesiredAimError.Yaw;
                        DesiredAimError = AdjustAim(StartTrace, aimerror);
                    }
                }
                CurrentAimError.Yaw = CurrentAimError.Yaw - Instigator.Rotation.Yaw;
                // End:0x7FD
                if(BoundError())
                {
                    DesiredAimError = AdjustAim(StartTrace, aimerror);
                }
                CurrentAimError.Yaw = CurrentAimError.Yaw + Instigator.Rotation.Yaw;
                // End:0x86D
                if(Instigator.Controller.Target == none)
                {
                    Aim = rotator(Instigator.Controller.FocalPoint - StartTrace);
                }
                // End:0x89C
                else
                {
                    Aim = rotator(Instigator.Controller.Target.Location - StartTrace);
                }
                Aim.Yaw = CurrentAimError.Yaw;
                CurrentAimError.Yaw = CurrentAimError.Yaw - Instigator.Rotation.Yaw;
            }
            // End:0x8F4
            else
            {
                Aim = GetPlayerAim(StartTrace, aimerror);
            }
            X = vector(Aim);
            EndTrace = StartTrace + (TraceRange * X);
        }
        // End:0x953
        if(PingDT <= 0.0)
        {
            Other = Weapon.Trace(HitLocation, HitNormal, EndTrace, StartTrace, true);
        }
        // End:0x986
        else
        {
            TimeTravel(PingDT);
            bNeedRevert = true;
            Other = DoTimeTravelTrace(HitLocation, HitNormal, EndTrace, StartTrace);
        }
        // End:0x9FC
        if((Other != none) && Other.IsA('NewNet_PawnCollisionCopy'))
        {
            PawnHitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
            Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
        }
        // End:0xA07
        else
        {
            PawnHitLocation = HitLocation;
        }
        // End:0xA31
        if((Other != none) && Other != Instigator)
        {
            EndEffect = HitLocation;
        }
        // End:0xA3C
        else
        {
            EndEffect = EndTrace;
        }
        // End:0xA5B
        if(Beam != none)
        {
            Beam.EndEffect = EndEffect;
        }
        // End:0xBE9
        if(Instigator.Role < ROLE_Authority)
        {
            // End:0xBD8
            if(LinkGun.ThirdPersonActor != none)
            {
                // End:0xB83
                if(LinkGun.Linking || ((Other != none) && Instigator.PlayerReplicationInfo.Team != none) && Other.TeamLink(Instigator.PlayerReplicationInfo.Team.TeamIndex))
                {
                    // End:0xB61
                    if((Instigator.PlayerReplicationInfo.Team == none) || Instigator.PlayerReplicationInfo.Team.TeamIndex == 0)
                    {
                        LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(1);
                    }
                    // End:0xB80
                    else
                    {
                        LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(2);
                    }
                }
                // End:0xBD8
                else
                {
                    // End:0xBB9
                    if(LinkGun.Links > 0)
                    {
                        LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(3);
                    }
                    // End:0xBD8
                    else
                    {
                        LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(0);
                    }
                }
            }
            // End:0xBE7
            if(bNeedRevert)
            {
                UnTimeTravel();
            }
            return;
        }
        // End:0xE75
        if((Other != none) && Other != Instigator)
        {
            // End:0xC4B
            if(IsLinkable(Other))
            {
                // End:0xC32
                if(Other != LockedPawn)
                {
                    SetLinkTo(Pawn(Other));
                }
                // End:0xC48
                if(LockedPawn != none)
                {
                    LinkBreakTime = LinkBreakDelay;
                }
            }
            // End:0xE75
            else
            {
                // End:0xC7B
                if(LockedPawn != none)
                {
                    // End:0xC6F
                    if(LinkBreakTime <= 0.0)
                    {
                        SetLinkTo(none);
                    }
                    // End:0xC7B
                    else
                    {
                        LinkBreakTime -= dt;
                    }
                }
                // End:0xE75
                if(bDoHit)
                {
                    // End:0xCA0
                    if(Beam != none)
                    {
                        Beam.bLockedOn = false;
                    }
                    Instigator.MakeNoise(1.0);
                    AdjustedDamage = int(AdjustLinkDamage(LinkGun, Other, float(Damage)));
                    // End:0xE75
                    if(!Other.bWorldGeometry)
                    {
                        // End:0xD6D
                        if(((Level.Game.bTeamGame && Pawn(Other) != none) && Pawn(Other).PlayerReplicationInfo != none) && Pawn(Other).PlayerReplicationInfo.Team == Instigator.PlayerReplicationInfo.Team)
                        {
                            AdjustedDamage = 0;
                        }
                        HealObjective = DestroyableObjective(Other);
                        // End:0xDA1
                        if(HealObjective == none)
                        {
                            HealObjective = DestroyableObjective(Other.Owner);
                        }
                        // End:0xE2A
                        if((HealObjective != none) && HealObjective.TeamLink(Instigator.GetTeamNum()))
                        {
                            SetLinkTo(none);
                            bIsHealingObjective = true;
                            // End:0xE27
                            if(!HealObjective.HealDamage(AdjustedDamage, Instigator.Controller, DamageType))
                            {
                                LinkGun.ConsumeAmmo(ThisModeNum, float(-AmmoPerFire));
                            }
                        }
                        // End:0xE59
                        else
                        {
                            Other.TakeDamage(AdjustedDamage, Instigator, PawnHitLocation, MomentumTransfer * X, DamageType);
                        }
                        // End:0xE75
                        if(Beam != none)
                        {
                            Beam.bLockedOn = true;
                        }
                    }
                }
            }
        }
        LinkedVehicle = Vehicle(LockedPawn);
        // End:0xF3E
        if((LinkedVehicle != none) && bDoHit)
        {
            AdjustedDamage = int((float(Damage) * ((1.50 * float(LinkGun.Links)) + float(1))) * Instigator.DamageScaling);
            // End:0xEF5
            if(Instigator.HasUDamage())
            {
                AdjustedDamage *= float(2);
            }
            // End:0xF3E
            if(!LinkedVehicle.HealDamage(AdjustedDamage, Instigator.Controller, DamageType))
            {
                LinkGun.ConsumeAmmo(ThisModeNum, float(-AmmoPerFire));
            }
        }
        LinkGun(Weapon).Linking = (LockedPawn != none) || bIsHealingObjective;
        // End:0xF81
        if(bShouldStop)
        {
            B.StopFiring();
        }
        // End:0x124A
        else
        {
            // End:0xFE6
            if((Beam == none) && bIsFiring)
            {
                Beam = Weapon.Spawn(BeamEffectClass, Instigator);
                // End:0xFDB
                if(SentLinkVolume == default.LinkVolume)
                {
                    SentLinkVolume = byte(default.LinkVolume + 1);
                }
                // End:0xFE6
                else
                {
                    SentLinkVolume = default.LinkVolume;
                }
            }
            // End:0x124A
            if(Beam != none)
            {
                // End:0x1134
                if(LinkGun.Linking || ((Other != none) && Instigator.PlayerReplicationInfo.Team != none) && Other.TeamLink(Instigator.PlayerReplicationInfo.Team.TeamIndex))
                {
                    Beam.LinkColor = byte(Instigator.PlayerReplicationInfo.Team.TeamIndex + 1);
                    // End:0x1131
                    if(LinkGun.ThirdPersonActor != none)
                    {
                        // End:0x1112
                        if((Instigator.PlayerReplicationInfo.Team == none) || Instigator.PlayerReplicationInfo.Team.TeamIndex == 0)
                        {
                            LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(1);
                        }
                        // End:0x1131
                        else
                        {
                            LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(2);
                        }
                    }
                }
                // End:0x11AE
                else
                {
                    Beam.LinkColor = 0;
                    // End:0x11AE
                    if(LinkGun.ThirdPersonActor != none)
                    {
                        // End:0x118F
                        if(LinkGun.Links > 0)
                        {
                            LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(3);
                        }
                        // End:0x11AE
                        else
                        {
                            LinkAttachment(LinkGun.ThirdPersonActor).SetLinkColor(0);
                        }
                    }
                }
                Beam.Links = byte(LinkGun.Links);
                Instigator.AmbientSound = BeamSounds[Min(Beam.Links, 3)];
                Instigator.SoundVolume = SentLinkVolume;
                Beam.LinkedPawn = LockedPawn;
                Beam.bHitSomething = Other != none;
                Beam.EndEffect = EndEffect;
            }
        }
    }
    // End:0x1253
    else
    {
        StopFiring();
    }
    bStartFire = false;
    bDoHit = false;
    // End:0x1272
    if(bNeedRevert)
    {
        UnTimeTravel();
    }
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_LinkGun(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_LinkGun(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_LinkGun(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_LinkGun(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}
