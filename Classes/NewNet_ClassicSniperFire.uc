/*******************************************************************************
 * NewNet_ClassicSniperFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_ClassicSniperFire extends ClassicSniperFire;

var float PingDT;
var bool bUseEnhancedNetCode;

function DoTrace(Vector Start, Rotator Dir)
{
    local Vector X, Y, Z, End, HitLocation, HitNormal,
	    arcEnd;

    local Actor Other;
    local SniperWallHitEffect S;
    local Pawn HeadShotPawn;
    local Vector PawnHitLocation;

    // End:0x1D
    if(!bUseEnhancedNetCode)
    {
        super.DoTrace(Start, Dir);
        return;
    }
    Weapon.GetViewAxes(X, Y, Z);
    // End:0xA3
    if(Weapon.WeaponCentered())
    {
        arcEnd = (Instigator.Location + (Weapon.EffectOffset.X * X)) + ((1.50 * Weapon.EffectOffset.Z) * Z);
    }
    // End:0x131
    else
    {
        arcEnd = (((Instigator.Location + Instigator.CalcDrawOffset(Weapon)) + (Weapon.EffectOffset.X * X)) + ((Weapon.hand * Weapon.EffectOffset.Y) * Y)) + (Weapon.EffectOffset.Z * Z);
    }
    X = vector(Dir);
    End = Start + (TraceRange * X);
    TimeTravel(PingDT);
    // End:0x19B
    if(PingDT <= 0.0)
    {
        Other = Weapon.Trace(HitLocation, HitNormal, End, Start, true);
    }
    // End:0x1BB
    else
    {
        Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);
    }
    // End:0x231
    if((Other != none) && Other.UnresolvedNativeFunction_97('NewNet_PawnCollisionCopy'))
    {
        PawnHitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
        Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
    }
    // End:0x23C
    else
    {
        PawnHitLocation = HitLocation;
    }
    UnTimeTravel();
    // End:0x2A0
    if((Level.NetMode != NM_Standalone) || PlayerController(Instigator.Controller) == none)
    {
        Weapon.UnresolvedNativeFunction_97(class'TracerProjectile', Instigator.Controller,, Start, Dir);
    }
    // End:0x414
    if((Other != none) && Other != Instigator)
    {
        // End:0x3F8
        if(!Other.bWorldGeometry)
        {
            // End:0x309
            if(Vehicle(Other) != none)
            {
                HeadShotPawn = Vehicle(Other).CheckForHeadShot(PawnHitLocation, X, 1.0);
            }
            // End:0x351
            if(HeadShotPawn != none)
            {
                HeadShotPawn.TakeDamage(int(float(DamageMax) * HeadShotDamageMult), Instigator, PawnHitLocation, Momentum * X, DamageTypeHeadShot);
            }
            // End:0x3F5
            else
            {
                // End:0x3C6
                if((Pawn(Other) != none) && Pawn(Other).IsHeadShot(HitLocation, X, 1.0))
                {
                    Other.TakeDamage(int(float(DamageMax) * HeadShotDamageMult), Instigator, PawnHitLocation, Momentum * X, DamageTypeHeadShot);
                }
                // End:0x3F5
                else
                {
                    Other.TakeDamage(DamageMax, Instigator, PawnHitLocation, Momentum * X, DamageType);
                }
            }
        }
        // End:0x411
        else
        {
            HitLocation = HitLocation + (2.0 * HitNormal);
        }
    }
    // End:0x433
    else
    {
        HitLocation = End;
        HitNormal = Normal(Start - End);
    }
    // End:0x4A9
    if((HitNormal != vect(0.0, 0.0, 0.0)) && HitScanBlockingVolume(Other) == none)
    {
        S = Weapon.UnresolvedNativeFunction_97(class'SniperWallHitEffect',,, HitLocation, rotator(float(-1) * HitNormal));
        // End:0x4A9
        if(S != none)
        {
            S.FireStart = Start;
        }
    }
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_ClassicSniperRifle(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_ClassicSniperRifle(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_ClassicSniperRifle(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_ClassicSniperRifle(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}
