/*******************************************************************************
 * NewNet_RocketMultiFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_RocketMultiFire extends WeaponFire_RocketAlt
    dependson(WeaponFire_RocketAlt);

const MAX_PROJECTILE_FUDGE = 0.075;

var Vector OldInstigatorLocation;
var Vector OldInstigatorEyePosition;
var Vector OldXAxis;
var Vector OldYAxis;
var Vector OldZAxis;
var Rotator OldAim;
var float OldLoad;
var class<Projectile> FakeProjectileClass;
var NewNet_FakeProjectileManager FPM;
var float NextAltTimerTime;
var bool bAltTimerActive;
var bool bUseEnhancedNetCode;

function PlayFiring()
{
    super(RocketMultiFire).PlayFiring();
    // End:0x1C
    if(!class'Misc_Player'.static.UseNewNet())
    {
        return;
    }
    CheckFireEffect();
    //return;    
}

simulated function CheckFireEffect()
{
    local float Ping;

    // End:0xF2
    if((Level.NetMode == NM_Client) && Instigator.IsLocallyControlled())
    {
        Ping = class'NewNet_PRI'.default.PredictedPing - (0.50 * class'NewNet_TimeStamp'.default.AverDT);
        // End:0x70
        if(Ping <= 0.0750)
        {
            DoClientFireEffect();
        }
        // End:0xF2
        else
        {
            OldInstigatorLocation = Instigator.Location;
            OldInstigatorEyePosition = Instigator.EyePosition();
            Weapon.GetViewAxes(OldXAxis, OldYAxis, OldZAxis);
            OldAim = AdjustAim(OldInstigatorLocation + OldInstigatorEyePosition, aimerror);
            OldLoad = load;
            SetAltTimer(Ping - 0.0750, false);
        }
    }
    //return;    
}

simulated function FindFPM()
{
    // End:0x1D
    foreach Weapon.DynamicActors(class'NewNet_FakeProjectileManager', FPM)
    {
        // End:0x1D
        break;        
    }    
    //return;    
}

simulated function ModeTick(float dt)
{
    super(RocketMultiFire).ModeTick(dt);
    // End:0x26
    if(Level.NetMode != NM_Client)
    {
        return;
    }
    // End:0x57
    if(bAltTimerActive && Level.TimeSeconds > NextAltTimerTime)
    {
        AltTimer();
        bAltTimerActive = false;
    }
    //return;    
}

simulated function SetAltTimer(float F, bool B)
{
    NextAltTimerTime = Level.TimeSeconds + F;
    bAltTimerActive = true;
    //return;    
}

simulated function AltTimer()
{
    DoTimedClientFireEffect();
    //return;    
}

simulated function DoClientFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator Aim;
    local Vector HitLocation, HitNormal, FireLocation;
    local Actor Other;
    local int P, Q, SpawnCount, i;
    local RocketProj FiredRockets[4];
    local bool bCurl;

    // End:0x28
    if((SpreadStyle == 2) || load < float(2))
    {
        SuperDoFireEffect();
        return;
    }
    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    StartTrace = Instigator.Location + Instigator.EyePosition();
    StartProj = (StartTrace + (X * ProjSpawnOffset.X)) + (Z * ProjSpawnOffset.Z);
    // End:0xEF
    if(!Weapon.WeaponCentered())
    {
        StartProj = StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x12C
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = AdjustAim(StartProj, aimerror);
    SpawnCount = Max(1, int(load));
    P = 0;
    J0x159:
    // End:0x21E [Loop If]
    if(P < SpawnCount)
    {
        FireLocation = (StartProj - (float(2) * ((((Sin((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Y) - (((Cos((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Z)))) - ((X * float(8)) * FRand());
        FiredRockets[P] = RocketProj(SpawnFakeProjectile(FireLocation, Aim, P));
        ++ P;
        // [Loop Continue]
        goto J0x159;
    }
    // End:0x22C
    if(SpawnCount < 2)
    {
        return;
    }
    ++ FlockIndex;
    // End:0x248
    if(FlockIndex == 0)
    {
        FlockIndex = 1;
    }
    P = 0;
    J0x24F:
    // End:0x365 [Loop If]
    if(P < SpawnCount)
    {
        // End:0x35B
        if(FiredRockets[P] != none)
        {
            FiredRockets[P].bCurl = bCurl;
            FiredRockets[P].FlockIndex = FlockIndex;
            i = 0;
            Q = 0;
            J0x2B3:
            // End:0x31B [Loop If]
            if(Q < SpawnCount)
            {
                // End:0x311
                if((P != Q) && FiredRockets[Q] != none)
                {
                    FiredRockets[P].Flock[i] = FiredRockets[Q];
                    ++ i;
                }
                ++ Q;
                // [Loop Continue]
                goto J0x2B3;
            }
            bCurl = !bCurl;
            // End:0x35B
            if(Level.NetMode != NM_DedicatedServer)
            {
                FiredRockets[P].SetTimer(0.10, true);
            }
        }
        ++ P;
        // [Loop Continue]
        goto J0x24F;
    }
    //return;    
}

simulated function DoTimedClientFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator Aim;
    local Vector HitLocation, HitNormal, FireLocation;
    local Actor Other;
    local int P, Q, SpawnCount, i;
    local RocketProj FiredRockets[4];
    local bool bCurl;

    // End:0x28
    if((SpreadStyle == 2) || OldLoad < float(2))
    {
        SuperDoTimedFireEffect();
        return;
    }
    Instigator.MakeNoise(1.0);
    X = OldXAxis;
    Y = OldYAxis;
    Z = OldZAxis;
    StartTrace = OldInstigatorLocation + OldInstigatorEyePosition;
    StartProj = (StartTrace + (X * ProjSpawnOffset.X)) + (Z * ProjSpawnOffset.Z);
    // End:0xDF
    if(!Weapon.WeaponCentered())
    {
        StartProj = StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x11C
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = OldAim;
    SpawnCount = Max(1, int(OldLoad));
    P = 0;
    J0x13E:
    // End:0x203 [Loop If]
    if(P < SpawnCount)
    {
        FireLocation = (StartProj - (float(2) * ((((Sin((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Y) - (((Cos((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Z)))) - ((X * float(8)) * FRand());
        FiredRockets[P] = RocketProj(SpawnFakeProjectile(FireLocation, Aim, P));
        ++ P;
        // [Loop Continue]
        goto J0x13E;
    }
    // End:0x211
    if(SpawnCount < 2)
    {
        return;
    }
    ++ FlockIndex;
    // End:0x22D
    if(FlockIndex == 0)
    {
        FlockIndex = 1;
    }
    P = 0;
    J0x234:
    // End:0x34A [Loop If]
    if(P < SpawnCount)
    {
        // End:0x340
        if(FiredRockets[P] != none)
        {
            FiredRockets[P].bCurl = bCurl;
            FiredRockets[P].FlockIndex = FlockIndex;
            i = 0;
            Q = 0;
            J0x298:
            // End:0x300 [Loop If]
            if(Q < SpawnCount)
            {
                // End:0x2F6
                if((P != Q) && FiredRockets[Q] != none)
                {
                    FiredRockets[P].Flock[i] = FiredRockets[Q];
                    ++ i;
                }
                ++ Q;
                // [Loop Continue]
                goto J0x298;
            }
            bCurl = !bCurl;
            // End:0x340
            if(Level.NetMode != NM_DedicatedServer)
            {
                FiredRockets[P].SetTimer(0.10, true);
            }
        }
        ++ P;
        // [Loop Continue]
        goto J0x234;
    }
    //return;    
}

simulated function SuperDoTimedFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    X = OldXAxis;
    Y = OldYAxis;
    Z = OldZAxis;
    StartTrace = OldInstigatorLocation + OldInstigatorEyePosition;
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xB7
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0xF4
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = OldAim;
    SpawnCount = Max(1, ProjPerFire * int(OldLoad));
    switch(SpreadStyle)
    {
        // End:0x1C8
        case 1:
            X = vector(Aim);
            P = 0;
            J0x136:
            // End:0x1C5 [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                SpawnFakeProjectile(StartProj, rotator(X >> R), P);
                ++ P;
                // [Loop Continue]
                goto J0x136;
            }
            // End:0x28E
            break;
        // End:0x27A
        case 2:
            P = 0;
            J0x1D4:
            // End:0x277 [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                SpawnFakeProjectile(StartProj, rotator(X >> Aim), P);
                ++ P;
                // [Loop Continue]
                goto J0x1D4;
            }
            // End:0x28E
            break;
        // End:0xFFFF
        default:
            SpawnFakeProjectile(StartProj, Aim, 0);
            //return;
    }    
}

simulated function Projectile SpawnFakeProjectile(Vector Start, Rotator Dir, int Index)
{
    local Projectile P;

    // End:0x1E
    if(FPM == none)
    {
        FindFPM();
        // End:0x1E
        if(FPM == none)
        {
            return none;
        }
    }
    // End:0x6A
    if(FPM.AllowFakeProjectile(FakeProjectileClass, Index))
    {
        P = Weapon.UnresolvedNativeFunction_97(FakeProjectileClass, Weapon.Owner,, Start, Dir);
    }
    // End:0x77
    if(P == none)
    {
        return none;
    }
    FPM.RegisterFakeProjectile(P, Index);
    return P;
    //return;    
}

function Projectile AltSpawnProjectile(Vector Start, Rotator Dir, int Index)
{
    local Projectile P;

    P = RocketLauncher(Weapon).SpawnProjectile(Start, Dir);
    // End:0x44
    if(P != none)
    {
        P.Damage *= DamageAtten;
    }
    // End:0x71
    if(P.UnresolvedNativeFunction_97('NewNet_RocketProj'))
    {
        NewNet_RocketProj(P).Index = Index;
    }
    // End:0x9E
    if(P.UnresolvedNativeFunction_97('NewNet_SeekingRocketProj'))
    {
        NewNet_SeekingRocketProj(P).Index = Index;
    }
    return P;
    //return;    
}

function DoFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator Aim;
    local Vector HitLocation, HitNormal, FireLocation;
    local Actor Other;
    local int P, Q, SpawnCount, i;
    local RocketProj FiredRockets[4];
    local bool bCurl;

    // End:0x13
    if(!bUseEnhancedNetCode)
    {
        super(RocketMultiFire).DoFireEffect();
        return;
    }
    // End:0x3B
    if((SpreadStyle == 2) || load < float(2))
    {
        SuperServerDoFireEffect();
        return;
    }
    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    StartTrace = Instigator.Location + Instigator.EyePosition();
    StartProj = (StartTrace + (X * ProjSpawnOffset.X)) + (Z * ProjSpawnOffset.Z);
    // End:0x102
    if(!Weapon.WeaponCentered())
    {
        StartProj = StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x13F
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = AdjustAim(StartProj, aimerror);
    SpawnCount = Max(1, int(load));
    P = 0;
    J0x16C:
    // End:0x231 [Loop If]
    if(P < SpawnCount)
    {
        FireLocation = (StartProj - (float(2) * ((((Sin((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Y) - (((Cos((float(P * 2) * 3.1415930) / float(MaxLoad)) * float(8)) - float(7)) * Z)))) - ((X * float(8)) * FRand());
        FiredRockets[P] = RocketProj(AltSpawnProjectile(FireLocation, Aim, P));
        ++ P;
        // [Loop Continue]
        goto J0x16C;
    }
    // End:0x23F
    if(SpawnCount < 2)
    {
        return;
    }
    ++ FlockIndex;
    // End:0x25B
    if(FlockIndex == 0)
    {
        FlockIndex = 1;
    }
    P = 0;
    J0x262:
    // End:0x378 [Loop If]
    if(P < SpawnCount)
    {
        // End:0x36E
        if(FiredRockets[P] != none)
        {
            FiredRockets[P].bCurl = bCurl;
            FiredRockets[P].FlockIndex = FlockIndex;
            i = 0;
            Q = 0;
            J0x2C6:
            // End:0x32E [Loop If]
            if(Q < SpawnCount)
            {
                // End:0x324
                if((P != Q) && FiredRockets[Q] != none)
                {
                    FiredRockets[P].Flock[i] = FiredRockets[Q];
                    ++ i;
                }
                ++ Q;
                // [Loop Continue]
                goto J0x2C6;
            }
            bCurl = !bCurl;
            // End:0x36E
            if(Level.NetMode != NM_DedicatedServer)
            {
                FiredRockets[P].SetTimer(0.10, true);
            }
        }
        ++ P;
        // [Loop Continue]
        goto J0x262;
    }
    //return;    
}

simulated function SuperDoFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    StartTrace = Instigator.Location + Instigator.EyePosition();
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xC7
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x104
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = AdjustAim(StartProj, aimerror);
    SpawnCount = Max(1, ProjPerFire * int(load));
    switch(SpreadStyle)
    {
        // End:0x1E3
        case 1:
            X = vector(Aim);
            P = 0;
            J0x151:
            // End:0x1E0 [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                SpawnFakeProjectile(StartProj, rotator(X >> R), P);
                ++ P;
                // [Loop Continue]
                goto J0x151;
            }
            // End:0x2A9
            break;
        // End:0x295
        case 2:
            P = 0;
            J0x1EF:
            // End:0x292 [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                SpawnFakeProjectile(StartProj, rotator(X >> Aim), P);
                ++ P;
                // [Loop Continue]
                goto J0x1EF;
            }
            // End:0x2A9
            break;
        // End:0xFFFF
        default:
            SpawnFakeProjectile(StartProj, Aim, 0);
            //return;
    }    
}

function SuperServerDoFireEffect()
{
    local Vector StartProj, StartTrace, X, Y, Z;

    local Rotator R, Aim;
    local Vector HitLocation, HitNormal;
    local Actor Other;
    local int P, SpawnCount;
    local float theta;

    Instigator.MakeNoise(1.0);
    Weapon.GetViewAxes(X, Y, Z);
    StartTrace = Instigator.Location + Instigator.EyePosition();
    StartProj = StartTrace + (X * ProjSpawnOffset.X);
    // End:0xC7
    if(!Weapon.WeaponCentered())
    {
        StartProj = (StartProj + ((Weapon.hand * Y) * ProjSpawnOffset.Y)) + (Z * ProjSpawnOffset.Z);
    }
    Other = Weapon.Trace(HitLocation, HitNormal, StartProj, StartTrace, false);
    // End:0x104
    if(Other != none)
    {
        StartProj = HitLocation;
    }
    Aim = AdjustAim(StartProj, aimerror);
    SpawnCount = Max(1, ProjPerFire * int(load));
    switch(SpreadStyle)
    {
        // End:0x1E3
        case 1:
            X = vector(Aim);
            P = 0;
            J0x151:
            // End:0x1E0 [Loop If]
            if(P < SpawnCount)
            {
                R.Yaw = int(Spread * (FRand() - 0.50));
                R.Pitch = int(Spread * (FRand() - 0.50));
                R.Roll = int(Spread * (FRand() - 0.50));
                AltSpawnProjectile(StartProj, rotator(X >> R), P);
                ++ P;
                // [Loop Continue]
                goto J0x151;
            }
            // End:0x2A9
            break;
        // End:0x295
        case 2:
            P = 0;
            J0x1EF:
            // End:0x292 [Loop If]
            if(P < SpawnCount)
            {
                theta = ((Spread * 3.1415930) / float(32768)) * (float(P) - (float(SpawnCount - 1) / 2.0));
                X.X = Cos(theta);
                X.Y = Sin(theta);
                X.Z = 0.0;
                AltSpawnProjectile(StartProj, rotator(X >> Aim), P);
                ++ P;
                // [Loop Continue]
                goto J0x1EF;
            }
            // End:0x2A9
            break;
        // End:0xFFFF
        default:
            AltSpawnProjectile(StartProj, Aim, 0);
            //return;
    }    
}

defaultproperties
{
    FakeProjectileClass=class'NewNet_Fake_RocketProj'
}