/*******************************************************************************
 * NewNet_BioChargedFire generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_BioChargedFire extends WeaponFire_BioAlt
    dependson(WeaponFire_BioAlt);

const PROJ_TIMESTEP = 0.0201;
const MAX_PROJECTILE_FUDGE = 0.07500;

var float PingDT;
var bool bUseEnhancedNetCode;

function Projectile SpawnProjectile(Vector Start, Rotator Dir)
{
    local Rotator NewDir;
    local float F, G;
    local Vector End, HitLocation, HitNormal, VZ;
    local Actor Other;
    local BioGlob Glob;

    GotoState('None');
    // End:0x14
    if(GoopLoad == 0)
    {
        return none;
    }
    // End:0x30
    if(!bUseEnhancedNetCode)
    {
        return super(BioChargedFire).SpawnProjectile(Start, Dir);
    }
    // End:0x238
    if(class'BioGlob' != none)
    {
        // End:0x215
        if((PingDT > 0.0) && Weapon.Owner != none)
        {
            NewDir = Dir;
            F = 0.0;
            J0x76:
            // End:0x11C [Loop If]
            if(F < (PingDT + 0.02010))
            {
                G = FMin(PingDT, F);
                End = Start + (Extrapolate(NewDir, 0.02010, byte(GoopLoad)));
                TimeTravel(PingDT - G);
                Other = DoTimeTravelTrace(HitLocation, HitNormal, End, Start);
                // End:0x102
                if(Other != none)
                {
                    // [Explicit Break]
                    goto J0x11C;
                }
                Start = End;
                F += 0.02010;
                J0x11C:
                // [Loop Continue]
                goto J0x76;
            }
            UnTimeTravel();
            // End:0x195
            if((Other != none) && Other.UnresolvedNativeFunction_97('NewNet_PawnCollisionCopy'))
            {
                HitLocation = (HitLocation + NewNet_PawnCollisionCopy(Other).CopiedPawn.Location) - Other.Location;
                Other = NewNet_PawnCollisionCopy(Other).CopiedPawn;
            }
            VZ.Z = class'BioGlob'.default.TossZ;
            // End:0x1DF
            if(Other == none)
            {
                Glob = Weapon.UnresolvedNativeFunction_97(class'BioGlob',,, End, NewDir);
            }
            // End:0x212
            else
            {
                Glob = Weapon.UnresolvedNativeFunction_97(class'BioGlob',,, HitLocation - (vector(NewDir) * 16.0), NewDir);
            }
        }
        // End:0x238
        else
        {
            Glob = Weapon.UnresolvedNativeFunction_97(class'BioGlob',,, Start, Dir);
        }
    }
    // End:0x27B
    if(Glob != none)
    {
        Glob.Damage *= DamageAtten;
        Glob.SetGoopLevel(GoopLoad);
        Glob.AdjustSpeed();
    }
    GoopLoad = 0;
    // End:0x2AB
    if(Weapon.AmmoAmount(ThisModeNum) <= 0)
    {
        Weapon.OutOfAmmo();
    }
    return Glob;
    //return;    
}

function Vector Extrapolate(out Rotator Dir, float dF, byte GoopLoad)
{
    local Rotator oldDir;
    local float GooSpeed;

    oldDir = Dir;
    // End:0x2F
    if(GoopLoad < 1)
    {
        GooSpeed = class'BioGlob'.default.Speed;
    }
    // End:0x63
    else
    {
        GooSpeed = (class'BioGlob'.default.Speed * (0.40 + float(GoopLoad))) / (1.40 * float(GoopLoad));
    }
    Dir = rotator((vector(oldDir) * GooSpeed) + (Weapon.Owner.PhysicsVolume.Gravity * dF));
    return ((vector(oldDir) * GooSpeed) * dF) + ((0.50 * Square(dF)) * Weapon.Owner.PhysicsVolume.Gravity);
    //return;    
}

function Actor DoTimeTravelTrace(out Vector HitLocation, out Vector HitNormal, Vector End, Vector Start)
{
    local Actor Other;
    local bool bFoundPCC;
    local Vector NewEnd, WorldHitNormal, WorldHitLocation, PCCHitNormal, PCCHitLocation;

    local NewNet_PawnCollisionCopy PCC, returnPCC;

    // End:0x8D
    foreach Weapon.TraceActors(class'Actor', Other, WorldHitLocation, WorldHitNormal, End, Start)
    {
        // End:0x85
        if(((Other.bBlockActors || Other.bProjTarget) || Other.bWorldGeometry) && !class'TAM_Mutator'.static.IsPredicted(Other))
        {
            // End:0x8D
            break;
        }
        Other = none;        
    }    
    // End:0xA7
    if(Other != none)
    {
        NewEnd = WorldHitLocation;
    }
    // End:0xB2
    else
    {
        NewEnd = End;
    }
    // End:0x131
    foreach Weapon.TraceActors(class'NewNet_PawnCollisionCopy', PCC, PCCHitLocation, PCCHitNormal, NewEnd, Start)
    {
        // End:0x130
        if(((PCC != none) && PCC.CopiedPawn != none) && PCC.CopiedPawn != Instigator)
        {
            bFoundPCC = true;
            returnPCC = PCC;
            // End:0x131
            break;
        }        
    }    
    // End:0x15A
    if(bFoundPCC)
    {
        HitLocation = PCCHitLocation;
        HitNormal = PCCHitNormal;
        return returnPCC;
    }
    // End:0x176
    else
    {
        HitLocation = WorldHitLocation;
        HitNormal = WorldHitNormal;
        return Other;
    }
    //return;    
}

function TimeTravel(float Delta)
{
    local NewNet_PawnCollisionCopy PCC;

    // End:0x45
    if(NewNet_BioRifle(Weapon).M == none)
    {
        // End:0x44
        foreach Weapon.DynamicActors(class'TAM_Mutator', NewNet_BioRifle(Weapon).M)
        {
            // End:0x44
            break;            
        }        
    }
    PCC = NewNet_BioRifle(Weapon).M.PCC;
    J0x67:
    // End:0x9D [Loop If]
    if(PCC != none)
    {
        PCC.TimeTravelPawn(Delta);
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x67;
    }
    //return;    
}

function UnTimeTravel()
{
    local NewNet_PawnCollisionCopy PCC;

    PCC = NewNet_BioRifle(Weapon).M.PCC;
    J0x22:
    // End:0x53 [Loop If]
    if(PCC != none)
    {
        PCC.TurnOffCollision();
        PCC = PCC.Next;
        // [Loop Continue]
        goto J0x22;
    }
    //return;    
}
