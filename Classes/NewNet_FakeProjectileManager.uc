/*******************************************************************************
 * NewNet_FakeProjectileManager generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2013 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class NewNet_FakeProjectileManager extends Actor
    notplaceable;

struct FPindex
{
    var Projectile FP;
    var int Index;
};

var array<FPindex> FP;

simulated function RegisterFakeProjectile(Projectile P, optional int Index)
{
    local int i;

    i = FP.Length + 1;
    FP.Length = i;
    FP[i - 1].FP = P;
    FP[i - 1].Index = Index;
    //return;    
}

simulated function bool AllowFakeProjectile(class<Projectile> pClass, optional int Index)
{
    local int i;

    CleanUpProjectiles();
    i = 0;
    J0x0D:
    // End:0x80 [Loop If]
    if(i < FP.Length)
    {
        // End:0x76
        if(((FP[i].FP != none) && FP[i].FP.Class == pClass) && FP[i].Index == Index)
        {
            return false;
        }
        ++ i;
        // [Loop Continue]
        goto J0x0D;
    }
    return true;
    //return;    
}

simulated function CleanUpProjectiles()
{
    local int i;

    i = FP.Length - 1;
    J0x0F:
    // End:0x46 [Loop If]
    if(i >= 0)
    {
        // End:0x3C
        if(FP[i].FP == none)
        {
            FP.Remove(i, 1);
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    //return;    
}

simulated function RemoveProjectile(Projectile P)
{
    local int i;

    i = FP.Length - 1;
    J0x0F:
    // End:0x62 [Loop If]
    if(i >= 0)
    {
        // End:0x58
        if((FP[i].FP == none) || FP[i].FP == P)
        {
            FP.Remove(i, 1);
        }
        -- i;
        // [Loop Continue]
        goto J0x0F;
    }
    P.Destroy();
    //return;    
}

simulated function Projectile GetFP(class<Projectile> CP, optional int Index)
{
    local int i;

    i = 0;
    J0x07:
    // End:0x89 [Loop If]
    if(i < FP.Length)
    {
        // End:0x7F
        if(((FP[i].FP != none) && FP[i].FP.Class == CP) && FP[i].Index == Index)
        {
            return FP[i].FP;
        }
        ++ i;
        // [Loop Continue]
        goto J0x07;
    }
    return none;
    //return;    
}

defaultproperties
{
    bHidden=true
}